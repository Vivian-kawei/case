{"version":3,"sources":["webpack:///static/js/vendor.62133dbcf281a58ed4c6.js","webpack:///./~/prosemirror-model/dist/index.js","webpack:///./~/prosemirror-state/dist/index.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/prosemirror-transform/dist/index.js","webpack:///./~/prosemirror-model/dist/fragment.js","webpack:///./~/prosemirror-model/dist/mark.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/prosemirror-commands/dist/commands.js","webpack:///./~/prosemirror-transform/dist/map.js","webpack:///./~/prosemirror-transform/dist/replace_step.js","webpack:///./~/prosemirror-transform/dist/transform.js","webpack:///./~/prosemirror-view/dist/browser.js","webpack:///./~/vue/dist/vue.common.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/prosemirror-history/dist/history.js","webpack:///./~/prosemirror-inputrules/dist/inputrules.js","webpack:///./~/prosemirror-model/dist/replace.js","webpack:///./~/prosemirror-state/dist/selection.js","webpack:///./~/prosemirror-transform/dist/step.js","webpack:///./~/prosemirror-view/dist/index.js","webpack:///./~/babel-runtime/core-js/json/stringify.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/crel/crel.js","webpack:///./~/prosemirror-inputrules/dist/index.js","webpack:///./~/prosemirror-menu/dist/menu.js","webpack:///./~/prosemirror-model/dist/comparedeep.js","webpack:///./~/prosemirror-model/dist/content.js","webpack:///./~/prosemirror-model/dist/node.js","webpack:///./~/prosemirror-model/dist/resolvedpos.js","webpack:///./~/prosemirror-schema-list/dist/schema-list.js","webpack:///./~/prosemirror-schema-table/dist/schema-table.js","webpack:///./~/prosemirror-state/dist/transaction.js","webpack:///./~/prosemirror-transform/dist/mark_step.js","webpack:///./~/prosemirror-transform/dist/structure.js","webpack:///./~/prosemirror-view/dist/decoration.js","webpack:///./~/prosemirror-view/dist/trackmappings.js","webpack:///./~/babel-runtime/core-js/array/from.js","webpack:///./~/babel-runtime/core-js/object/assign.js","webpack:///./~/babel-runtime/helpers/toConsumableArray.js","webpack:///./~/core-js/library/fn/array/from.js","webpack:///./~/core-js/library/fn/json/stringify.js","webpack:///./~/core-js/library/fn/object/assign.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_classof.js","webpack:///./~/core-js/library/modules/_create-property.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_is-array-iter.js","webpack:///./~/core-js/library/modules/_iter-call.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_iter-detect.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_object-assign.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/core-js/library/modules/es6.array.from.js","webpack:///./~/core-js/library/modules/es6.object.assign.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/nprogress/nprogress.js","webpack:///./~/orderedmap/index.js","webpack:///./~/prosemirror-dropcursor/dist/dropcursor.js","webpack:///./~/prosemirror-example-setup/dist/index.js","webpack:///./~/prosemirror-example-setup/dist/keymap.js","webpack:///./~/prosemirror-example-setup/dist/menu.js","webpack:///./~/prosemirror-example-setup/dist/prompt.js","webpack:///./~/prosemirror-inputrules/dist/rules.js","webpack:///./~/prosemirror-inputrules/dist/util.js","webpack:///./~/prosemirror-keymap/dist/keymap.js","webpack:///./~/prosemirror-menu/dist/icons.js","webpack:///./~/prosemirror-menu/dist/index.js","webpack:///./~/prosemirror-menu/dist/menubar.js","webpack:///./~/prosemirror-model/dist/diff.js","webpack:///./~/prosemirror-model/dist/from_dom.js","webpack:///./~/prosemirror-model/dist/schema.js","webpack:///./~/prosemirror-model/dist/to_dom.js","webpack:///./~/prosemirror-schema-basic/dist/schema-basic.js","webpack:///./~/prosemirror-state/dist/plugin.js","webpack:///./~/prosemirror-state/dist/state.js","webpack:///./~/prosemirror-transform/dist/mark.js","webpack:///./~/prosemirror-transform/dist/replace.js","webpack:///./~/prosemirror-view/dist/capturekeys.js","webpack:///./~/prosemirror-view/dist/clipboard.js","webpack:///./~/prosemirror-view/dist/domchange.js","webpack:///./~/prosemirror-view/dist/domcoords.js","webpack:///./~/prosemirror-view/dist/input.js","webpack:///./~/prosemirror-view/dist/selection.js","webpack:///./~/prosemirror-view/dist/viewdesc.js","webpack:///./~/rope-sequence/dist/index.js","webpack:///./~/vue-resource/dist/vue-resource.common.js","webpack:///./~/vue-router/dist/vue-router.common.js","webpack:///./~/w3c-keyname/index.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/addStyles.js"],"names":["webpackJsonp","module","exports","__webpack_require__","Node","assign","ResolvedPos","NodeRange","Fragment","assign$1","Slice","ReplaceError","Mark","assign$2","Schema","NodeType","MarkType","assign$3","ContentMatch","DOMParser","DOMSerializer","Selection","TextSelection","NodeSelection","Transaction","EditorState","Plugin","PluginKey","store","uid","Symbol","USE_SYMBOL","$exports","name","Transform","TransformError","Step","StepResult","joinPoint","canJoin","canSplit","insertPoint","liftTarget","findWrapping","StepMap","MapResult","Mapping","assign$4","AddMarkStep","RemoveMarkStep","assign$5","ReplaceStep","ReplaceAroundStep","assign$6","replaceStep","retIndex","index","offset","found","ref","findDiffStart","findDiffEnd","content","size","this$1","this","i","length","nodeSize","prototypeAccessors","firstChild","lastChild","childCount","prototype","nodesBetween","from","to","f","nodeStart","parent","pos","child","end","start","Math","max","min","textBetween","blockSeparator","leafText","text","separated","node","isText","slice","isLeaf","isBlock","append","other","last","first","sameMarkup","withText","push","cut","result","cutByIndex","empty","replaceChild","current","copy","addToStart","concat","addToEnd","eq","get","RangeError","offsetAt","maybeChild","forEach","p","otherPos","findIndex","round","curPos","cur","toString","toStringInner","join","toJSON","map","n","fromJSON","schema","value","nodeFromJSON","fromArray","array","joined","nodes","Array","isArray","Object","defineProperties","compareDeep","type","attrs","addToSet","set","rank","removeFromSet","isInSet","obj","_","json","marks","create","sameSet","a","b","setFrom","none","sort","core","version","__e","global","window","self","Function","__g","isObject","it","TypeError","defineProperty","hasOwnProperty","key","call","dP","createDesc","object","anObject","IE8_DOM_DEFINE","toPrimitive","O","P","Attributes","e","deleteSelection","state","dispatch","selection","$from","$to","tr","scrollIntoView","sameParent","isTextblock","setStoredMarks","joinBackward","view","$head","endOfTextblock","parentOffset","before","depth","range","blockRange","target","lift","isSelectable","delete","setSelection","doc","deleteBarrier","selectNextNode","joinForward","after","joinUp","point","resolve","nodeBefore","joinDown","nodeAt","joinPointBelow","newlineInCode","anchor","spec","code","sharedDepth","insertText","exitCode","above","indexAfter","defaultContentType","canReplaceWith","replaceWith","createAndFill","near","createParagraphNear","side","insert","liftEmptyBlock","split","splitBlock","atEnd","deflt","types","can","canReplace","setNodeType","selectParentNode","sel","same","joinMaybeClear","$pos","nodeAfter","compatibleContent","clearNonMatching","contentMatchAt","conn","match","$cut","findWrappingFor","matchType","validEnd","wrap","step","joinAt","selAfter","findFrom","dir","wrapIn","nodeType","wrapping","setBlockType","hasMarkup","where","contentExpr","markApplies","allowsMark","toggleMark","markType","storedMarks","removeStoredMark","addStoredMark","rangeHasMark","removeMark","addMark","wrapDispatchForJoin","isJoinable","isGeneric","ranges","mapping","maps","j","_s","_e","joinable","i$1","indexOf","i$2","autoJoin","command","chainCommands","commands","len","arguments","ref$1","ref$2","baseKeymap","Enter","Mod-Enter","Backspace","Mod-Backspace","Delete","Mod-Delete","Alt-ArrowUp","Alt-ArrowDown","Mod-BracketLeft","Escape","mac","navigator","test","platform","os","extra","Ctrl-h","Alt-Backspace","Ctrl-d","Ctrl-Alt-Backspace","Alt-Delete","Alt-d","prop","makeRecover","factor16","recoverIndex","lower16","recoverOffset","pow","deleted","recover","inverted","diff","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","JSON","stringify","mirror","getMirror","setMirror","m","appendMap","mirrors","appendMapping","startSize","mirr","recoverables","rec","corr","contentBetween","dist","next","structure","__proto__","constructor","apply","fail","fromReplace","getMap","merge","openRight","openLeft","slice$1","stepType","jsonID","gapFrom","gapTo","gap","inserted","insertAt","removeBetween","Error","steps","docs","maybeStep","failed","addStep","ie_upto10","userAgent","ie_11up","exec","ie","ie_version","document","documentMode","gecko","ios","webkit","documentElement","style","_toString","val","String","toNumber","parseFloat","makeMap","str","expectsLowerCase","list","toLowerCase","remove$1","arr","item","splice","hasOwn","isPrimitive","cached","fn","cache","hit","bind$1","ctx","boundFn","l","_length","toArray","ret","extend","_from","isPlainObject","OBJECT_STRING","toObject","res","noop","genStaticKeys","modules","reduce","keys","staticKeys","looseEqual","isObjectA","isObjectB","looseIndexOf","isReserved","c","charCodeAt","def","enumerable","writable","configurable","parsePath","path","bailRE","segments","isNative","Ctor","pushTarget","_target","Dep","targetStack","popTarget","pop","protoAugment","src","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","dep","property","getOwnPropertyDescriptor","getter","setter","childOb","depend","dependArray","newVal","notify","set$1","del","mergeData","toVal","fromVal","mergeHook","parentVal","childVal","mergeAssets","normalizeProps","options","props","camelize","normalizeDirectives","dirs","directives","bind","update","mergeOptions","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","mixin","Vue$3","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","absent","isType","Boolean","hyphenate","undefined","getPropDefaultValue","prevShouldConvert","default","$options","getType","resetSchedulerState","queue","has$1","waiting","flushing","flushSchedulerQueue","watcher","run","devtools","config","emit","queueWatcher","nextTick","traverse","seenObjects","clear","_traverse","seen","isA","depId","has","add","initState","_watchers","opts","initProps","methods","initMethods","data","initData","_data","computed","initComputed","watch","initWatch","_propKeys","isRoot","$parent","loop","proxy","userDef","computedSharedDefinition","makeComputedGetter","owner","Watcher","lazy","dirty","evaluate","handler","createWatcher","$watch","stateMixin","Vue","dataDef","$set","$delete","expOrFn","cb","user","immediate","teardown","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","children","elm","context","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","mergeVNodeHook","hookKey","hook","injectedHash","__injected","oldHook","updateListeners","on","oldOn","remove$$1","old","event","capture","once","charAt","invoker","arrInvoker","fnInvoker","ev","arguments$1","single","o","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","getFirstComponentChild","filter","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","add$1","$once","$on","remove$2","$off","oldListeners","eventsMixin","hookRE","cbs","$emit","args","initLifecycle","abstract","$children","$root","$refs","_watcher","_inactive","_isMounted","_isDestroyed","_isBeingDestroyed","lifecycleMixin","_mount","el","hydrating","$el","render","createEmptyVNode","callHook","_update","_render","$vnode","prevEl","prevVnode","_vnode","prevActiveInstance","activeInstance","__patch__","_parentElm","_refElm","__vue__","_updateFromParent","parentVnode","renderChildren","hasChildren","_renderChildren","_parentVnode","propKeys","$slots","resolveSlots","$forceUpdate","$destroy","handlers","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","resolveConstructorOptions","extractProps","functional","createFunctionalComponent","nativeOn","mergeHooks","_context","h","d","createElement","slots","functionalContext","slot","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","inlineTemplate","staticRenderFns","init","$mount","keepAlive","mountedNode","prepatch","oldVnode","destroy$1","factory","requested","pendingCallbacks","sync","reject","reason","then","domProps","altKey","checkProp","hash","preserve","hooksToMerge","fromParent","ours","hooks","mergeHook$1","one","two","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","scopedSlots","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","initRender","_staticTrees","renderContext","$scopedSlots","_c","$createElement","renderMixin","markStatic","tree","isOnce","markStaticNode","$nextTick","_renderProxy","errorHandler","_v","_n","_q","_i","_m","isInFor","_o","_f","identity","_l","_t","fallback","bindObject","scopedSlotFn","slotNodes","_b","asProp","mustUseProp","_k","eventKeyCode","builtInAlias","keyCodes","defaultSlot","isComment","initMixin","_init","_uid","initInternalComponent","_self","super","superOptions","cachedSuperOptions","extendOptions","_scopeId","components","initUse","use","plugin","installed","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","_assetTypes","initAssetRegisters","definition","matches","pattern","initGlobalAPI","configDef","util","builtInComponents","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","inBrowser","unknownElementCache","HTMLUnknownElement","HTMLElement","query","querySelector","createElement$1","tagName","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","refs","refInFor","isUndef","s","isDef","sameVnode","vnode1","vnode2","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","emptyNodeAt","nodeOps","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isRootInsert","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","innerNode","transition","activate","emptyNode","isPatchable","pendingInsert","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","rm","remove","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hasData","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","isRenderedModule","hooks$1","isInitialPatch","isRealElement","hasAttribute","removeAttribute","ancestor","updateDirectives","oldDir","isCreate","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","add$2","oldHandler","remove$3","target$1","addEventListener","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","isDirty","_value","strCur","shouldUpdateValue","checkVal","composing","isInputChanged","activeElement","_vModifiers","number","trim","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","setProp","addClass","classList","getAttribute","removeClass","tar","replace","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","onEnd","setTimeout","styles","getComputedStyle","transitioneDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","resolveTransition","_enterCb","css","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","expectsCSS","userWantsControl","show","pendingNode","_pending","leave","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","afterLeave","leaveCancelled","delayLeave","def$$1","autoCssTransition","called","_enter","setSelected","binding","isMultiple","multiple","selected","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","shouldDecode","encoded","div","innerHTML","decode","html","decoder","decodeAttr","shouldDecodeNewlines","nlRE","ltRE","gtRE","ampRE","quoteRE","parseHTML","advance","substring","parseStartTag","startTagOpen","attr","startTagClose","attribute","unarySlash","handleStartTag","expectHTML","lastTag","isNonPhrasingTag","parseEndTag","canBeLeftOpenTag","unary","isUnaryTag$$1","IS_REGEX_CAPTURING_BROKEN","stack","needle","isUnaryTag","no","isSpecialTag","sfc","stackedTag","reStackedTag","reCache","RegExp","endTagLength","rest","all","endTag","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","rest$1","parseFilters","exp","pushFilter","filters","lastFilterIndex","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","wrapFilter","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","baseWarn","msg","console","error","pluckModuleFunction","addProp","addAttr","addDirective","arg","addHandler","important","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","parseModel","index$1","expressionPos","expressionEndPos","lastIndexOf","idx","eof","chr","isStringStart","parseString","parseBracket","inBracket","stringQuote","parse","template","warn$1","warn","platformGetTagNamespace","platformMustUseProp","platformIsPreTag","isPreTag","preTransforms","transforms","postTransforms","root","currentParent","preserveWhitespace","inVPre","inPre","checkRootConstraints","isIE","guardIESVGBug","element","makeAttrsMap","isForbiddenTag","forbidden","processPre","pre","processRawAttrs","processFor","processIf","processOnce","processKey","plain","processRef","processSlot","processComponent","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","lastNode","decodeHTMLCached","checkInFor","inMatch","forAliasRE","for","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","condition","ifConditions","slotName","component","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","isStaticKey","genStaticKeysCached","isPlatformReservedTag","markStaticRoots","genStaticKeys$1","static","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","isBuiltInTag","isDirectChildOfTemplateFor","every","genHandlers","genHandler","modifierCode","genKeyFilter","handlerCode","simplePathRE","fnExpRE","genFilterCode","keyVal","parseInt","bind$2","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","currentOptions","warn$2","transforms$1","dataGenFns","platformDirectives$1","isPlatformReservedTag$1","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","genIfConditions","conditions","genTernaryExp","shift","genDirectives","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","baseDirectives","inlineRenderFns","genScopedSlot","scope","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","some","maybeComponent","genText","transformSpecialNewlines","bind$$1","componentName","compile$1","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","model$1","_warn","warn$3","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","genAssignmentCode","needCompositionGuard","valueExpression","assignment","modelRs","compile$$1","baseOptions","compileToFunctions","compiled","makeFunction","getOuterHTML","outerHTML","container","cloneNode","_isServer","_Set","camelizeRE","toUpperCase","hyphenateRE","optionMergeStrategies","silent","ignoredElements","_lifecycleHooks","_maxUpdateCount","hasProto","UA","isEdge","isAndroid","isIOS","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","logError","err","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","formatComponentName","uid$1","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","observeArray","arrayKeys","getOwnPropertyNames","isSettingProps","augment","walk","items","instanceData","defaultData","freeze","defineReactive","uid$2","deep","active","deps","newDeps","depIds","newDepIds","cleanupDeps","tmp","raw","patternTypes","KeepAlive","include","exclude","created","destroyed","testEl","acceptValue","svg","math","isHTMLTag","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalize","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","platformModules","patch$1","vmodel","model","needReset","v","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","info","platformComponents","singleAttrIdentifier","singleAttrAssign","singleAttrValues","source","ncname","qnameCapture","g","isScriptOrStyle","hasLang","isSFC","regexEscapeRE","open","close","esc","tab","space","up","right","down","stop","prevent","ctrl","alt","meta","cloak","klass$1","style$1","modules$1","directives$1","idToTemplate","mount","compile","hide","PROTOTYPE","$export","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","IS_BIND","B","IS_WRAP","W","expProto","C","virtual","R","U","bitmap","shared","ceil","floor","isNaN","defined","cutOffEvents","cutPoint","applyTransaction","history","rebased","newState","getMeta","historyKey","closeHistoryKey","HistoryState","done","undone","newGroup","prevTime","time","newGroupDelay","isAdjacentToLastStep","prevMap","addTransform","Branch","addMaps","firstMap","adjacent","_start","_end","rStart","rEnd","histTransaction","redo","histOptions","popEvent","preserveItems","selectionBefore","added","newHist","remaining","setMeta","closeHistory","hist","undo","getState","eventCount","undoDepth","redoDepth","RopeSequence","max_empty_items","remap","mapFrom","remapping","addAfter","addBefore","Item","mapJSON","reverse","newItems","oldItems","lastItem","merged","overflow","DEPTH_OVERFLOW","mirrorOffset","mirrorPos","rebasedTransform","rebasedCount","rebasedItems","startPos","newUntil","iRebased","newMaps","branch","emptyItemCount","compress","count","upto","newItem","stringHandler","string","cutOff","inputRules","rules","stored","stateKey","selectionSet","docChanged","handleTextInput","textBefore","MAX_MATCH","handleKeyDown","keyCode","maybeUndoInputRule","undoable","toUndo","InputRule","removeRange","indexTo","offsetTo","insertInto","inner","replaceOuter","prepareSliceForReplace","replaceThreeWay","replaceTwoWay","checkJoin","main","$before","$after","addNode","addRange","$start","$end","startIndex","endIndex","textOffset","validContent","$along","resolveNoCache","message","fragment","maxOpen","n$1","findSelectionIn","textOnly","bias","atStart","between","$anchor","nearAnchor","inv","foundAnchor","foundHead","head","prototypeAccessors$1","selectable","mustOverride","stepsByID","_doc","_mapping","_other","stepClass","ok","computeDocDeco","focused","contenteditable","editable","someProp","Decoration","getEditable","scrollRectIntoView","posAtCoords","coordsAtPos","docViewDesc","initInput","destroyInput","startObserving","stopObserving","ensureListeners","ref$3","SelectionReader","selectionToDOM","ref$4","viewDecorations","DecorationSet","EditorView","place","_root","docView","lastSelectedViewDesc","selectionReader","pluginViews","updatePluginViews","handleDOMEvents","updateState","plugins","inDOMChange","prevEditable","innerDeco","outerDeco","matchesNode","domChanged","editableChanged","scrollToSelection","domAfterPos","destroyPluginViews","prevState","pluginView","hasFocus","ownerDocument","getSelection","rangeCount","contains","anchorNode","propName","prop$1","focus","search","host","coords","dispatchTransaction","__esModule","aFunction","that","is","cof","propertyIsEnumerable","$keys","enumBugKeys","TAG","stat","SHARED","IObject","toInteger","px","random","crel","settings","childIndex","argumentsLength","attributeMap","attrMapString","isElementString","isNodeString","isNode","isElement","Proxy","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","allInputRules","wrappingInputRule","textblockTypeInputRule","blockQuoteRule","orderedListRule","bulletListRule","codeBlockRule","headingRule","translate","markMenuEvent","lastMenuEvent","Date","now","isMenuEvent","wrapper","renderDropdownItems","rendered","prefix","renderGrouped","createDocumentFragment","needSep","separator","wrapItem","passedOptions","select","MenuItem","blockTypeItem","getIcon","disabled","onDeselected","dom","icon","label","title","execEvent","preventDefault","Dropdown","listeningOnClose","expand","menuDOM","DropdownSubmenu","toggle","icons","width","height","strong","em","link","bulletList","orderedList","blockquote","joinUpItem","liftItem","selectParentNodeItem","undoItem","redoItem","p$1","parseValue","SyntaxError","AttrValue","checkMarks","mark","resolveValue","expr","attrVal","defaultAttrs","checkCount","elt","expandTypes","specs","group","parseRepeat","many","parseAttrs","parts","ContentExpr","elements","inlineContent","atType","parentAttrs","matchesType","matchToEnd","getMatchAt","matchFragment","checkReplace","replacement","checkReplaceWith","typeAttrs","compatible","generateContent","fillBefore","inline","repeat","nodeTypes","isInline","attrSet","markSet","hasRequiredAttrs","newElt","ContentElement","overlaps","parentExpr","constrainedAttrs","createFiller","computeAttrs","defaultType","t","nextElement","move","matchNode","fragPos","matched","toEnd","fits","possibleContent","targetAttrs","targetMarks","via","possible","fullAttrs","wrapMarks","emptyAttrs","warnedAboutMarksAt","descendants","includeParents","childAfter","childBefore","resolveCached","marksAt","useAfter","canAppend","at","markFromJSON","TextNode","base","resolveDepth","dOff","inclusiveRight","pred","rem","resolveCache","resolveCachePos","resolveCacheSize","addListNodes","itemContent","listGroup","ordered_list","bullet_list","list_item","listItem","wrapInList","doJoin","outerRange","$insert","doWrapInList","wrappers","joinBefore","splitDepth","splitPos","splitListItem","grandParent","nextType","liftListItem","endOfList","sinkListItem","nestedBefore","order","parseDOM","getAttrs","toDOM","defining","addTableNodes","cellContent","tableGroup","table","table_row","tableRow","table_cell","tableCell","createTable","rows","columns","setColumns","rowType","cellType","cell","cells","row","rowNodes","adjustColumns","findRow","addColumnBefore","cellFrom","rowDepth","AddColumnStep","addColumnAfter","removeColumn","RemoveColumnStep","addRow","exampleRow","addRowBefore","addRowAfter","removeRow","moveCell","$cellStart","rowIndex","cellStart","$cellStart$1","sel$1","selectNextCell","selectPreviousCell","positions","tablePos","columnIndex","cellAttrs","rowOff","cellPos","updatedRows","rowCells","updatedTable","$first","dPos","_schema","selectionToInsertionEnd","startLen","_to","_newFrom","newTo","currentMarks","UPDATED_SEL","UPDATED_MARKS","UPDATED_SCROLL","curSelection","curSelectionFor","storedMarksSet","scrolledIntoView","setTime","replaceSelection","replaceRange","lastParent","replaceSelectionWith","inheritMarks","replaceRangeWith","deleteRange","mapFragment","mapped","oldSlice","canCut","innerRange","around","findWrappingOutside","findWrappingInside","outer","inside","innerMatch","typesAfter","typeAfter","baseType","d$1","gapStart","gapEnd","splitting","splitting$1","startM","endM","compareObjs","mapChildren","oldChildren","newLocal","oldOffset","oldEnd","newEnd","dSize","mustRebuild","fromLocal","toLocal","childOffset","mapInner","decorations","mapAndGatherRemainingDecorations","moveSpans","built","buildTree","local","i$3","from$1","byPos","spans","span","gather","onRemove","takeSpansForNode","withoutNulls","hasNulls","localStart","subtree","locals","valid","removeOverlap","working","insertAhead","deco","DecorationGroup","WidgetType","widget","contentEditable","noOptions","associative","InlineType","inclusiveLeft","find","findInner","childOff","addInner","baseOffset","removeInner","span$1","j$1","forChild","dec","localSet","localsInner","members","sorted","TrackedRecord","TrackMappings","addApplyListener","track","removeApplyListener","record","getMapping","mappings","_interopRequireDefault","_from2","arr2","$JSON","toIObject","toLength","toIndex","IS_INCLUDES","$this","fromIndex","ARG","tryGet","T","callee","$defineProperty","Iterators","ITERATOR","ArrayProto","iterator","entries","descriptor","setToStringTag","IteratorPrototype","Constructor","NAME","LIBRARY","redefine","$iterCreate","getPrototypeOf","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","DEFAULT","IS_SET","FORCED","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","values","SAFE_CLOSING","riter","skipClosing","safe","iter","getKeys","gOPS","pIE","$assign","A","K","k","aLen","getSymbols","isEnum","dPs","IE_PROTO","Empty","createDict","iframeDocument","iframe","lt","gt","contentWindow","write","Properties","getOwnPropertySymbols","ObjectProto","arrayIndexOf","names","TO_STRING","valueOf","classof","getIteratorMethod","isArrayIter","createProperty","getIterFn","arrayLike","mapfn","iterFn","$at","iterated","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","clamp","toBarPerc","barPositionCSS","speed","ease","barCSS","Settings","positionUsing","margin-left","hasClass","oldList","newList","className","removeElement","NProgress","minimum","easing","trickle","trickleRate","trickleSpeed","showSpinner","barSelector","spinnerSelector","configure","status","started","isStarted","progress","bar","offsetWidth","getPositioningCSS","opacity","work","force","inc","amount","promise","$promise","always","fromStart","isRendered","getElementById","spinner","perc","bodyStyle","vendorPrefix","camelCase","letter","getVendorProp","vendorName","cssPrefixes","capName","getStyleProp","cssProps","applyCss","properties","OrderedMap","newKey","without","prepend","subtract","dropCursor","scheduleRemoval","clearTimeout","linux","pluginStateFor","dragover","clientX","clientY","dragend","drop","dragleave","color","nodeName","exampleSetup","buildInputRules","keymap","buildKeymap","mapKeys","attributes","menuContent","buildMenuItems","fullMenu","floatingMenu","code_block","heading","ref$5","ref$6","ref$7","cmd","hard_break","br","paragraph","level","horizontal_rule","hr","canInsert","insertImageItem","openPrompt","fields","TextField","required","callback","positiveInteger","insertTableItem","tableType","_a","validate","cols","cmdItem","markActive","markItem","linkItem","href","clean","wrapListItem","r","toggleStrong","toggleEm","toggleCode","toggleLink","image","insertImage","wrapBulletList","wrapOrderedList","wrapBlockQuote","makeParagraph","makeCodeBlock","insertHorizontalRule","insertTable","x","insertMenu","typeMenu","makeHead1","makeHead2","makeHead3","makeHead4","makeHead5","makeHead6","tableItems","tableMenu","inlineMenu","blockMenu","mouseOutside","domFields","submitButton","cancelButton","form","field","buttons","box","innerHeight","innerWidth","submit","params","getValues","ctrlKey","metaKey","shiftKey","input","read","bad","reportInvalid","offsetLeft","offsetTop","Field","validateType","autocomplete","SelectField","opt","regexp","joinPredicate","maxLevel","normalizeKeyName","mod","bindings","baseName","keyName","isChar","direct","withShift","hashPath","buildSVG","SVG","XLINK","location","collection","sym","MenuBarEditorView","selectionIsInverted","focusNode","anchorOffset","focusOffset","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","findWrappingScrollable","scrollHeight","clientHeight","editor","menu","spacer","maxHeight","widthForMaxHeight","floating","updateMenu","updateFloat","scrollFunc","updateScrollCursor","minHeight","rects","getRangeAt","getClientRects","selRect","menuRect","bottom","scrollable","scrollTop","editorRect","position","border","clientWidth","childA","childB","posA","posB","iA","iB","minSize","normalizeList","prevItem","listTags","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","parseStyles","re","tags","rule","ParseContext","addAll","finish","parseSlice","matchTag","matchStyle","schemaRules","priority","nextPriority","loop$1","rules$1","name$1","fromSchema","domParser","blockTags","address","article","aside","canvas","dd","dl","fieldset","figcaption","figure","footer","h1","h2","h3","h4","h5","h6","header","hgroup","li","noscript","ol","output","section","tfoot","ul","ignoreTags","script","OPT_PRESERVE_WS","OPT_OPEN_LEFT","NodeContext","solid","parser","isOpen","topContext","topNode","topOptions","topStart","findPositions","currentPos","addDOM","addTextNode","addElementWithStyles","addElement","nodeValue","insertNode","findInText","findInside","ruleFromNode","ignore","skip","addElementByRule","oldMarks","getContent","contentDOM","contentElement","findAround","childNodes","findAtPoint","findPlace","route","enterInner","closeExtra","preserveWS","topOpen","defaults","attrName","given","compute","initAttrs","Attribute","isRequired","createChecked","instance","nodeSpec","markSpec","wrappings","text$1","gatherToDOM","serializeFragment","keep","serializeMark","serializeNode","renderStructure","serializeNodeAndMarks","renderSpec","innerContent","onContent","domSerializer","nodesFromSchema","marksFromSchema","draggable","fontWeight","createKey","pluginsByKey","FieldDesc","desc","baseFields","_marks","_old","Configuration","filterTransaction","transactions","trs","applyInner","haveNew","appendTransaction","oldState","tr$1","newInstance","applyListeners","$config","reconfigure","pluginFields","removing","adding","toRemove","found$1","clearMarkup","delSteps","allowed","fill","closeFragment","oldOpen","newOpen","coveredDepths","fitsTrivially","placed","placeSlice","fittedLeft","fitLeft","fitted","fitRight","canMoveText","fittedAfter","fitLeftInner","placedBelow","placedHere","fitRightJoin","matchCount","toNode","joinable$1","closed","fitRightClosed","fitRightSeparate","normalizeSlice","parent$1","nodeRight","nodeLeft","dFrom","unplaced","parents","dSlice","curType","curAttrs","curFragment","findPlacement","endOfContent","hasMarks","startMatch","existing","stripped","matchStrippingMarks","newNodes","canExpand","preferredExpand","leftNodes","preferredDepth","openDepth","expandDepth","covered","grown","moveSelectionBlock","$side","selectHorizontally","nextNode","nodeLen","isIgnorable","pmViewDesc","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","previousSibling","setSel","skipIgnoredNodesRight","createRange","setEnd","setStart","removeAllRanges","selectVertically","leavingTextblock","beyond","stopNativeHorizontalDelete","captureKeyDown","browser","toClipboard","dataTransfer","fullSlice","sliceContext","serializer","clearData","setData","canUpdateClipboard","cachedCanUpdateClipboard","getData","fromClipboard","plainText","$context","txt","inCode","readHTML","addContext","normalizeSiblings","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","returned","sibling","metas","detachedDoc","implementation","createHTMLDocument","firstTag","wrapMap","thead","colgroup","col","td","th","parseBetween","domFromPos","startOff","parentRight","endOff","scan","domSel","isCollapsed","startDoc","editableContent","parseRule","isAtEnd","isAtStart","rangeAroundSelection","keyEvent","readDOMChange","parseResult","$from$1","$to$1","parsed","parsedSel","compare","change","findDiff","nextSel","endB","looksLikeJoin","endA","markChange","$from1","isMarkChange","resolveSelection","curMarks","prevMarks","$newStart","$newEnd","skipClosingAndOpening","$next","fromEnd","mayOpen","preferedStart","move$1","DOMChange","changedRange","markDirty","compositionEnd","windowRect","rect","scrollThreshold","scrollMargin","atBody","bounding","moveX","moveY","scrollBy","scrollLeft","findOffsetInNode","closest","coordsClosest","dxClosest","rowBot","rowTop","textRange","findOffsetInText","singleRect","targetKludge","childBox","elementFromPoint","nearestDesc","posFromDOM","posAtStart","child$1","withFlushedState","viewState","endOfTextblockVertical","boxes","endOfTextblockHorizontal","maybeRTL","modify","oldRange","parentDOM","cachedState","cachedDir","cachedResult","mouseDown","dragging","mutationObserver","mutations","registerMutations","eventBelongsToView","runCustomHandler","editHandlers","extraHandlers","bubbles","defaultPrevented","stopEvent","eventCoords","isNear","click","y","runHandlerOnContext","updateSelection","origin","selectClickedLeaf","selectClickedNode","selectAt","selectedNode","handleSingleClick","handleDoubleClick","handleTripleClick","defaultTripleClick","nodePos","forceDOMFlush","observeOptions","disconnect","mut","attributeName","ignoreMutation","fromOffset","localPosFromDOM","toOffset","posAtEnd","sliceSingleNode","clearDragging","dropPos","insertPos","keydown","poll","keyup","keypress","charCode","fromCharCode","lastClick","oneButLastClick","selectNodeModifier","mousedown","flushed","MouseDown","selectNode","allowDefault","targetNode","targetPos","mightDrag","setContentEditable","abs","touchdown","contextmenu","compositionstart","compositionupdate","compositionend","childList","clipboardData","paste","singleNode","Dragging","dragstart","draggedRange","dragenter","$mouse","blur","poller","reader","SelectionChangePoller","TimeoutPoller","takeFocus","syncNodeSelection","lastSelection","resetEditable","descAt","storeDOMState","clearNodeSelection","deselectNode","lastAnchorNode","lastHeadNode","lastAnchorOffset","lastHeadOffset","readFromDOM","listening","curOrigin","originTime","readFunc","polling","pollFunc","doPoll","applyOuterDeco","NodeViewDesc","renderDescs","descs","childDOM","MarkViewDesc","computeOuterDeco","needsWrap","noDeco","OuterDecoLevel","patchOuterDeco","outerDOM","nodeDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","nothing","curList","sameOuterDeco","iterDeco","onWidget","onNode","decoIndex","restNode","parentIndex","cutAt","customNodeViews","cachedCustomFor","cachedCustomViews","buildCustomViews","iosHacks","oldCSS","listStyle","NOT_DIRTY","CHILD_DIRTY","CONTENT_DIRTY","NODE_DIRTY","ViewDesc","matchesWidget","matchesMark","matchesHack","posBeforeChild","domBefore","domAfter","desc$1","search$1","onlyNodes","getDesc","searchDOM","findDOMOffset","anchorDOM","headDOM","collapse","_mutation","startInside","endInside","WidgetViewDesc","custom","descObj","CustomNodeViewDesc","TextViewDesc","updater","ViewTreeUpdater","placeWidget","syncToMarks","findNodeMatch","updateNextNode","addTextblockHacks","destroyRest","changed","updateOuterDeco","inParent","mutation","BRHackViewDesc","destroyBetween","maxKeep","markDesc","siblings","nextDOM","GOOD_LEAF_SIZE","leafAppend","leafPrepend","appendInner","Append","sliceInner","getInner","forEachInner","forEachInvertedInner","Leaf","flatten","leftLen","Promise$1","executor","PENDING","deferred","PromiseObj","Util","debug","toLower","toUpper","isString","isBoolean","isFunction","isBlob","Blob","isFormData","FormData","when","fulfilled","rejected","$vm","each","_merge","_assign","url","urlParams","Url","variables","tmpl","expanded","vars","operators","literal","operator","substr","variable","encodeReserved","modifier","isDefined","encodeValue","isKeyOperator","encodeURIComponent","part","encodeURI","serialize","xdrClient","request","xdr","XDomainRequest","_ref","respondWith","responseText","abort","getUrl","onload","onerror","ontimeout","onprogress","send","getBody","cors","crossOrigin","SUPPORTS_CORS","client","emulateHTTP","requestUrl","protocol","ORIGIN_URL","headers","emulateJSON","response","bodyText","jsonpClient","jsonp","async","Http","common","xhrClient","xhr","XMLHttpRequest","statusText","getAllResponseHeaders","upload","responseType","credentials","withCredentials","setRequestHeader","Client","reqHandlers","resHandlers","sendRequest","getName","curr","normalizeName","blobText","FileReader","readAsText","isBlobText","interceptors","Request","Resource","actions","resource","action","$http","http","$url","$resource","_this","RESOLVED","REJECTED","iterable","resolver","race","onResolved","onRejected","finally","escape","port","hostname","pathname","classCallCheck","Headers","getAll","thisArg","_this2","Response","bodyBlob","blob","CUSTOM_HEADERS","X-Requested-With","COMMON_HEADERS","Accept","JSON_CONTENT_TYPE","Content-Type","put","post","patch","save","resolveQuery","extraQuery","parsedQuery","parseQuery","param","stringifyQuery","encode","val2","createRoute","redirectedFrom","fullPath","getFullPath","formatMatch","isSameRoute","START","trailingSlashRE","isObjectEqual","aKeys","bKeys","isIncludedRoute","queryIncludes","guardEvent","button","findAnchor","_Vue","_router","_route","beforeCreate","router","View","Link","beforeRouteEnter","beforeRouteLeave","resolvePath","relative","segment","hashIndex","queryIndex","cleanPath","createRouteMap","routes","pathMap","nameMap","addRouteRecord","matchAs","normalizePath","instances","redirect","defaultDelimiter","delimiter","PATH_REGEXP","escaped","asterisk","partial","optional","escapeGroup","escapeString","tokensToFunction","encodeURIComponentPretty","encodeAsterisk","pretty","token","isarray","attachKeys","flags","sensitive","regexpToRegexp","groups","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","strict","endsWithDelimiter","getRouteRegex","regexpCache","fillParams","routeMsg","filler","regexpCompileCache","normalizeLocation","_normalized","rawPath","parsedPath","basePath","createMatcher","currentRoute","paramNames","_createRoute","matchRoute","originalRedirect","resolveRecordPath","resolvedPath","aliasedPath","aliasedMatch","aliasedRecord","decodeURIComponent","runQueue","normalizeBase","baseEl","resolveQueue","activated","deactivated","extractGuard","extractLeaveGuards","flatMapComponents","guard","wrapLeaveGuard","extractEnterGuards","isValid","wrapEnterGuard","resolveAsyncComponents","resolvedDef","saveScrollPosition","positionStore","pageXOffset","pageYOffset","getScrollPosition","getElementPosition","docRect","elRect","isValidPosition","isNumber","normalizePosition","getLocation","pushState","replaceState","_key","genKey","ensureSlash","getHash","replaceHash","pushHash","createHref","routerView","$route","_routerViewCache","inactive","routerViewDepth","toTypes","exact","$router","normalizedTo","classes","linkActiveClass","compareTarget","aData","aAttrs","__moduleExports","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","supportsHistory","ua","History","listen","transitionTo","onComplete","onAbort","confirmTransition","updateRoute","ensureURL","beforeHooks","postEnterCbs","enterGuards","app","afterHooks","HTML5History","expectScroll","scrollBehavior","handleScroll","go","isPop","behavior","shouldScroll","scrollTo","HashHistory","checkFallback","onHashChange","AbstractHistory","targetIndex","VueRouter","setupHashListener","beforeEach","afterEach","back","forward","getMatchedComponents","brokenModifierNames","8","9","10","12","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","106","107","108","109","110","111","144","145","160","161","162","163","164","165","173","186","187","188","189","190","191","192","219","220","221","222","229","48","49","50","51","52","53","54","55","56","57","chrome","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","cssNode","sources","btoa","unescape","memoize","memo","isOldIE","getElementsByTagName","mayRemove","textStore"],"mappings":"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","file":"static/js/vendor.62133dbcf281a58ed4c6.js","sourcesContent":["webpackJsonp([1,0],[\n/* 0 */,\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.Node = __webpack_require__(52).Node\n\t;var assign;\n\t((assign = __webpack_require__(53), exports.ResolvedPos = assign.ResolvedPos, exports.NodeRange = assign.NodeRange))\n\texports.Fragment = __webpack_require__(5).Fragment\n\t;var assign$1;\n\t((assign$1 = __webpack_require__(31), exports.Slice = assign$1.Slice, exports.ReplaceError = assign$1.ReplaceError))\n\texports.Mark = __webpack_require__(6).Mark\n\t\n\t;var assign$2;\n\t((assign$2 = __webpack_require__(148), exports.Schema = assign$2.Schema, exports.NodeType = assign$2.NodeType, exports.MarkType = assign$2.MarkType))\n\t;var assign$3;\n\t((assign$3 = __webpack_require__(51), exports.ContentMatch = assign$3.ContentMatch))\n\t\n\texports.DOMParser = __webpack_require__(147).DOMParser\n\texports.DOMSerializer =  __webpack_require__(149).DOMSerializer\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;var assign;\n\t((assign = __webpack_require__(32), exports.Selection = assign.Selection, exports.TextSelection = assign.TextSelection, exports.NodeSelection = assign.NodeSelection))\n\t\n\texports.Transaction = __webpack_require__(56).Transaction\n\t\n\texports.EditorState = __webpack_require__(152).EditorState\n\t\n\t;var assign$1;\n\t((assign$1 = __webpack_require__(151), exports.Plugin = assign$1.Plugin, exports.PluginKey = assign$1.PluginKey))\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(43)('wks')\n\t  , uid        = __webpack_require__(46)\n\t  , Symbol     = __webpack_require__(8).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;var assign;\n\t((assign = __webpack_require__(17), exports.Transform = assign.Transform, exports.TransformError = assign.TransformError))\n\t;var assign$1;\n\t((assign$1 = __webpack_require__(33), exports.Step = assign$1.Step, exports.StepResult = assign$1.StepResult))\n\t;var assign$2;\n\t((assign$2 = __webpack_require__(58), exports.joinPoint = assign$2.joinPoint, exports.canJoin = assign$2.canJoin, exports.canSplit = assign$2.canSplit, exports.insertPoint = assign$2.insertPoint, exports.liftTarget = assign$2.liftTarget, exports.findWrapping = assign$2.findWrapping))\n\t;var assign$3;\n\t((assign$3 = __webpack_require__(15), exports.StepMap = assign$3.StepMap, exports.MapResult = assign$3.MapResult, exports.Mapping = assign$3.Mapping))\n\t;var assign$4;\n\t((assign$4 = __webpack_require__(57), exports.AddMarkStep = assign$4.AddMarkStep, exports.RemoveMarkStep = assign$4.RemoveMarkStep))\n\t;var assign$5;\n\t((assign$5 = __webpack_require__(16), exports.ReplaceStep = assign$5.ReplaceStep, exports.ReplaceAroundStep = assign$5.ReplaceAroundStep))\n\t__webpack_require__(153)\n\t;var assign$6;\n\t((assign$6 = __webpack_require__(154), exports.replaceStep = assign$6.replaceStep))\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(146);\n\tvar findDiffStart = ref.findDiffStart;\n\tvar findDiffEnd = ref.findDiffEnd;\n\t\n\t// ::- Fragment is the type used to represent a node's collection of\n\t// child nodes.\n\t//\n\t// Fragments are persistent data structures. That means you should\n\t// _not_ mutate them or their content, but create new instances\n\t// whenever needed. The API tries to make this easy.\n\tvar Fragment = function(content, size) {\n\t  var this$1 = this;\n\t\n\t  this.content = content\n\t  this.size = size || 0\n\t  if (size == null) { for (var i = 0; i < content.length; i++)\n\t    { this$1.size += content[i].nodeSize } }\n\t};\n\t\n\tvar prototypeAccessors = { firstChild: {},lastChild: {},childCount: {} };\n\t\n\tFragment.prototype.nodesBetween = function (from, to, f, nodeStart, parent) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0, pos = 0; pos < to; i++) {\n\t    var child = this$1.content[i], end = pos + child.nodeSize\n\t    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n\t      var start = pos + 1\n\t      child.nodesBetween(Math.max(0, from - start),\n\t                         Math.min(child.content.size, to - start),\n\t                         f, nodeStart + start)\n\t    }\n\t    pos = end\n\t  }\n\t};\n\t\n\t// : (number, number, ?string, ?string) → string\n\tFragment.prototype.textBetween = function (from, to, blockSeparator, leafText) {\n\t  var text = \"\", separated = true\n\t  this.nodesBetween(from, to, function (node, pos) {\n\t    if (node.isText) {\n\t      text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n\t      separated = !blockSeparator\n\t    } else if (node.isLeaf && leafText) {\n\t      text += leafText\n\t      separated = !blockSeparator\n\t    } else if (!separated && node.isBlock) {\n\t      text += blockSeparator\n\t      separated = true\n\t    }\n\t  }, 0)\n\t  return text\n\t};\n\t\n\t// :: (Fragment) → Fragment\n\t// Create a new fragment containing the content of this fragment and\n\t// `other`.\n\tFragment.prototype.append = function (other) {\n\t  if (!other.size) { return this }\n\t  if (!this.size) { return other }\n\t  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n\t  if (last.isText && last.sameMarkup(first)) {\n\t    content[content.length - 1] = last.withText(last.text + first.text)\n\t    i = 1\n\t  }\n\t  for (; i < other.content.length; i++) { content.push(other.content[i]) }\n\t  return new Fragment(content, this.size + other.size)\n\t};\n\t\n\t// :: (number, ?number) → Fragment\n\t// Cut out the sub-fragment between the two given positions.\n\tFragment.prototype.cut = function (from, to) {\n\t    var this$1 = this;\n\t\n\t  if (to == null) { to = this.size }\n\t  if (from == 0 && to == this.size) { return this }\n\t  var result = [], size = 0\n\t  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n\t    var child = this$1.content[i], end = pos + child.nodeSize\n\t    if (end > from) {\n\t      if (pos < from || end > to) {\n\t        if (child.isText)\n\t          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)) }\n\t        else\n\t          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)) }\n\t      }\n\t      result.push(child)\n\t      size += child.nodeSize\n\t    }\n\t    pos = end\n\t  } }\n\t  return new Fragment(result, size)\n\t};\n\t\n\tFragment.prototype.cutByIndex = function (from, to) {\n\t  if (from == to) { return Fragment.empty }\n\t  if (from == 0 && to == this.content.length) { return this }\n\t  return new Fragment(this.content.slice(from, to))\n\t};\n\t\n\t// :: (number, Node) → Fragment\n\t// Create a new fragment in which the node at the given index is\n\t// replaced by the given node.\n\tFragment.prototype.replaceChild = function (index, node) {\n\t  var current = this.content[index]\n\t  if (current == node) { return this }\n\t  var copy = this.content.slice()\n\t  var size = this.size + node.nodeSize - current.nodeSize\n\t  copy[index] = node\n\t  return new Fragment(copy, size)\n\t};\n\t\n\t// : (Node) → Fragment\n\t// Create a new fragment by prepending the given node to this\n\t// fragment.\n\tFragment.prototype.addToStart = function (node) {\n\t  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n\t};\n\t\n\t// : (Node) → Fragment\n\t// Create a new fragment by appending the given node to this\n\t// fragment.\n\tFragment.prototype.addToEnd = function (node) {\n\t  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n\t};\n\t\n\t// :: (Fragment) → bool\n\t// Compare this fragment to another one.\n\tFragment.prototype.eq = function (other) {\n\t    var this$1 = this;\n\t\n\t  if (this.content.length != other.content.length) { return false }\n\t  for (var i = 0; i < this.content.length; i++)\n\t    { if (!this$1.content[i].eq(other.content[i])) { return false } }\n\t  return true\n\t};\n\t\n\t// :: ?Node\n\t// The first child of the fragment, or `null` if it is empty.\n\tprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\t\n\t// :: ?Node\n\t// The last child of the fragment, or `null` if it is empty.\n\tprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\t\n\t// :: number\n\t// The number of child nodes in this fragment.\n\tprototypeAccessors.childCount.get = function () { return this.content.length };\n\t\n\t// :: (number) → Node\n\t// Get the child node at the given index. Raise an error when the\n\t// index is out of range.\n\tFragment.prototype.child = function (index) {\n\t  var found = this.content[index]\n\t  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n\t  return found\n\t};\n\t\n\t// :: (number) → number\n\t// Get the offset at (size of children before) the given index.\n\tFragment.prototype.offsetAt = function (index) {\n\t    var this$1 = this;\n\t\n\t  var offset = 0\n\t  for (var i = 0; i < index; i++) { offset += this$1.content[i].nodeSize }\n\t  return offset\n\t};\n\t\n\t// :: (number) → ?Node\n\t// Get the child node at the given index, if it exists.\n\tFragment.prototype.maybeChild = function (index) {\n\t  return this.content[index]\n\t};\n\t\n\t// :: ((node: Node, offset: number, index: number))\n\t// Call `f` for every child node, passing the node, its offset\n\t// into this parent node, and its index.\n\tFragment.prototype.forEach = function (f) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0, p = 0; i < this.content.length; i++) {\n\t    var child = this$1.content[i]\n\t    f(child, p, i)\n\t    p += child.nodeSize\n\t  }\n\t};\n\t\n\t// :: (Fragment) → ?number\n\t// Find the first position at which this fragment and another\n\t// fragment differ, or `null` if they are the same.\n\tFragment.prototype.findDiffStart = function (other, pos) {\n\t    if ( pos === void 0 ) pos = 0;\n\t\n\t  return findDiffStart(this, other, pos)\n\t};\n\t\n\t// :: (Node) → ?{a: number, b: number}\n\t// Find the first position, searching from the end, at which this\n\t// fragment and the given fragment differ, or `null` if they are the\n\t// same. Since this position will not be the same in both nodes, an\n\t// object with two separate positions is returned.\n\tFragment.prototype.findDiffEnd = function (other, pos, otherPos) {\n\t    if ( pos === void 0 ) pos = this.size;\n\t    if ( otherPos === void 0 ) otherPos = other.size;\n\t\n\t  return findDiffEnd(this, other, pos, otherPos)\n\t};\n\t\n\t// : (number, ?number) → {index: number, offset: number}\n\t// Find the index and inner offset corresponding to a given relative\n\t// position in this fragment. The result object will be reused\n\t// (overwritten) the next time the function is called. (Not public.)\n\tFragment.prototype.findIndex = function (pos, round) {\n\t    var this$1 = this;\n\t    if ( round === void 0 ) round = -1;\n\t\n\t  if (pos == 0) { return retIndex(0, pos) }\n\t  if (pos == this.size) { return retIndex(this.content.length, pos) }\n\t  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n\t  for (var i = 0, curPos = 0;; i++) {\n\t    var cur = this$1.child(i), end = curPos + cur.nodeSize\n\t    if (end >= pos) {\n\t      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n\t      return retIndex(i, curPos)\n\t    }\n\t    curPos = end\n\t  }\n\t};\n\t\n\t// :: () → string\n\t// Return a debugging string that describes this fragment.\n\tFragment.prototype.toString = function () { return \"<\" + this.toStringInner() + \">\" };\n\t\n\tFragment.prototype.toStringInner = function () { return this.content.join(\", \") };\n\t\n\t// :: () → ?Object\n\t// Create a JSON-serializeable representation of this fragment.\n\tFragment.prototype.toJSON = function () {\n\t  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n\t};\n\t\n\t// :: (Schema, ?Object) → Fragment\n\t// Deserialize a fragment from its JSON representation.\n\tFragment.fromJSON = function (schema, value) {\n\t  return value ? new Fragment(value.map(schema.nodeFromJSON)) : Fragment.empty\n\t};\n\t\n\t// :: ([Node]) → Fragment\n\t// Build a fragment from an array of nodes. Ensures that adjacent\n\t// text nodes with the same style are joined together.\n\tFragment.fromArray = function (array) {\n\t  if (!array.length) { return Fragment.empty }\n\t  var joined, size = 0\n\t  for (var i = 0; i < array.length; i++) {\n\t    var node = array[i]\n\t    size += node.nodeSize\n\t    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n\t      if (!joined) { joined = array.slice(0, i) }\n\t      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n\t    } else if (joined) {\n\t      joined.push(node)\n\t    }\n\t  }\n\t  return new Fragment(joined || array, size)\n\t};\n\t\n\t// :: (?union<Fragment, Node, [Node]>) → Fragment\n\t// Create a fragment from something that can be interpreted as a set\n\t// of nodes. For `null`, it returns the empty fragment. For a\n\t// fragment, the fragment itself. For a node or array of nodes, a\n\t// fragment containing those nodes.\n\tFragment.from = function (nodes) {\n\t  if (!nodes) { return Fragment.empty }\n\t  if (nodes instanceof Fragment) { return nodes }\n\t  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n\t  return new Fragment([nodes], nodes.nodeSize)\n\t};\n\t\n\tObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\texports.Fragment = Fragment\n\t\n\tvar found = {index: 0, offset: 0}\n\tfunction retIndex(index, offset) {\n\t  found.index = index\n\t  found.offset = offset\n\t  return found\n\t}\n\t\n\t// :: Fragment\n\t// An empty fragment. Intended to be reused whenever a node doesn't\n\t// contain anything (rather than allocating a new empty fragment for\n\t// each leaf node).\n\tFragment.empty = new Fragment([], 0)\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(50);\n\tvar compareDeep = ref.compareDeep;\n\t\n\t// ::- A mark is a piece of information that can be attached to a node,\n\t// such as it being emphasized, in code font, or a link. It has a type\n\t// and optionally a set of attributes that provide further information\n\t// (such as the target of the link). Marks are created through a\n\t// `Schema`, which controls which types exist and which\n\t// attributes they have.\n\tvar Mark = function(type, attrs) {\n\t  // :: MarkType\n\t  // The type of this mark.\n\t  this.type = type\n\t  // :: Object\n\t  // The attributes associated with this mark.\n\t  this.attrs = attrs\n\t};\n\t\n\t// :: ([Mark]) → [Mark]\n\t// Given a set of marks, create a new set which contains this one as\n\t// well, in the right position. If this mark is already in the set,\n\t// the set itself is returned. If a mark of this type with different\n\t// attributes is already in the set, a set in which it is replaced\n\t// by this one is returned.\n\tMark.prototype.addToSet = function (set) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < set.length; i++) {\n\t    var other = set[i]\n\t    if (other.type == this$1.type) {\n\t      if (this$1.eq(other)) { return set }\n\t      var copy = set.slice()\n\t      copy[i] = this$1\n\t      return copy\n\t    }\n\t    if (other.type.rank > this$1.type.rank)\n\t      { return set.slice(0, i).concat(this$1).concat(set.slice(i)) }\n\t  }\n\t  return set.concat(this)\n\t};\n\t\n\t// :: ([Mark]) → [Mark]\n\t// Remove this mark from the given set, returning a new set. If this\n\t// mark is not in the set, the set itself is returned.\n\tMark.prototype.removeFromSet = function (set) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < set.length; i++)\n\t    { if (this$1.eq(set[i]))\n\t      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n\t  return set\n\t};\n\t\n\t// :: ([Mark]) → bool\n\t// Test whether this mark is in the given set of marks.\n\tMark.prototype.isInSet = function (set) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < set.length; i++)\n\t    { if (this$1.eq(set[i])) { return true } }\n\t  return false\n\t};\n\t\n\t// :: (Mark) → bool\n\t// Test whether this mark has the same type and attributes as\n\t// another mark.\n\tMark.prototype.eq = function (other) {\n\t  if (this == other) { return true }\n\t  if (this.type != other.type) { return false }\n\t  if (!compareDeep(other.attrs, this.attrs)) { return false }\n\t  return true\n\t};\n\t\n\t// :: () → Object\n\t// Convert this mark to a JSON-serializeable representation.\n\tMark.prototype.toJSON = function () {\n\t    var this$1 = this;\n\t\n\t  var obj = {type: this.type.name}\n\t  for (var _ in this$1.attrs) {\n\t    obj.attrs = this$1.attrs\n\t    break\n\t  }\n\t  return obj\n\t};\n\t\n\t// :: (Schema, Object) → Mark\n\tMark.fromJSON = function (schema, json) {\n\t  return schema.marks[json.type].create(json.attrs)\n\t};\n\t\n\t// :: ([Mark], [Mark]) → bool\n\t// Test whether two sets of marks are identical.\n\tMark.sameSet = function (a, b) {\n\t  if (a == b) { return true }\n\t  if (a.length != b.length) { return false }\n\t  for (var i = 0; i < a.length; i++)\n\t    { if (!a[i].eq(b[i])) { return false } }\n\t  return true\n\t};\n\t\n\t// :: (?union<Mark, [Mark]>) → [Mark]\n\t// Create a properly sorted mark set from null, a single mark, or an\n\t// unsorted array of marks.\n\tMark.setFrom = function (marks) {\n\t  if (!marks || marks.length == 0) { return Mark.none }\n\t  if (marks instanceof Mark) { return [marks] }\n\t  var copy = marks.slice()\n\t  copy.sort(function (a, b) { return a.type.rank - b.type.rank; })\n\t  return copy\n\t};\n\texports.Mark = Mark\n\t\n\t// :: [Mark] The empty set of marks.\n\tMark.none = []\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(23);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(22)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(13)\n\t  , createDesc = __webpack_require__(25);\n\tmodule.exports = __webpack_require__(10) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(9)\n\t  , IE8_DOM_DEFINE = __webpack_require__(92)\n\t  , toPrimitive    = __webpack_require__(109)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(4);\n\tvar joinPoint = ref.joinPoint;\n\tvar canJoin = ref.canJoin;\n\tvar findWrapping = ref.findWrapping;\n\tvar liftTarget = ref.liftTarget;\n\tvar canSplit = ref.canSplit;\n\tvar ReplaceAroundStep = ref.ReplaceAroundStep;\n\tvar ref$1 = __webpack_require__(1);\n\tvar Slice = ref$1.Slice;\n\tvar Fragment = ref$1.Fragment;\n\tvar ref$2 = __webpack_require__(2);\n\tvar Selection = ref$2.Selection;\n\tvar TextSelection = ref$2.TextSelection;\n\tvar NodeSelection = ref$2.NodeSelection;\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Delete the selection, if there is one.\n\tfunction deleteSelection(state, dispatch) {\n\t  if (state.selection.empty) { return false }\n\t  if (dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var tr = state.tr.deleteSelection().scrollIntoView()\n\t    if ($from.sameParent($to) && $from.parent.isTextblock)\n\t      { tr.setStoredMarks($from.marks(true)) }\n\t    dispatch(tr)\n\t  }\n\t  return true\n\t}\n\texports.deleteSelection = deleteSelection\n\t\n\t// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n\t// If the selection is empty and at the start of a textblock, move\n\t// that block closer to the block before it, by lifting it out of its\n\t// parent or, if it has no parent it doesn't share with the node\n\t// before it, moving it into a parent of that node, or joining it with\n\t// that. Will use the view for accurate start-of-textblock detection\n\t// if given.\n\tfunction joinBackward(state, dispatch, view) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var empty = ref.empty;\n\t  if (!empty || (view ? !view.endOfTextblock(\"backward\", state)\n\t                      : $head.parentOffset > 0))\n\t    { return false }\n\t\n\t  // Find the node before this one\n\t  var before, cut\n\t  for (var i = $head.depth - 1; !before && i >= 0; i--) { if ($head.index(i) > 0) {\n\t    cut = $head.before(i + 1)\n\t    before = $head.node(i).child($head.index(i) - 1)\n\t  } }\n\t\n\t  // If there is no node before this, try to lift\n\t  if (!before) {\n\t    var range = $head.blockRange(), target = range && liftTarget(range)\n\t    if (target == null) { return false }\n\t    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n\t    return true\n\t  }\n\t\n\t  // If the node below has no content and the node above is\n\t  // selectable, delete the node below and select the one above.\n\t  if (before.isLeaf && NodeSelection.isSelectable(before) && $head.parent.content.size == 0) {\n\t    if (dispatch) {\n\t      var tr = state.tr.delete(cut, cut + $head.parent.nodeSize)\n\t      tr.setSelection(NodeSelection.create(tr.doc, cut - before.nodeSize))\n\t      dispatch(tr.scrollIntoView())\n\t    }\n\t    return true\n\t  }\n\t\n\t  // If the node doesn't allow children, delete it\n\t  if (before.isLeaf) {\n\t    if (dispatch) { dispatch(state.tr.delete(cut - before.nodeSize, cut).scrollIntoView()) }\n\t    return true\n\t  }\n\t\n\t  // Apply the joining algorithm\n\t  return deleteBarrier(state, cut, dispatch) || selectNextNode(state, cut, -1, dispatch)\n\t}\n\texports.joinBackward = joinBackward\n\t\n\t// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n\t// If the selection is empty and the cursor is at the end of a\n\t// textblock, move the node after it closer to the node with the\n\t// cursor (lifting it out of parents that aren't shared, moving it\n\t// into parents of the cursor block, or joining the two when they are\n\t// siblings). Will use the view for accurate start-of-textblock\n\t// detection if given.\n\tfunction joinForward(state, dispatch, view) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var empty = ref.empty;\n\t  if (!empty || (view ? !view.endOfTextblock(\"forward\", state)\n\t                      : $head.parentOffset < $head.parent.content.size))\n\t    { return false }\n\t\n\t  // Find the node after this one\n\t  var after, cut\n\t  for (var i = $head.depth - 1; !after && i >= 0; i--) {\n\t    var parent = $head.node(i)\n\t    if ($head.index(i) + 1 < parent.childCount) {\n\t      after = parent.child($head.index(i) + 1)\n\t      cut = $head.after(i + 1)\n\t    }\n\t  }\n\t\n\t  // If there is no node after this, there's nothing to do\n\t  if (!after) { return false }\n\t\n\t  // If the node doesn't allow children, delete it\n\t  if (after.isLeaf) {\n\t    if (dispatch) { dispatch(state.tr.delete(cut, cut + after.nodeSize).scrollIntoView()) }\n\t    return true\n\t  }\n\t  // Apply the joining algorithm\n\t  return deleteBarrier(state, cut, dispatch) || selectNextNode(state, cut, 1, dispatch)\n\t}\n\texports.joinForward = joinForward\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Join the selected block or, if there is a text selection, the\n\t// closest ancestor block of the selection that can be joined, with\n\t// the sibling above it.\n\tfunction joinUp(state, dispatch) {\n\t  var ref = state.selection;\n\t  var node = ref.node;\n\t  var from = ref.from;\n\t  var point\n\t  if (node) {\n\t    if (node.isTextblock || !canJoin(state.doc, from)) { return false }\n\t    point = from\n\t  } else {\n\t    point = joinPoint(state.doc, from, -1)\n\t    if (point == null) { return false }\n\t  }\n\t  if (dispatch) {\n\t    var tr = state.tr.join(point)\n\t    if (state.selection.node) { tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)) }\n\t    dispatch(tr.scrollIntoView())\n\t  }\n\t  return true\n\t}\n\texports.joinUp = joinUp\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Join the selected block, or the closest ancestor of the selection\n\t// that can be joined, with the sibling after it.\n\tfunction joinDown(state, dispatch) {\n\t  var node = state.selection.node, nodeAt = state.selection.from\n\t  var point = joinPointBelow(state)\n\t  if (!point) { return false }\n\t  if (dispatch) {\n\t    var tr = state.tr.join(point)\n\t    if (node) { tr.setSelection(NodeSelection.create(tr.doc, nodeAt)) }\n\t    dispatch(tr.scrollIntoView())\n\t  }\n\t  return true\n\t}\n\texports.joinDown = joinDown\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Lift the selected block, or the closest ancestor block of the\n\t// selection that can be lifted, out of its parent node.\n\tfunction lift(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  var range = $from.blockRange($to), target = range && liftTarget(range)\n\t  if (target == null) { return false }\n\t  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n\t  return true\n\t}\n\texports.lift = lift\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// If the selection is in a node whose type has a truthy\n\t// [`code`](#model.NodeSpec.code) property in its spec, replace the\n\t// selection with a newline character.\n\tfunction newlineInCode(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var anchor = ref.anchor;\n\t  if (!$head || !$head.parent.type.spec.code || $head.sharedDepth(anchor) != $head.depth) { return false }\n\t  if (dispatch) { dispatch(state.tr.insertText(\"\\n\").scrollIntoView()) }\n\t  return true\n\t}\n\texports.newlineInCode = newlineInCode\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// When the selection is in a node with a truthy\n\t// [`code`](#model.NodeSpec.code) property in its spec, create a\n\t// default block after the code block, and move the cursor there.\n\tfunction exitCode(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var anchor = ref.anchor;\n\t  if (!$head || !$head.parent.type.spec.code || $head.sharedDepth(anchor) != $head.depth) { return false }\n\t  var above = $head.node(-1), after = $head.indexAfter(-1), type = above.defaultContentType(after)\n\t  if (!above.canReplaceWith(after, after, type)) { return false }\n\t  if (dispatch) {\n\t    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n\t    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n\t    dispatch(tr.scrollIntoView())\n\t  }\n\t  return true\n\t}\n\texports.exitCode = exitCode\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// If a block node is selected, create an empty paragraph before (if\n\t// it is its parent's first child) or after it.\n\tfunction createParagraphNear(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  var node = ref.node;\n\t  if (!node || !node.isBlock) { return false }\n\t  var type = $from.parent.defaultContentType($to.indexAfter())\n\t  if (!type || !type.isTextblock) { return false }\n\t  if (dispatch) {\n\t    var side = ($from.parentOffset ? $to : $from).pos\n\t    var tr = state.tr.insert(side, type.createAndFill())\n\t    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n\t    dispatch(tr.scrollIntoView())\n\t  }\n\t  return true\n\t}\n\texports.createParagraphNear = createParagraphNear\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// If the cursor is in an empty textblock that can be lifted, lift the\n\t// block.\n\tfunction liftEmptyBlock(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var empty = ref.empty;\n\t  if (!empty || $head.parent.content.size) { return false }\n\t  if ($head.depth > 1 && $head.after() != $head.end(-1)) {\n\t    var before = $head.before()\n\t    if (canSplit(state.doc, before)) {\n\t      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()) }\n\t      return true\n\t    }\n\t  }\n\t  var range = $head.blockRange(), target = range && liftTarget(range)\n\t  if (target == null) { return false }\n\t  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n\t  return true\n\t}\n\texports.liftEmptyBlock = liftEmptyBlock\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Split the parent block of the selection. If the selection is a text\n\t// selection, also delete its content.\n\tfunction splitBlock(state, dispatch) {\n\t  var ref = state.selection;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  var node = ref.node;\n\t  if (node && node.isBlock) {\n\t    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) { return false }\n\t    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()) }\n\t    return true\n\t  }\n\t\n\t  if (dispatch) {\n\t    var atEnd = $to.parentOffset == $to.parent.content.size\n\t    var tr = state.tr.delete($from.pos, $to.pos)\n\t    var deflt = $from.depth == 0 ? null : $from.node(-1).defaultContentType($from.indexAfter(-1))\n\t    var types = atEnd ? [{type: deflt}] : null\n\t    var can = canSplit(tr.doc, $from.pos, 1, types)\n\t    if (!types && !can && canSplit(tr.doc, $from.pos, 1, [{type: deflt}])) {\n\t      types = [{type: deflt}]\n\t      can = true\n\t    }\n\t    if (can) {\n\t      tr.split($from.pos, 1, types)\n\t      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n\t          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent)))\n\t        { tr.setNodeType($from.before(), deflt) }\n\t    }\n\t    dispatch(tr.scrollIntoView())\n\t  }\n\t  return true\n\t}\n\texports.splitBlock = splitBlock\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// Move the selection to the node wrapping the current selection, if\n\t// any. (Will not select the document node.)\n\tfunction selectParentNode(state, dispatch) {\n\t  var sel = state.selection, pos\n\t  if (sel.node) {\n\t    if (!sel.$from.depth) { return false }\n\t    pos = sel.$from.before()\n\t  } else {\n\t    var same = sel.$head.sharedDepth(sel.anchor)\n\t    if (same == 0) { return false }\n\t    pos = sel.$head.before(same)\n\t  }\n\t  if (dispatch) { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos))) }\n\t  return true\n\t}\n\texports.selectParentNode = selectParentNode\n\t\n\tfunction joinMaybeClear(state, $pos, dispatch) {\n\t  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n\t  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }\n\t  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n\t    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()) }\n\t    return true\n\t  }\n\t  if (!$pos.parent.canReplace(index, index + 1)) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr\n\t             .clearNonMatching($pos.pos, before.contentMatchAt(before.childCount))\n\t             .join($pos.pos)\n\t             .scrollIntoView()) }\n\t  return true\n\t}\n\t\n\tfunction deleteBarrier(state, cut, dispatch) {\n\t  var $cut = state.doc.resolve(cut), before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n\t  if (joinMaybeClear(state, $cut, dispatch)) {\n\t    return true\n\t  } else if (after.isTextblock && $cut.parent.canReplace($cut.index(), $cut.index() + 1) &&\n\t             (conn = (match = before.contentMatchAt(before.childCount)).findWrappingFor(after)) &&\n\t             match.matchType((conn[0] || after).type, (conn[0] || after).attrs).validEnd()) {\n\t    if (dispatch) {\n\t      var end = cut + after.nodeSize, wrap = Fragment.empty\n\t      for (var i = conn.length - 1; i >= 0; i--)\n\t        { wrap = Fragment.from(conn[i].type.create(conn[i].attrs, wrap)) }\n\t      wrap = Fragment.from(before.copy(wrap))\n\t      var tr = state.tr.step(new ReplaceAroundStep(cut - 1, end, cut, end, new Slice(wrap, 1, 0), conn.length, true))\n\t      var joinAt = end + 2 * conn.length\n\t      if (canJoin(tr.doc, joinAt)) { tr.join(joinAt) }\n\t      dispatch(tr.scrollIntoView())\n\t    }\n\t    return true\n\t  } else {\n\t    var selAfter = Selection.findFrom($cut, 1)\n\t    var range = selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n\t    if (target == null) { return false }\n\t    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n\t    return true\n\t  }\n\t}\n\t\n\tfunction selectNextNode(state, cut, dir, dispatch) {\n\t  var $cut = state.doc.resolve(cut)\n\t  var node = dir > 0 ? $cut.nodeAfter : $cut.nodeBefore\n\t  if (!node || !NodeSelection.isSelectable(node)) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, cut - (dir > 0 ? 0 : node.nodeSize))).scrollIntoView()) }\n\t  return true\n\t}\n\t\n\t// Parameterized commands\n\t\n\tfunction joinPointBelow(state) {\n\t  var ref = state.selection;\n\t  var node = ref.node;\n\t  var to = ref.to;\n\t  if (node) { return canJoin(state.doc, to) ? to : null }\n\t  else { return joinPoint(state.doc, to, 1) }\n\t}\n\t\n\t// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Wrap the selection in a node of the given type with the given\n\t// attributes.\n\tfunction wrapIn(nodeType, attrs) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n\t    if (!wrapping) { return false }\n\t    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()) }\n\t    return true\n\t  }\n\t}\n\texports.wrapIn = wrapIn\n\t\n\t// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Returns a command that tries to set the textblock around the\n\t// selection to the given node type with the given attributes.\n\tfunction setBlockType(nodeType, attrs) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var node = ref.node;\n\t    var depth\n\t    if (node) {\n\t      depth = $from.depth\n\t    } else {\n\t      if (!$from.depth || $to.pos > $from.end()) { return false }\n\t      depth = $from.depth - 1\n\t    }\n\t    var target = node || $from.parent\n\t    if (!target.isTextblock || target.hasMarkup(nodeType, attrs)) { return false }\n\t    var index = $from.index(depth)\n\t    if (!$from.node(depth).canReplaceWith(index, index + 1, nodeType)) { return false }\n\t    if (dispatch) {\n\t      var where = $from.before(depth + 1)\n\t      dispatch(state.tr\n\t               .clearNonMatching(where, nodeType.contentExpr.start(attrs))\n\t               .setNodeType(where, nodeType, attrs)\n\t               .scrollIntoView())\n\t    }\n\t    return true\n\t  }\n\t}\n\texports.setBlockType = setBlockType\n\t\n\tfunction markApplies(doc, from, to, type) {\n\t  var can = false\n\t  doc.nodesBetween(from, to, function (node) {\n\t    if (can) { return false }\n\t    can = node.isTextblock && node.contentMatchAt(0).allowsMark(type)\n\t  })\n\t  return can\n\t}\n\t\n\t// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Create a command function that toggles the given mark with the\n\t// given attributes. Will return `false` when the current selection\n\t// doesn't support that mark. This will remove the mark if any marks\n\t// of that type exist in the selection, or add it otherwise. If the\n\t// selection is empty, this applies to the [stored\n\t// marks](#state.EditorState.storedMarks) instead of a range of the\n\t// document.\n\tfunction toggleMark(markType, attrs) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var empty = ref.empty;\n\t    var from = ref.from;\n\t    var to = ref.to;\n\t    var $from = ref.$from;\n\t    if (!markApplies(state.doc, from, to, markType)) { return false }\n\t    if (dispatch) {\n\t      if (empty) {\n\t        if (markType.isInSet(state.storedMarks || $from.marks()))\n\t          { dispatch(state.tr.removeStoredMark(markType)) }\n\t        else\n\t          { dispatch(state.tr.addStoredMark(markType.create(attrs))) }\n\t      } else {\n\t        if (state.doc.rangeHasMark(from, to, markType))\n\t          { dispatch(state.tr.removeMark(from, to, markType).scrollIntoView()) }\n\t        else\n\t          { dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView()) }\n\t      }\n\t    }\n\t    return true\n\t  }\n\t}\n\texports.toggleMark = toggleMark\n\t\n\tfunction wrapDispatchForJoin(dispatch, isJoinable) {\n\t  return function (tr) {\n\t    if (!tr.isGeneric) { return dispatch(tr) }\n\t\n\t    var ranges = []\n\t    for (var i = 0; i < tr.mapping.maps.length; i++) {\n\t      var map = tr.mapping.maps[i]\n\t      for (var j = 0; j < ranges.length; j++)\n\t        { ranges[j] = map.map(ranges[j]) }\n\t      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); })\n\t    }\n\t\n\t    // Figure out which joinable points exist inside those ranges,\n\t    // by checking all node boundaries in their parent nodes.\n\t    var joinable = []\n\t    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n\t      var from = ranges[i$1], to = ranges[i$1 + 1]\n\t      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n\t      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n\t        var after = parent.maybeChild(index)\n\t        if (!after) { break }\n\t        if (index && joinable.indexOf(pos) == -1) {\n\t          var before = parent.child(index - 1)\n\t          if (before.type == after.type && isJoinable(before, after))\n\t            { joinable.push(pos) }\n\t        }\n\t        pos += after.nodeSize\n\t      }\n\t    }\n\t    // Join the joinable points\n\t    joinable.sort(function (a, b) { return a - b; })\n\t    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n\t      if (canJoin(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]) }\n\t    }\n\t    dispatch(tr)\n\t  }\n\t}\n\t\n\t// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n\t// Wrap a command so that, when it produces a transform that causes\n\t// two joinable nodes to end up next to each other, those are joined.\n\t// Nodes are considered joinable when they are of the same type and\n\t// when the `isJoinable` predicate returns true for them or, if an\n\t// array of strings was passed, if their node type name is in that\n\t// array.\n\tfunction autoJoin(command, isJoinable) {\n\t  if (Array.isArray(isJoinable)) {\n\t    var types = isJoinable\n\t    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; }\n\t  }\n\t  return function (state, dispatch) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable)); }\n\t}\n\texports.autoJoin = autoJoin\n\t\n\t// :: (...[(EditorState, ?(tr: Transaction)) → bool]) → (EditorState, ?(tr: Transaction)) → bool\n\t// Combine a number of command functions into a single function (which\n\t// calls them one by one until one returns true).\n\tfunction chainCommands() {\n\t  var commands = [], len = arguments.length;\n\t  while ( len-- ) commands[ len ] = arguments[ len ];\n\t\n\t  return function(state, dispatch, view) {\n\t    for (var i = 0; i < commands.length; i++)\n\t      { if (commands[i](state, dispatch, view)) { return true } }\n\t    return false\n\t  }\n\t}\n\texports.chainCommands = chainCommands\n\t\n\t// :: Object\n\t// A basic keymap containing bindings not specific to any schema.\n\t// Binds the following keys (when multiple commands are listed, they\n\t// are chained with [`chainCommands`](#commands.chainCommands):\n\t//\n\t// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n\t// * **Mod-Enter** to `exitCode`\n\t// * **Backspace** to `deleteSelection`, `joinBackward`\n\t// * **Mod-Backspace** to `deleteSelection`, `joinBackward`\n\t// * **Delete** to `deleteSelection`, `joinForward`\n\t// * **Mod-Delete** to `deleteSelection`, `joinForward`\n\t// * **Alt-ArrowUp** to `joinUp`\n\t// * **Alt-ArrowDown** to `joinDown`\n\t// * **Mod-BracketLeft** to `lift`\n\t// * **Escape** to `selectParentNode`\n\tvar baseKeymap = {\n\t  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n\t  \"Mod-Enter\": exitCode,\n\t\n\t  \"Backspace\": chainCommands(deleteSelection, joinBackward),\n\t  \"Mod-Backspace\": chainCommands(deleteSelection, joinBackward),\n\t  \"Delete\": chainCommands(deleteSelection, joinForward),\n\t  \"Mod-Delete\": chainCommands(deleteSelection, joinForward),\n\t\n\t  \"Alt-ArrowUp\": joinUp,\n\t  \"Alt-ArrowDown\": joinDown,\n\t  \"Mod-BracketLeft\": lift,\n\t  \"Escape\": selectParentNode\n\t}\n\t\n\t// declare global: os, navigator\n\tvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n\t          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\t\n\tif (mac) {\n\t  var extra = {\n\t    \"Ctrl-h\": baseKeymap[\"Backspace\"],\n\t    \"Alt-Backspace\": baseKeymap[\"Mod-Backspace\"],\n\t    \"Ctrl-d\": baseKeymap[\"Delete\"],\n\t    \"Ctrl-Alt-Backspace\": baseKeymap[\"Mod-Delete\"],\n\t    \"Alt-Delete\": baseKeymap[\"Mod-Delete\"],\n\t    \"Alt-d\": baseKeymap[\"Mod-Delete\"]\n\t  }\n\t  for (var prop in extra) { baseKeymap[prop] = extra[prop] }\n\t}\n\t\n\texports.baseKeymap = baseKeymap\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// Mappable:: interface\n\t// There are several things that positions can be mapped through.\n\t// We'll denote those as 'mappable'.\n\t//\n\t//   map:: (pos: number, assoc: ?number) → number\n\t//   Map a position through this object. When given, `assoc` (should\n\t//   be -1 or 1, defaults to 1) determines with which side the\n\t//   position is associated, which determines in which direction to\n\t//   move when a chunk of content is inserted at the mapped position,\n\t//   and when to consider the position to be deleted.\n\t//\n\t//   mapResult:: (pos: number, assoc: ?number) → MapResult\n\t//   Map a position, and return an object containing additional\n\t//   information about the mapping. The result's `deleted` field tells\n\t//   you whether the position was deleted (completely enclosed in a\n\t//   replaced range) during the mapping.\n\t\n\t// Recovery values encode a range index and an offset. They are\n\t// represented as numbers, because tons of them will be created when\n\t// mapping, for example, a large number of marked ranges. The number's\n\t// lower 16 bits provide the index, the remaining bits the offset.\n\t//\n\t// Note: We intentionally don't use bit shift operators to en- and\n\t// decode these, since those clip to 32 bits, which we might in rare\n\t// cases want to overflow. A 64-bit float can represent 48-bit\n\t// integers precisely.\n\t\n\tvar lower16 = 0xffff\n\tvar factor16 = Math.pow(2, 16)\n\t\n\tfunction makeRecover(index, offset) { return index + offset * factor16 }\n\tfunction recoverIndex(value) { return value & lower16 }\n\tfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\t\n\t// ::- An object representing a mapped position with extra\n\t// information.\n\tvar MapResult = function MapResult(pos, deleted, recover) {\n\t  if ( deleted === void 0 ) deleted = false;\n\t  if ( recover === void 0 ) recover = null;\n\t\n\t  // :: number The mapped version of the position.\n\t  this.pos = pos\n\t  // :: bool Tells you whether the position was deleted, that is,\n\t  // whether the step removed its surroundings from the document.\n\t  this.deleted = deleted\n\t  this.recover = recover\n\t};\n\texports.MapResult = MapResult\n\t\n\t// ::- A map describing the deletions and insertions made by a step,\n\t// which can be used to find the correspondence between positions in\n\t// the pre-step version of a document and the same position in the\n\t// post-step version. This class implements [`Mappable`](#transform.Mappable).\n\tvar StepMap = function StepMap(ranges, inverted) {\n\t  if ( inverted === void 0 ) inverted = false;\n\t\n\t  this.ranges = ranges\n\t  this.inverted = inverted\n\t};\n\t\n\tStepMap.prototype.recover = function recover (value) {\n\t    var this$1 = this;\n\t\n\t  var diff = 0, index = recoverIndex(value)\n\t  if (!this.inverted) { for (var i = 0; i < index; i++)\n\t    { diff += this$1.ranges[i * 3 + 2] - this$1.ranges[i * 3 + 1] } }\n\t  return this.ranges[index * 3] + diff + recoverOffset(value)\n\t};\n\t\n\t// :: (number, ?number) → MapResult\n\t// Map the given position through this map. The `assoc` parameter can\n\t// be used to control what happens when the transform inserted\n\t// content at (or around) this position—if `assoc` is negative, the a\n\t// position before the inserted content will be returned, if it is\n\t// positive, a position after the insertion is returned.\n\tStepMap.prototype.mapResult = function mapResult (pos, assoc) { return this._map(pos, assoc, false) };\n\t\n\t// :: (number, ?number) → number\n\t// Map the given position through this map, returning only the\n\t// mapped position.\n\tStepMap.prototype.map = function map (pos, assoc) { return this._map(pos, assoc, true) };\n\t\n\tStepMap.prototype._map = function _map (pos, assoc, simple) {\n\t    var this$1 = this;\n\t\n\t  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n\t  for (var i = 0; i < this.ranges.length; i += 3) {\n\t    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0)\n\t    if (start > pos) { break }\n\t    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex], end = start + oldSize\n\t    if (pos <= end) {\n\t      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n\t      var result = start + diff + (side < 0 ? 0 : newSize)\n\t      if (simple) { return result }\n\t      var recover = makeRecover(i / 3, pos - start)\n\t      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n\t    }\n\t    diff += newSize - oldSize\n\t  }\n\t  return simple ? pos + diff : new MapResult(pos + diff)\n\t};\n\t\n\tStepMap.prototype.touches = function touches (pos, recover) {\n\t    var this$1 = this;\n\t\n\t  var diff = 0, index = recoverIndex(recover)\n\t  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n\t  for (var i = 0; i < this.ranges.length; i += 3) {\n\t    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0)\n\t    if (start > pos) { break }\n\t    var oldSize = this$1.ranges[i + oldIndex], end = start + oldSize\n\t    if (pos <= end && i == index * 3) { return true }\n\t    diff += this$1.ranges[i + newIndex] - oldSize\n\t  }\n\t  return false\n\t};\n\t\n\t// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n\t// Calls the given function on each of the changed ranges denoted by\n\t// this map.\n\tStepMap.prototype.forEach = function forEach (f) {\n\t    var this$1 = this;\n\t\n\t  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n\t  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n\t    var start = this$1.ranges[i], oldStart = start - (this$1.inverted ? diff : 0), newStart = start + (this$1.inverted ? 0 : diff)\n\t    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex]\n\t    f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n\t    diff += newSize - oldSize\n\t  }\n\t};\n\t\n\t// :: () → StepMap\n\t// Create an inverted version of this map. The result can be used to\n\t// map positions in the post-step document to the pre-step document.\n\tStepMap.prototype.invert = function invert () {\n\t  return new StepMap(this.ranges, !this.inverted)\n\t};\n\t\n\tStepMap.prototype.toString = function toString () {\n\t  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n\t};\n\texports.StepMap = StepMap\n\t\n\tStepMap.empty = new StepMap([])\n\t\n\t// ::- A mapping represents a pipeline of zero or more [step\n\t// maps](#transform.StepMap). It has special provisions for losslessly\n\t// handling mapping positions through a series of steps in which some\n\t// steps are inverted versions of earlier steps. (This comes up when\n\t// ‘rebasing’ steps for collaboration or history management.) This\n\t// class implements [`Mappable`](#transform.Mappable).\n\tvar Mapping = function Mapping(maps, mirror, from, to) {\n\t  // :: [StepMap]\n\t  // The step maps in this mapping.\n\t  this.maps = maps || []\n\t  // :: number\n\t  // The starting position in the `maps` array, used when `map` or\n\t  // `mapResult` is called.\n\t  this.from = from || 0\n\t  // :: number\n\t  // The end positions in the `maps` array.\n\t  this.to = to == null ? this.maps.length : to\n\t  this.mirror = mirror\n\t};\n\t\n\t// :: (?number, ?number) → Mapping\n\t// Create a remapping that maps only through a part of this one.\n\tMapping.prototype.slice = function slice (from, to) {\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = this.maps.length;\n\t\n\t  return new Mapping(this.maps, this.mirror, from, to)\n\t};\n\t\n\tMapping.prototype.copy = function copy () {\n\t  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n\t};\n\t\n\tMapping.prototype.getMirror = function getMirror (n) {\n\t    var this$1 = this;\n\t\n\t  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n\t    { if (this$1.mirror[i] == n) { return this$1.mirror[i + (i % 2 ? -1 : 1)] } } }\n\t};\n\t\n\tMapping.prototype.setMirror = function setMirror (n, m) {\n\t  if (!this.mirror) { this.mirror = [] }\n\t  this.mirror.push(n, m)\n\t};\n\t\n\t// :: (StepMap, ?number)\n\t// Add a step map to the end of this remapping. If `mirrors` is\n\t// given, it should be the index of the step map that is the mirror\n\t// image of this one.\n\tMapping.prototype.appendMap = function appendMap (map, mirrors) {\n\t  this.to = this.maps.push(map)\n\t  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors) }\n\t};\n\t\n\t// :: (Mapping)\n\t// Add all the step maps in a given mapping to this one (preserving\n\t// mirroring information).\n\tMapping.prototype.appendMapping = function appendMapping (mapping) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n\t    var mirr = mapping.getMirror(i)\n\t    this$1.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n\t  }\n\t};\n\t\n\t// :: (number, ?number) → number\n\t// Map a position through this remapping.\n\tMapping.prototype.map = function map (pos, assoc) {\n\t    var this$1 = this;\n\t\n\t  if (this.mirror) { return this._map(pos, assoc, true) }\n\t  for (var i = this.from; i < this.to; i++)\n\t    { pos = this$1.maps[i].map(pos, assoc) }\n\t  return pos\n\t};\n\t\n\t// :: (number, ?number) → MapResult\n\t// Map a position through this remapping, returning a mapping\n\t// result.\n\tMapping.prototype.mapResult = function mapResult (pos, assoc) { return this._map(pos, assoc, false) };\n\t\n\tMapping.prototype._map = function _map (pos, assoc, simple) {\n\t    var this$1 = this;\n\t\n\t  var deleted = false, recoverables = null\n\t\n\t  for (var i = this.from; i < this.to; i++) {\n\t    var map = this$1.maps[i], rec = recoverables && recoverables[i]\n\t    if (rec != null && map.touches(pos, rec)) {\n\t      pos = map.recover(rec)\n\t      continue\n\t    }\n\t\n\t    var result = map.mapResult(pos, assoc)\n\t    if (result.recover != null) {\n\t      var corr = this$1.getMirror(i)\n\t      if (corr != null && corr > i && corr < this$1.to) {\n\t        if (result.deleted) {\n\t          i = corr\n\t          pos = this$1.maps[corr].recover(result.recover)\n\t          continue\n\t        } else {\n\t          ;(recoverables || (recoverables = Object.create(null)))[corr] = result.recover\n\t        }\n\t      }\n\t    }\n\t\n\t    if (result.deleted) { deleted = true }\n\t    pos = result.pos\n\t  }\n\t\n\t  return simple ? pos : new MapResult(pos, deleted)\n\t};\n\texports.Mapping = Mapping\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Slice = ref.Slice;\n\t\n\tvar ref$1 = __webpack_require__(33);\n\tvar Step = ref$1.Step;\n\tvar StepResult = ref$1.StepResult;\n\tvar ref$2 = __webpack_require__(15);\n\tvar StepMap = ref$2.StepMap;\n\t\n\t// ::- Replace a part of the document with a slice of new content.\n\tvar ReplaceStep = (function (Step) {\n\t  function ReplaceStep(from, to, slice, structure) {\n\t    Step.call(this)\n\t    this.from = from\n\t    this.to = to\n\t    this.slice = slice\n\t    this.structure = !!structure\n\t  }\n\t\n\t  if ( Step ) ReplaceStep.__proto__ = Step;\n\t  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n\t  ReplaceStep.prototype.constructor = ReplaceStep;\n\t\n\t  ReplaceStep.prototype.apply = function apply (doc) {\n\t    if (this.structure && contentBetween(doc, this.from, this.to))\n\t      { return StepResult.fail(\"Structure replace would overwrite content\") }\n\t    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n\t  };\n\t\n\t  ReplaceStep.prototype.getMap = function getMap () {\n\t    return new StepMap([this.from, this.to - this.from, this.slice.size])\n\t  };\n\t\n\t  ReplaceStep.prototype.invert = function invert (doc) {\n\t    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n\t  };\n\t\n\t  ReplaceStep.prototype.map = function map (mapping) {\n\t    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n\t    if (from.deleted && to.deleted) { return null }\n\t    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n\t  };\n\t\n\t  ReplaceStep.prototype.merge = function merge (other) {\n\t    if (!(other instanceof ReplaceStep) || other.structure != this.structure) { return null }\n\t\n\t    if (this.from + this.slice.size == other.from && !this.slice.openRight && !other.slice.openLeft) {\n\t      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n\t          : new Slice(this.slice.content.append(other.slice.content), this.slice.openLeft, other.slice.openRight)\n\t      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n\t    } else if (other.to == this.from && !this.slice.openLeft && !other.slice.openRight) {\n\t      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n\t          : new Slice(other.slice.content.append(this.slice.content), other.slice.openLeft, this.slice.openRight)\n\t      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n\t    } else {\n\t      return null\n\t    }\n\t  };\n\t\n\t  ReplaceStep.prototype.toJSON = function toJSON () {\n\t    var json = {stepType: \"replace\", from: this.from, to: this.to}\n\t    if (this.slice.size) { json.slice = this.slice.toJSON() }\n\t    if (this.structure) { json.structure = true }\n\t    return json\n\t  };\n\t\n\t  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n\t    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n\t  };\n\t\n\t  return ReplaceStep;\n\t}(Step));\n\texports.ReplaceStep = ReplaceStep\n\t\n\tStep.jsonID(\"replace\", ReplaceStep)\n\t\n\t// ::- Replace a part of the document with a slice of content, but\n\t// preserve a range of the replaced content by moving it into the\n\t// slice.\n\tvar ReplaceAroundStep = (function (Step) {\n\t  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n\t    Step.call(this)\n\t    this.from = from\n\t    this.to = to\n\t    this.gapFrom = gapFrom\n\t    this.gapTo = gapTo\n\t    this.slice = slice\n\t    this.insert = insert\n\t    this.structure = !!structure\n\t  }\n\t\n\t  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n\t  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n\t  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\t\n\t  ReplaceAroundStep.prototype.apply = function apply (doc) {\n\t    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n\t                           contentBetween(doc, this.gapTo, this.to)))\n\t      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\t\n\t    var gap = doc.slice(this.gapFrom, this.gapTo)\n\t    if (gap.openLeft || gap.openRight)\n\t      { return StepResult.fail(\"Gap is not a flat range\") }\n\t    var inserted = this.slice.insertAt(this.insert, gap.content)\n\t    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n\t    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n\t  };\n\t\n\t  ReplaceAroundStep.prototype.getMap = function getMap () {\n\t    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n\t                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n\t  };\n\t\n\t  ReplaceAroundStep.prototype.invert = function invert (doc) {\n\t    var gap = this.gapTo - this.gapFrom\n\t    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n\t                                 this.from + this.insert, this.from + this.insert + gap,\n\t                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n\t                                 this.gapFrom - this.from, this.structure)\n\t  };\n\t\n\t  ReplaceAroundStep.prototype.map = function map (mapping) {\n\t    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n\t    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n\t    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n\t    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n\t  };\n\t\n\t  ReplaceAroundStep.toJSON = function toJSON () {\n\t    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n\t                gapFrom: this.gapFrom, gapTo: this.gapTo, slice: this.slice.toJSON()}\n\t    if (this.structure) { json.structure = true }\n\t    return true\n\t  };\n\t\n\t  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n\t    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n\t                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n\t  };\n\t\n\t  return ReplaceAroundStep;\n\t}(Step));\n\texports.ReplaceAroundStep = ReplaceAroundStep\n\t\n\tStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\t\n\tfunction contentBetween(doc, from, to) {\n\t  var $from = doc.resolve(from), dist = to - from, depth = $from.depth\n\t  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n\t    depth--\n\t    dist--\n\t  }\n\t  if (dist > 0) {\n\t    var next = $from.node(depth).maybeChild($from.indexAfter(depth))\n\t    while (dist > 0) {\n\t      if (!next || next.isLeaf) { return true }\n\t      next = next.firstChild\n\t      dist--\n\t    }\n\t  }\n\t  return false\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(15);\n\tvar Mapping = ref.Mapping;\n\t\n\tvar TransformError = (function (Error) {\n\t  function TransformError () {\n\t    Error.apply(this, arguments);\n\t  }if ( Error ) TransformError.__proto__ = Error;\n\t  TransformError.prototype = Object.create( Error && Error.prototype );\n\t  TransformError.prototype.constructor = TransformError;\n\t\n\t  \n\t\n\t  return TransformError;\n\t}(Error));\n\texports.TransformError = TransformError\n\t\n\t// ::- Abstraction to build up and track such an array of\n\t// [steps](#transform.Step).\n\t//\n\t// The high-level transforming methods return the `Transform` object\n\t// itself, so that they can be chained.\n\tvar Transform = function Transform(doc) {\n\t  // :: Node\n\t  // The current document (the result of applying the steps in the\n\t  // transform).\n\t  this.doc = doc\n\t  // :: [Step]\n\t  // The steps in this transform.\n\t  this.steps = []\n\t  // :: [Node]\n\t  // The documents before each of the steps.\n\t  this.docs = []\n\t  // :: Mapping\n\t  // A mapping with the maps for each of the steps in this transform.\n\t  this.mapping = new Mapping\n\t};\n\t\n\tvar prototypeAccessors = { before: {} };\n\t\n\t// :: Node The document at the start of the transformation.\n\tprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\t\n\t// :: (step: Step) → Transform\n\t// Apply a new step in this transformation, saving the result.\n\t// Throws an error when the step fails.\n\tTransform.prototype.step = function step (object) {\n\t  var result = this.maybeStep(object)\n\t  if (result.failed) { throw new TransformError(result.failed) }\n\t  return this\n\t};\n\t\n\t// :: (Step) → StepResult\n\t// Try to apply a step in this transformation, ignoring it if it\n\t// fails. Returns the step result.\n\tTransform.prototype.maybeStep = function maybeStep (step) {\n\t  var result = step.apply(this.doc)\n\t  if (!result.failed) { this.addStep(step, result.doc) }\n\t  return result\n\t};\n\t\n\tTransform.prototype.addStep = function addStep (step, doc) {\n\t  this.docs.push(this.doc)\n\t  this.steps.push(step)\n\t  this.mapping.appendMap(step.getMap())\n\t  this.doc = doc\n\t};\n\t\n\tObject.defineProperties( Transform.prototype, prototypeAccessors );\n\texports.Transform = Transform\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tvar result = module.exports = {}\n\t\n\tif (typeof navigator != \"undefined\") {\n\t  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent)\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\t\n\t  result.mac = /Mac/.test(navigator.platform)\n\t  result.ie = ie_upto10 || !!ie_11up\n\t  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up && +ie_11up[1]\n\t  result.gecko = /gecko\\/\\d/i.test(navigator.userAgent)\n\t  result.ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n\t  result.webkit = 'WebkitAppearance' in document.documentElement.style\n\t}\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v2.1.8\n\t * (c) 2014-2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\t/*  */\n\t\n\t/**\n\t * Convert a value to a string that is actually rendered.\n\t */\n\tfunction _toString (val) {\n\t  return val == null\n\t    ? ''\n\t    : typeof val === 'object'\n\t      ? JSON.stringify(val, null, 2)\n\t      : String(val)\n\t}\n\t\n\t/**\n\t * Convert a input value to a number for persistence.\n\t * If the conversion fails, return original string.\n\t */\n\tfunction toNumber (val) {\n\t  var n = parseFloat(val, 10);\n\t  return (n || n === 0) ? n : val\n\t}\n\t\n\t/**\n\t * Make a map and return a function for checking if a key\n\t * is in that map.\n\t */\n\tfunction makeMap (\n\t  str,\n\t  expectsLowerCase\n\t) {\n\t  var map = Object.create(null);\n\t  var list = str.split(',');\n\t  for (var i = 0; i < list.length; i++) {\n\t    map[list[i]] = true;\n\t  }\n\t  return expectsLowerCase\n\t    ? function (val) { return map[val.toLowerCase()]; }\n\t    : function (val) { return map[val]; }\n\t}\n\t\n\t/**\n\t * Check if a tag is a built-in tag.\n\t */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\t\n\t/**\n\t * Remove an item from an array\n\t */\n\tfunction remove$1 (arr, item) {\n\t  if (arr.length) {\n\t    var index = arr.indexOf(item);\n\t    if (index > -1) {\n\t      return arr.splice(index, 1)\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether the object has the property.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn (obj, key) {\n\t  return hasOwnProperty.call(obj, key)\n\t}\n\t\n\t/**\n\t * Check if value is primitive\n\t */\n\tfunction isPrimitive (value) {\n\t  return typeof value === 'string' || typeof value === 'number'\n\t}\n\t\n\t/**\n\t * Create a cached version of a pure function.\n\t */\n\tfunction cached (fn) {\n\t  var cache = Object.create(null);\n\t  return (function cachedFn (str) {\n\t    var hit = cache[str];\n\t    return hit || (cache[str] = fn(str))\n\t  })\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n\t});\n\t\n\t/**\n\t * Capitalize a string.\n\t */\n\tvar capitalize = cached(function (str) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1)\n\t});\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t  return str\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .toLowerCase()\n\t});\n\t\n\t/**\n\t * Simple bind, faster than native\n\t */\n\tfunction bind$1 (fn, ctx) {\n\t  function boundFn (a) {\n\t    var l = arguments.length;\n\t    return l\n\t      ? l > 1\n\t        ? fn.apply(ctx, arguments)\n\t        : fn.call(ctx, a)\n\t      : fn.call(ctx)\n\t  }\n\t  // record original fn length\n\t  boundFn._length = fn.length;\n\t  return boundFn\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t */\n\tfunction toArray (list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t */\n\tfunction extend (to, _from) {\n\t  for (var key in _from) {\n\t    to[key] = _from[key];\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t */\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t */\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\tfunction isPlainObject (obj) {\n\t  return toString.call(obj) === OBJECT_STRING\n\t}\n\t\n\t/**\n\t * Merge an Array of Objects into a single Object.\n\t */\n\tfunction toObject (arr) {\n\t  var res = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (arr[i]) {\n\t      extend(res, arr[i]);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/**\n\t * Perform no operation.\n\t */\n\tfunction noop () {}\n\t\n\t/**\n\t * Always return false.\n\t */\n\tvar no = function () { return false; };\n\t\n\t/**\n\t * Return same value\n\t */\n\tvar identity = function (_) { return _; };\n\t\n\t/**\n\t * Generate a static keys string from compiler modules.\n\t */\n\tfunction genStaticKeys (modules) {\n\t  return modules.reduce(function (keys, m) {\n\t    return keys.concat(m.staticKeys || [])\n\t  }, []).join(',')\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t */\n\tfunction looseEqual (a, b) {\n\t  var isObjectA = isObject(a);\n\t  var isObjectB = isObject(b);\n\t  if (isObjectA && isObjectB) {\n\t    return JSON.stringify(a) === JSON.stringify(b)\n\t  } else if (!isObjectA && !isObjectB) {\n\t    return String(a) === String(b)\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction looseIndexOf (arr, val) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (looseEqual(arr[i], val)) { return i }\n\t  }\n\t  return -1\n\t}\n\t\n\t/*  */\n\t\n\tvar config = {\n\t  /**\n\t   * Option merge strategies (used in core/util/options)\n\t   */\n\t  optionMergeStrategies: Object.create(null),\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to enable devtools\n\t   */\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Error handler for watcher errors\n\t   */\n\t  errorHandler: null,\n\t\n\t  /**\n\t   * Ignore certain custom elements\n\t   */\n\t  ignoredElements: [],\n\t\n\t  /**\n\t   * Custom user key aliases for v-on\n\t   */\n\t  keyCodes: Object.create(null),\n\t\n\t  /**\n\t   * Check if a tag is reserved so that it cannot be registered as a\n\t   * component. This is platform-dependent and may be overwritten.\n\t   */\n\t  isReservedTag: no,\n\t\n\t  /**\n\t   * Check if a tag is an unknown element.\n\t   * Platform-dependent.\n\t   */\n\t  isUnknownElement: no,\n\t\n\t  /**\n\t   * Get the namespace of an element\n\t   */\n\t  getTagNamespace: noop,\n\t\n\t  /**\n\t   * Parse the real tag name for the specific platform.\n\t   */\n\t  parsePlatformTagName: identity,\n\t\n\t  /**\n\t   * Check if an attribute must be bound using property, e.g. value\n\t   * Platform-dependent.\n\t   */\n\t  mustUseProp: no,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   */\n\t  _assetTypes: [\n\t    'component',\n\t    'directive',\n\t    'filter'\n\t  ],\n\t\n\t  /**\n\t   * List of lifecycle hooks.\n\t   */\n\t  _lifecycleHooks: [\n\t    'beforeCreate',\n\t    'created',\n\t    'beforeMount',\n\t    'mounted',\n\t    'beforeUpdate',\n\t    'updated',\n\t    'beforeDestroy',\n\t    'destroyed',\n\t    'activated',\n\t    'deactivated'\n\t  ],\n\t\n\t  /**\n\t   * Max circular updates allowed in a scheduler flush cycle.\n\t   */\n\t  _maxUpdateCount: 100\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t */\n\tfunction isReserved (str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F\n\t}\n\t\n\t/**\n\t * Define a property.\n\t */\n\tfunction def (obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Parse simple path.\n\t */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath (path) {\n\t  if (bailRE.test(path)) {\n\t    return\n\t  } else {\n\t    var segments = path.split('.');\n\t    return function (obj) {\n\t      for (var i = 0; i < segments.length; i++) {\n\t        if (!obj) { return }\n\t        obj = obj[segments[i]];\n\t      }\n\t      return obj\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t/* globals MutationObserver */\n\t\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\t\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function () {\n\t  if (_isServer === undefined) {\n\t    /* istanbul ignore if */\n\t    if (!inBrowser && typeof global !== 'undefined') {\n\t      // detect presence of vue-server-renderer and avoid\n\t      // Webpack shimming the process\n\t      _isServer = global['process'].env.VUE_ENV === 'server';\n\t    } else {\n\t      _isServer = false;\n\t    }\n\t  }\n\t  return _isServer\n\t};\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t/* istanbul ignore next */\n\tfunction isNative (Ctor) {\n\t  return /native code/.test(Ctor.toString())\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously.\n\t */\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t\n\t  function nextTickHandler () {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks.length = 0;\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  // the nextTick behavior leverages the microtask queue, which can be accessed\n\t  // via either native Promise.then or MutationObserver.\n\t  // MutationObserver has wider support, however it is seriously bugged in\n\t  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t  // completely stops working after triggering a few times... so, if native\n\t  // Promise is available, we will use it:\n\t  /* istanbul ignore if */\n\t  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t    var p = Promise.resolve();\n\t    var logError = function (err) { console.error(err); };\n\t    timerFunc = function () {\n\t      p.then(nextTickHandler).catch(logError);\n\t      // in problematic UIWebViews, Promise.then doesn't completely break, but\n\t      // it can get stuck in a weird state where callbacks are pushed into the\n\t      // microtask queue but the queue isn't being flushed, until the browser\n\t      // needs to do some other work, e.g. handle a timer. Therefore we can\n\t      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\t      if (isIOS) { setTimeout(noop); }\n\t    };\n\t  } else if (typeof MutationObserver !== 'undefined' && (\n\t    isNative(MutationObserver) ||\n\t    // PhantomJS and iOS 7.x\n\t    MutationObserver.toString() === '[object MutationObserverConstructor]'\n\t  )) {\n\t    // use MutationObserver where native Promise is not available,\n\t    // e.g. PhantomJS IE11, iOS7, Android 4.4\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(String(counter));\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = String(counter);\n\t    };\n\t  } else {\n\t    // fallback to setTimeout\n\t    /* istanbul ignore next */\n\t    timerFunc = function () {\n\t      setTimeout(nextTickHandler, 0);\n\t    };\n\t  }\n\t\n\t  return function queueNextTick (cb, ctx) {\n\t    var _resolve;\n\t    callbacks.push(function () {\n\t      if (cb) { cb.call(ctx); }\n\t      if (_resolve) { _resolve(ctx); }\n\t    });\n\t    if (!pending) {\n\t      pending = true;\n\t      timerFunc();\n\t    }\n\t    if (!cb && typeof Promise !== 'undefined') {\n\t      return new Promise(function (resolve) {\n\t        _resolve = resolve;\n\t      })\n\t    }\n\t  }\n\t})();\n\t\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = (function () {\n\t    function Set () {\n\t      this.set = Object.create(null);\n\t    }\n\t    Set.prototype.has = function has (key) {\n\t      return this.set[key] === true\n\t    };\n\t    Set.prototype.add = function add (key) {\n\t      this.set[key] = true;\n\t    };\n\t    Set.prototype.clear = function clear () {\n\t      this.set = Object.create(null);\n\t    };\n\t\n\t    return Set;\n\t  }());\n\t}\n\t\n\tvar warn = noop;\n\tvar formatComponentName;\n\t\n\tif (false) {\n\t  var hasConsole = typeof console !== 'undefined';\n\t\n\t  warn = function (msg, vm) {\n\t    if (hasConsole && (!config.silent)) {\n\t      console.error(\"[Vue warn]: \" + msg + \" \" + (\n\t        vm ? formatLocation(formatComponentName(vm)) : ''\n\t      ));\n\t    }\n\t  };\n\t\n\t  formatComponentName = function (vm) {\n\t    if (vm.$root === vm) {\n\t      return 'root instance'\n\t    }\n\t    var name = vm._isVue\n\t      ? vm.$options.name || vm.$options._componentTag\n\t      : vm.name;\n\t    return (\n\t      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n\t      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n\t    )\n\t  };\n\t\n\t  var formatLocation = function (str) {\n\t    if (str === 'anonymous component') {\n\t      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n\t    }\n\t    return (\"\\n(found in \" + str + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t */\n\tvar Dep = function Dep () {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t};\n\t\n\tDep.prototype.addSub = function addSub (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\tDep.prototype.removeSub = function removeSub (sub) {\n\t  remove$1(this.subs, sub);\n\t};\n\t\n\tDep.prototype.depend = function depend () {\n\t  if (Dep.target) {\n\t    Dep.target.addDep(this);\n\t  }\n\t};\n\t\n\tDep.prototype.notify = function notify () {\n\t  // stablize the subscriber list first\n\t  var subs = this.subs.slice();\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\t\n\tfunction pushTarget (_target) {\n\t  if (Dep.target) { targetStack.push(Dep.target); }\n\t  Dep.target = _target;\n\t}\n\t\n\tfunction popTarget () {\n\t  Dep.target = targetStack.pop();\n\t}\n\t\n\t/*\n\t * not type checking this file because flow doesn't play well with\n\t * dynamically accessing methods on Array prototype\n\t */\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);[\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t]\n\t.forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator () {\n\t    var arguments$1 = arguments;\n\t\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments$1[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break\n\t      case 'unshift':\n\t        inserted = args;\n\t        break\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break\n\t    }\n\t    if (inserted) { ob.observeArray(inserted); }\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result\n\t  });\n\t});\n\t\n\t/*  */\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However when passing down props,\n\t * we don't want to force conversion because the value may be a nested value\n\t * under a frozen data structure. Converting it would defeat the optimization.\n\t */\n\tvar observerState = {\n\t  shouldConvert: true,\n\t  isSettingProps: false\n\t};\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t */\n\tvar Observer = function Observer (value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  this.vmCount = 0;\n\t  def(value, '__ob__', this);\n\t  if (Array.isArray(value)) {\n\t    var augment = hasProto\n\t      ? protoAugment\n\t      : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t};\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t */\n\tObserver.prototype.walk = function walk (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t */\n\tObserver.prototype.observeArray = function observeArray (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t */\n\tfunction protoAugment (target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t */\n\t/* istanbul ignore next */\n\tfunction copyAugment (target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t */\n\tfunction observe (value, asRootData) {\n\t  if (!isObject(value)) {\n\t    return\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (\n\t    observerState.shouldConvert &&\n\t    !isServerRendering() &&\n\t    (Array.isArray(value) || isPlainObject(value)) &&\n\t    Object.isExtensible(value) &&\n\t    !value._isVue\n\t  ) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (asRootData && ob) {\n\t    ob.vmCount++;\n\t  }\n\t  return ob\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t */\n\tfunction defineReactive$$1 (\n\t  obj,\n\t  key,\n\t  val,\n\t  customSetter\n\t) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter () {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (Array.isArray(value)) {\n\t          dependArray(value);\n\t        }\n\t      }\n\t      return value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      /* eslint-disable no-self-compare */\n\t      if (newVal === value || (newVal !== newVal && value !== value)) {\n\t        return\n\t      }\n\t      /* eslint-enable no-self-compare */\n\t      if (false) {\n\t        customSetter();\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Set a property on an object. Adds the new property and\n\t * triggers change notification if the property doesn't\n\t * already exist.\n\t */\n\tfunction set$1 (obj, key, val) {\n\t  if (Array.isArray(obj)) {\n\t    obj.length = Math.max(obj.length, key);\n\t    obj.splice(key, 1, val);\n\t    return val\n\t  }\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n\t      'at runtime - declare it upfront in the data option.'\n\t    );\n\t    return\n\t  }\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  defineReactive$$1(ob.value, key, val);\n\t  ob.dep.notify();\n\t  return val\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t */\n\tfunction del (obj, key) {\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid deleting properties on a Vue instance or its root $data ' +\n\t      '- just set it to null.'\n\t    );\n\t    return\n\t  }\n\t  if (!hasOwn(obj, key)) {\n\t    return\n\t  }\n\t  delete obj[key];\n\t  if (!ob) {\n\t    return\n\t  }\n\t  ob.dep.notify();\n\t}\n\t\n\t/**\n\t * Collect dependencies on array elements when the array is touched, since\n\t * we cannot intercept array element access like property getters.\n\t */\n\tfunction dependArray (value) {\n\t  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n\t    e = value[i];\n\t    e && e.__ob__ && e.__ob__.dep.depend();\n\t    if (Array.isArray(e)) {\n\t      dependArray(e);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t */\n\tvar strats = config.optionMergeStrategies;\n\t\n\t/**\n\t * Options with restrictions\n\t */\n\tif (false) {\n\t  strats.el = strats.propsData = function (parent, child, vm, key) {\n\t    if (!vm) {\n\t      warn(\n\t        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n\t        'creation with the `new` keyword.'\n\t      );\n\t    }\n\t    return defaultStrat(parent, child)\n\t  };\n\t}\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\tfunction mergeData (to, from) {\n\t  if (!from) { return to }\n\t  var key, toVal, fromVal;\n\t  var keys = Object.keys(from);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    key = keys[i];\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set$1(to, key, fromVal);\n\t    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\tstrats.data = function (\n\t  parentVal,\n\t  childVal,\n\t  vm\n\t) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn(\n\t        'The \"data\" option should be a function ' +\n\t        'that returns a per-instance value in component ' +\n\t        'definitions.',\n\t        vm\n\t      );\n\t      return parentVal\n\t    }\n\t    if (!parentVal) {\n\t      return childVal\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn () {\n\t      return mergeData(\n\t        childVal.call(this),\n\t        parentVal.call(this)\n\t      )\n\t    }\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn () {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function'\n\t        ? childVal.call(vm)\n\t        : childVal;\n\t      var defaultData = typeof parentVal === 'function'\n\t        ? parentVal.call(vm)\n\t        : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData)\n\t      } else {\n\t        return defaultData\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\tfunction mergeHook (\n\t  parentVal,\n\t  childVal\n\t) {\n\t  return childVal\n\t    ? parentVal\n\t      ? parentVal.concat(childVal)\n\t      : Array.isArray(childVal)\n\t        ? childVal\n\t        : [childVal]\n\t    : parentVal\n\t}\n\t\n\tconfig._lifecycleHooks.forEach(function (hook) {\n\t  strats[hook] = mergeHook;\n\t});\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\tfunction mergeAssets (parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal\n\t    ? extend(res, childVal)\n\t    : res\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Watchers.\n\t *\n\t * Watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\tstrats.watch = function (parentVal, childVal) {\n\t  /* istanbul ignore if */\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !Array.isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent\n\t      ? parent.concat(child)\n\t      : [child];\n\t  }\n\t  return ret\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\tstrats.props =\n\tstrats.methods =\n\tstrats.computed = function (parentVal, childVal) {\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\tvar defaultStrat = function (parentVal, childVal) {\n\t  return childVal === undefined\n\t    ? parentVal\n\t    : childVal\n\t};\n\t\n\t/**\n\t * Validate component names\n\t */\n\tfunction checkComponents (options) {\n\t  for (var key in options.components) {\n\t    var lower = key.toLowerCase();\n\t    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t      warn(\n\t        'Do not use built-in or reserved HTML elements as component ' +\n\t        'id: ' + key\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t */\n\tfunction normalizeProps (options) {\n\t  var props = options.props;\n\t  if (!props) { return }\n\t  var res = {};\n\t  var i, val, name;\n\t  if (Array.isArray(props)) {\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        name = camelize(val);\n\t        res[name] = { type: null };\n\t      } else if (false) {\n\t        warn('props must be strings when using array syntax.');\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    for (var key in props) {\n\t      val = props[key];\n\t      name = camelize(key);\n\t      res[name] = isPlainObject(val)\n\t        ? val\n\t        : { type: val };\n\t    }\n\t  }\n\t  options.props = res;\n\t}\n\t\n\t/**\n\t * Normalize raw function directives into object format.\n\t */\n\tfunction normalizeDirectives (options) {\n\t  var dirs = options.directives;\n\t  if (dirs) {\n\t    for (var key in dirs) {\n\t      var def = dirs[key];\n\t      if (typeof def === 'function') {\n\t        dirs[key] = { bind: def, update: def };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t */\n\tfunction mergeOptions (\n\t  parent,\n\t  child,\n\t  vm\n\t) {\n\t  if (false) {\n\t    checkComponents(child);\n\t  }\n\t  normalizeProps(child);\n\t  normalizeDirectives(child);\n\t  var extendsFrom = child.extends;\n\t  if (extendsFrom) {\n\t    parent = typeof extendsFrom === 'function'\n\t      ? mergeOptions(parent, extendsFrom.options, vm)\n\t      : mergeOptions(parent, extendsFrom, vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      if (mixin.prototype instanceof Vue$3) {\n\t        mixin = mixin.options;\n\t      }\n\t      parent = mergeOptions(parent, mixin, vm);\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField (key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t */\n\tfunction resolveAsset (\n\t  options,\n\t  type,\n\t  id,\n\t  warnMissing\n\t) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return\n\t  }\n\t  var assets = options[type];\n\t  // check local registration variations first\n\t  if (hasOwn(assets, id)) { return assets[id] }\n\t  var camelizedId = camelize(id);\n\t  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n\t  var PascalCaseId = capitalize(camelizedId);\n\t  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n\t  // fallback to prototype chain\n\t  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t  if (false) {\n\t    warn(\n\t      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n\t      options\n\t    );\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction validateProp (\n\t  key,\n\t  propOptions,\n\t  propsData,\n\t  vm\n\t) {\n\t  var prop = propOptions[key];\n\t  var absent = !hasOwn(propsData, key);\n\t  var value = propsData[key];\n\t  // handle boolean props\n\t  if (isType(Boolean, prop.type)) {\n\t    if (absent && !hasOwn(prop, 'default')) {\n\t      value = false;\n\t    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t      value = true;\n\t    }\n\t  }\n\t  // check default value\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop, key);\n\t    // since the default value is a fresh copy,\n\t    // make sure to observe it.\n\t    var prevShouldConvert = observerState.shouldConvert;\n\t    observerState.shouldConvert = true;\n\t    observe(value);\n\t    observerState.shouldConvert = prevShouldConvert;\n\t  }\n\t  if (false) {\n\t    assertProp(prop, key, value, vm, absent);\n\t  }\n\t  return value\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t */\n\tfunction getPropDefaultValue (vm, prop, key) {\n\t  // no default, return undefined\n\t  if (!hasOwn(prop, 'default')) {\n\t    return undefined\n\t  }\n\t  var def = prop.default;\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Invalid default value for prop \"' + key + '\": ' +\n\t      'Props with type Object/Array must use a factory function ' +\n\t      'to return the default value.',\n\t      vm\n\t    );\n\t  }\n\t  // the raw prop value was also undefined from previous render,\n\t  // return previous default value to avoid unnecessary watcher trigger\n\t  if (vm && vm.$options.propsData &&\n\t    vm.$options.propsData[key] === undefined &&\n\t    vm[key] !== undefined) {\n\t    return vm[key]\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && prop.type !== Function\n\t    ? def.call(vm)\n\t    : def\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t */\n\tfunction assertProp (\n\t  prop,\n\t  name,\n\t  value,\n\t  vm,\n\t  absent\n\t) {\n\t  if (prop.required && absent) {\n\t    warn(\n\t      'Missing required prop: \"' + name + '\"',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  if (value == null && !prop.required) {\n\t    return\n\t  }\n\t  var type = prop.type;\n\t  var valid = !type || type === true;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!Array.isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType || '');\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    warn(\n\t      'Invalid prop: type check failed for prop \"' + name + '\".' +\n\t      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n\t      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var validator = prop.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      warn(\n\t        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t */\n\tfunction assertType (value, type) {\n\t  var valid;\n\t  var expectedType = getType(type);\n\t  if (expectedType === 'String') {\n\t    valid = typeof value === (expectedType = 'string');\n\t  } else if (expectedType === 'Number') {\n\t    valid = typeof value === (expectedType = 'number');\n\t  } else if (expectedType === 'Boolean') {\n\t    valid = typeof value === (expectedType = 'boolean');\n\t  } else if (expectedType === 'Function') {\n\t    valid = typeof value === (expectedType = 'function');\n\t  } else if (expectedType === 'Object') {\n\t    valid = isPlainObject(value);\n\t  } else if (expectedType === 'Array') {\n\t    valid = Array.isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  }\n\t}\n\t\n\t/**\n\t * Use function string name to check built-in types,\n\t * because a simple equality check will fail when running\n\t * across different vms / iframes.\n\t */\n\tfunction getType (fn) {\n\t  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t  return match && match[1]\n\t}\n\t\n\tfunction isType (type, fn) {\n\t  if (!Array.isArray(fn)) {\n\t    return getType(fn) === getType(type)\n\t  }\n\t  for (var i = 0, len = fn.length; i < len; i++) {\n\t    if (getType(fn[i]) === getType(type)) {\n\t      return true\n\t    }\n\t  }\n\t  /* istanbul ignore next */\n\t  return false\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive$$1,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\tmakeMap: makeMap,\n\t\tisBuiltInTag: isBuiltInTag,\n\t\tremove: remove$1,\n\t\thasOwn: hasOwn,\n\t\tisPrimitive: isPrimitive,\n\t\tcached: cached,\n\t\tcamelize: camelize,\n\t\tcapitalize: capitalize,\n\t\thyphenate: hyphenate,\n\t\tbind: bind$1,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\ttoObject: toObject,\n\t\tnoop: noop,\n\t\tno: no,\n\t\tidentity: identity,\n\t\tgenStaticKeys: genStaticKeys,\n\t\tlooseEqual: looseEqual,\n\t\tlooseIndexOf: looseIndexOf,\n\t\tisReserved: isReserved,\n\t\tdef: def,\n\t\tparsePath: parsePath,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tUA: UA,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisEdge: isEdge,\n\t\tisAndroid: isAndroid,\n\t\tisIOS: isIOS,\n\t\tisServerRendering: isServerRendering,\n\t\tdevtools: devtools,\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tget warn () { return warn; },\n\t\tget formatComponentName () { return formatComponentName; },\n\t\tvalidateProp: validateProp\n\t});\n\t\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\t\n\tvar initProxy;\n\t\n\tif (false) {\n\t  var allowedGlobals = makeMap(\n\t    'Infinity,undefined,NaN,isFinite,isNaN,' +\n\t    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n\t    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n\t    'require' // for Webpack/Browserify\n\t  );\n\t\n\t  var warnNonPresent = function (target, key) {\n\t    warn(\n\t      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n\t      \"referenced during render. Make sure to declare reactive data \" +\n\t      \"properties in the data option.\",\n\t      target\n\t    );\n\t  };\n\t\n\t  var hasProxy =\n\t    typeof Proxy !== 'undefined' &&\n\t    Proxy.toString().match(/native code/);\n\t\n\t  if (hasProxy) {\n\t    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n\t    config.keyCodes = new Proxy(config.keyCodes, {\n\t      set: function set (target, key, value) {\n\t        if (isBuiltInModifier(key)) {\n\t          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n\t          return false\n\t        } else {\n\t          target[key] = value;\n\t          return true\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  var hasHandler = {\n\t    has: function has (target, key) {\n\t      var has = key in target;\n\t      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t      if (!has && !isAllowed) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return has || !isAllowed\n\t    }\n\t  };\n\t\n\t  var getHandler = {\n\t    get: function get (target, key) {\n\t      if (typeof key === 'string' && !(key in target)) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return target[key]\n\t    }\n\t  };\n\t\n\t  initProxy = function initProxy (vm) {\n\t    if (hasProxy) {\n\t      // determine which proxy handler to use\n\t      var options = vm.$options;\n\t      var handlers = options.render && options.render._withStripped\n\t        ? getHandler\n\t        : hasHandler;\n\t      vm._renderProxy = new Proxy(vm, handlers);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar queue = [];\n\tvar has$1 = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\t\n\t/**\n\t * Reset the scheduler's state.\n\t */\n\tfunction resetSchedulerState () {\n\t  queue.length = 0;\n\t  has$1 = {};\n\t  if (false) {\n\t    circular = {};\n\t  }\n\t  waiting = flushing = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\tfunction flushSchedulerQueue () {\n\t  flushing = true;\n\t\n\t  // Sort queue before flush.\n\t  // This ensures that:\n\t  // 1. Components are updated from parent to child. (because parent is always\n\t  //    created before the child)\n\t  // 2. A component's user watchers are run before its render watcher (because\n\t  //    user watchers are created before the render watcher)\n\t  // 3. If a component is destroyed during a parent component's watcher run,\n\t  //    its watchers can be skipped.\n\t  queue.sort(function (a, b) { return a.id - b.id; });\n\t\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (index = 0; index < queue.length; index++) {\n\t    var watcher = queue[index];\n\t    var id = watcher.id;\n\t    has$1[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn(\n\t          'You may have an infinite update loop ' + (\n\t            watcher.user\n\t              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n\t              : \"in a component render function.\"\n\t          ),\n\t          watcher.vm\n\t        );\n\t        break\n\t      }\n\t    }\n\t  }\n\t\n\t  // devtool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\t\n\t  resetSchedulerState();\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t */\n\tfunction queueWatcher (watcher) {\n\t  var id = watcher.id;\n\t  if (has$1[id] == null) {\n\t    has$1[id] = true;\n\t    if (!flushing) {\n\t      queue.push(watcher);\n\t    } else {\n\t      // if already flushing, splice the watcher based on its id\n\t      // if already past its id, it will be run next immediately.\n\t      var i = queue.length - 1;\n\t      while (i >= 0 && queue[i].id > watcher.id) {\n\t        i--;\n\t      }\n\t      queue.splice(Math.max(i, index) + 1, 0, watcher);\n\t    }\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushSchedulerQueue);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t */\n\tvar Watcher = function Watcher (\n\t  vm,\n\t  expOrFn,\n\t  cb,\n\t  options\n\t) {\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  // options\n\t  if (options) {\n\t    this.deep = !!options.deep;\n\t    this.user = !!options.user;\n\t    this.lazy = !!options.lazy;\n\t    this.sync = !!options.sync;\n\t  } else {\n\t    this.deep = this.user = this.lazy = this.sync = false;\n\t  }\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.expression =  false\n\t    ? expOrFn.toString()\n\t    : '';\n\t  // parse expression for getter\n\t  if (typeof expOrFn === 'function') {\n\t    this.getter = expOrFn;\n\t  } else {\n\t    this.getter = parsePath(expOrFn);\n\t    if (!this.getter) {\n\t      this.getter = function () {};\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n\t        'Watcher only accepts simple dot-delimited paths. ' +\n\t        'For full control, use a function instead.',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  this.value = this.lazy\n\t    ? undefined\n\t    : this.get();\n\t};\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\tWatcher.prototype.get = function get () {\n\t  pushTarget(this);\n\t  var value = this.getter.call(this.vm, this.vm);\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  popTarget();\n\t  this.cleanupDeps();\n\t  return value\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t */\n\tWatcher.prototype.addDep = function addDep (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this$1.deps[i];\n\t    if (!this$1.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this$1);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t */\n\tWatcher.prototype.update = function update () {\n\t  /* istanbul ignore else */\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync) {\n\t    this.run();\n\t  } else {\n\t    queueWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Scheduler job interface.\n\t * Will be called by the scheduler.\n\t */\n\tWatcher.prototype.run = function run () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (\n\t      value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated.\n\t      isObject(value) ||\n\t      this.deep\n\t    ) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      if (this.user) {\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          /* istanbul ignore else */\n\t          if (config.errorHandler) {\n\t            config.errorHandler.call(null, e, this.vm);\n\t          } else {\n\t            (\"production\") !== 'production' && warn(\n\t              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n\t              this.vm\n\t            );\n\t            throw e\n\t          }\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\tWatcher.prototype.evaluate = function evaluate () {\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\tWatcher.prototype.depend = function depend () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this$1.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subscriber list.\n\t */\n\tWatcher.prototype.teardown = function teardown () {\n\t    var this$1 = this;\n\t\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed.\n\t    if (!this.vm._isBeingDestroyed) {\n\t      remove$1(this.vm._watchers, this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this$1.deps[i].removeSub(this$1);\n\t    }\n\t    this.active = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Recursively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t */\n\tvar seenObjects = new _Set();\n\tfunction traverse (val) {\n\t  seenObjects.clear();\n\t  _traverse(val, seenObjects);\n\t}\n\t\n\tfunction _traverse (val, seen) {\n\t  var i, keys;\n\t  var isA = Array.isArray(val);\n\t  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n\t    return\n\t  }\n\t  if (val.__ob__) {\n\t    var depId = val.__ob__.dep.id;\n\t    if (seen.has(depId)) {\n\t      return\n\t    }\n\t    seen.add(depId);\n\t  }\n\t  if (isA) {\n\t    i = val.length;\n\t    while (i--) { _traverse(val[i], seen); }\n\t  } else {\n\t    keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) { _traverse(val[keys[i]], seen); }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initState (vm) {\n\t  vm._watchers = [];\n\t  var opts = vm.$options;\n\t  if (opts.props) { initProps(vm, opts.props); }\n\t  if (opts.methods) { initMethods(vm, opts.methods); }\n\t  if (opts.data) {\n\t    initData(vm);\n\t  } else {\n\t    observe(vm._data = {}, true /* asRootData */);\n\t  }\n\t  if (opts.computed) { initComputed(vm, opts.computed); }\n\t  if (opts.watch) { initWatch(vm, opts.watch); }\n\t}\n\t\n\tvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\t\n\tfunction initProps (vm, props) {\n\t  var propsData = vm.$options.propsData || {};\n\t  var keys = vm.$options._propKeys = Object.keys(props);\n\t  var isRoot = !vm.$parent;\n\t  // root instance props should be converted\n\t  observerState.shouldConvert = isRoot;\n\t  var loop = function ( i ) {\n\t    var key = keys[i];\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      if (isReservedProp[key]) {\n\t        warn(\n\t          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n\t          vm\n\t        );\n\t      }\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n\t        if (vm.$parent && !observerState.isSettingProps) {\n\t          warn(\n\t            \"Avoid mutating a prop directly since the value will be \" +\n\t            \"overwritten whenever the parent component re-renders. \" +\n\t            \"Instead, use a data or computed property based on the prop's \" +\n\t            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n\t            vm\n\t          );\n\t        }\n\t      });\n\t    } else {\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n\t    }\n\t  };\n\t\n\t  for (var i = 0; i < keys.length; i++) loop( i );\n\t  observerState.shouldConvert = true;\n\t}\n\t\n\tfunction initData (vm) {\n\t  var data = vm.$options.data;\n\t  data = vm._data = typeof data === 'function'\n\t    ? data.call(vm)\n\t    : data || {};\n\t  if (!isPlainObject(data)) {\n\t    data = {};\n\t    (\"production\") !== 'production' && warn(\n\t      'data functions should return an object:\\n' +\n\t      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n\t      vm\n\t    );\n\t  }\n\t  // proxy data on instance\n\t  var keys = Object.keys(data);\n\t  var props = vm.$options.props;\n\t  var i = keys.length;\n\t  while (i--) {\n\t    if (props && hasOwn(props, keys[i])) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n\t        \"Use prop default value instead.\",\n\t        vm\n\t      );\n\t    } else {\n\t      proxy(vm, keys[i]);\n\t    }\n\t  }\n\t  // observe data\n\t  observe(data, true /* asRootData */);\n\t}\n\t\n\tvar computedSharedDefinition = {\n\t  enumerable: true,\n\t  configurable: true,\n\t  get: noop,\n\t  set: noop\n\t};\n\t\n\tfunction initComputed (vm, computed) {\n\t  for (var key in computed) {\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      warn(\n\t        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n\t        \"overwritten by a computed property with the same name.\",\n\t        vm\n\t      );\n\t    }\n\t    var userDef = computed[key];\n\t    if (typeof userDef === 'function') {\n\t      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n\t      computedSharedDefinition.set = noop;\n\t    } else {\n\t      computedSharedDefinition.get = userDef.get\n\t        ? userDef.cache !== false\n\t          ? makeComputedGetter(userDef.get, vm)\n\t          : bind$1(userDef.get, vm)\n\t        : noop;\n\t      computedSharedDefinition.set = userDef.set\n\t        ? bind$1(userDef.set, vm)\n\t        : noop;\n\t    }\n\t    Object.defineProperty(vm, key, computedSharedDefinition);\n\t  }\n\t}\n\t\n\tfunction makeComputedGetter (getter, owner) {\n\t  var watcher = new Watcher(owner, getter, noop, {\n\t    lazy: true\n\t  });\n\t  return function computedGetter () {\n\t    if (watcher.dirty) {\n\t      watcher.evaluate();\n\t    }\n\t    if (Dep.target) {\n\t      watcher.depend();\n\t    }\n\t    return watcher.value\n\t  }\n\t}\n\t\n\tfunction initMethods (vm, methods) {\n\t  for (var key in methods) {\n\t    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n\t    if (false) {\n\t      warn(\n\t        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n\t        \"Did you reference the function correctly?\",\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\tfunction initWatch (vm, watch) {\n\t  for (var key in watch) {\n\t    var handler = watch[key];\n\t    if (Array.isArray(handler)) {\n\t      for (var i = 0; i < handler.length; i++) {\n\t        createWatcher(vm, key, handler[i]);\n\t      }\n\t    } else {\n\t      createWatcher(vm, key, handler);\n\t    }\n\t  }\n\t}\n\t\n\tfunction createWatcher (vm, key, handler) {\n\t  var options;\n\t  if (isPlainObject(handler)) {\n\t    options = handler;\n\t    handler = handler.handler;\n\t  }\n\t  if (typeof handler === 'string') {\n\t    handler = vm[handler];\n\t  }\n\t  vm.$watch(key, handler, options);\n\t}\n\t\n\tfunction stateMixin (Vue) {\n\t  // flow somehow has problems with directly declared definition object\n\t  // when using Object.defineProperty, so we have to procedurally build up\n\t  // the object here.\n\t  var dataDef = {};\n\t  dataDef.get = function () {\n\t    return this._data\n\t  };\n\t  if (false) {\n\t    dataDef.set = function (newData) {\n\t      warn(\n\t        'Avoid replacing instance root $data. ' +\n\t        'Use nested data properties instead.',\n\t        this\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\t\n\t  Vue.prototype.$set = set$1;\n\t  Vue.prototype.$delete = del;\n\t\n\t  Vue.prototype.$watch = function (\n\t    expOrFn,\n\t    cb,\n\t    options\n\t  ) {\n\t    var vm = this;\n\t    options = options || {};\n\t    options.user = true;\n\t    var watcher = new Watcher(vm, expOrFn, cb, options);\n\t    if (options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn () {\n\t      watcher.teardown();\n\t    }\n\t  };\n\t}\n\t\n\tfunction proxy (vm, key) {\n\t  if (!isReserved(key)) {\n\t    Object.defineProperty(vm, key, {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function proxyGetter () {\n\t        return vm._data[key]\n\t      },\n\t      set: function proxySetter (val) {\n\t        vm._data[key] = val;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar VNode = function VNode (\n\t  tag,\n\t  data,\n\t  children,\n\t  text,\n\t  elm,\n\t  context,\n\t  componentOptions\n\t) {\n\t  this.tag = tag;\n\t  this.data = data;\n\t  this.children = children;\n\t  this.text = text;\n\t  this.elm = elm;\n\t  this.ns = undefined;\n\t  this.context = context;\n\t  this.functionalContext = undefined;\n\t  this.key = data && data.key;\n\t  this.componentOptions = componentOptions;\n\t  this.child = undefined;\n\t  this.parent = undefined;\n\t  this.raw = false;\n\t  this.isStatic = false;\n\t  this.isRootInsert = true;\n\t  this.isComment = false;\n\t  this.isCloned = false;\n\t  this.isOnce = false;\n\t};\n\t\n\tvar createEmptyVNode = function () {\n\t  var node = new VNode();\n\t  node.text = '';\n\t  node.isComment = true;\n\t  return node\n\t};\n\t\n\tfunction createTextVNode (val) {\n\t  return new VNode(undefined, undefined, undefined, String(val))\n\t}\n\t\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode (vnode) {\n\t  var cloned = new VNode(\n\t    vnode.tag,\n\t    vnode.data,\n\t    vnode.children,\n\t    vnode.text,\n\t    vnode.elm,\n\t    vnode.context,\n\t    vnode.componentOptions\n\t  );\n\t  cloned.ns = vnode.ns;\n\t  cloned.isStatic = vnode.isStatic;\n\t  cloned.key = vnode.key;\n\t  cloned.isCloned = true;\n\t  return cloned\n\t}\n\t\n\tfunction cloneVNodes (vnodes) {\n\t  var res = new Array(vnodes.length);\n\t  for (var i = 0; i < vnodes.length; i++) {\n\t    res[i] = cloneVNode(vnodes[i]);\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction mergeVNodeHook (def, hookKey, hook, key) {\n\t  key = key + hookKey;\n\t  var injectedHash = def.__injected || (def.__injected = {});\n\t  if (!injectedHash[key]) {\n\t    injectedHash[key] = true;\n\t    var oldHook = def[hookKey];\n\t    if (oldHook) {\n\t      def[hookKey] = function () {\n\t        oldHook.apply(this, arguments);\n\t        hook.apply(this, arguments);\n\t      };\n\t    } else {\n\t      def[hookKey] = hook;\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction updateListeners (\n\t  on,\n\t  oldOn,\n\t  add,\n\t  remove$$1,\n\t  vm\n\t) {\n\t  var name, cur, old, fn, event, capture, once;\n\t  for (name in on) {\n\t    cur = on[name];\n\t    old = oldOn[name];\n\t    if (!cur) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n\t        vm\n\t      );\n\t    } else if (!old) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      if (Array.isArray(cur)) {\n\t        add(event, (cur.invoker = arrInvoker(cur)), once, capture);\n\t      } else {\n\t        if (!cur.invoker) {\n\t          fn = cur;\n\t          cur = on[name] = {};\n\t          cur.fn = fn;\n\t          cur.invoker = fnInvoker(cur);\n\t        }\n\t        add(event, cur.invoker, once, capture);\n\t      }\n\t    } else if (cur !== old) {\n\t      if (Array.isArray(old)) {\n\t        old.length = cur.length;\n\t        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n\t        on[name] = old;\n\t      } else {\n\t        old.fn = cur;\n\t        on[name] = old;\n\t      }\n\t    }\n\t  }\n\t  for (name in oldOn) {\n\t    if (!on[name]) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      remove$$1(event, oldOn[name].invoker, capture);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrInvoker (arr) {\n\t  return function (ev) {\n\t    var arguments$1 = arguments;\n\t\n\t    var single = arguments.length === 1;\n\t    for (var i = 0; i < arr.length; i++) {\n\t      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fnInvoker (o) {\n\t  return function (ev) {\n\t    var single = arguments.length === 1;\n\t    single ? o.fn(ev) : o.fn.apply(null, arguments);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\t\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// nomralization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren (children) {\n\t  for (var i = 0; i < children.length; i++) {\n\t    if (Array.isArray(children[i])) {\n\t      return Array.prototype.concat.apply([], children)\n\t    }\n\t  }\n\t  return children\n\t}\n\t\n\t// 2. When the children contains constrcuts that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren (children) {\n\t  return isPrimitive(children)\n\t    ? [createTextVNode(children)]\n\t    : Array.isArray(children)\n\t      ? normalizeArrayChildren(children)\n\t      : undefined\n\t}\n\t\n\tfunction normalizeArrayChildren (children, nestedIndex) {\n\t  var res = [];\n\t  var i, c, last;\n\t  for (i = 0; i < children.length; i++) {\n\t    c = children[i];\n\t    if (c == null || typeof c === 'boolean') { continue }\n\t    last = res[res.length - 1];\n\t    //  nested\n\t    if (Array.isArray(c)) {\n\t      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n\t    } else if (isPrimitive(c)) {\n\t      if (last && last.text) {\n\t        last.text += String(c);\n\t      } else if (c !== '') {\n\t        // convert primitive to vnode\n\t        res.push(createTextVNode(c));\n\t      }\n\t    } else {\n\t      if (c.text && last && last.text) {\n\t        res[res.length - 1] = createTextVNode(last.text + c.text);\n\t      } else {\n\t        // default key for nested array children (likely generated by v-for)\n\t        if (c.tag && c.key == null && nestedIndex != null) {\n\t          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t        }\n\t        res.push(c);\n\t      }\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction getFirstComponentChild (children) {\n\t  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n\t}\n\t\n\t/*  */\n\t\n\tfunction initEvents (vm) {\n\t  vm._events = Object.create(null);\n\t  vm._hasHookEvent = false;\n\t  // init parent attached events\n\t  var listeners = vm.$options._parentListeners;\n\t  if (listeners) {\n\t    updateComponentListeners(vm, listeners);\n\t  }\n\t}\n\t\n\tvar target;\n\t\n\tfunction add$1 (event, fn, once) {\n\t  if (once) {\n\t    target.$once(event, fn);\n\t  } else {\n\t    target.$on(event, fn);\n\t  }\n\t}\n\t\n\tfunction remove$2 (event, fn) {\n\t  target.$off(event, fn);\n\t}\n\t\n\tfunction updateComponentListeners (\n\t  vm,\n\t  listeners,\n\t  oldListeners\n\t) {\n\t  target = vm;\n\t  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n\t}\n\t\n\tfunction eventsMixin (Vue) {\n\t  var hookRE = /^hook:/;\n\t  Vue.prototype.$on = function (event, fn) {\n\t    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t    // optimize hook:event cost by using a boolean flag marked at registration\n\t    // instead of a hash lookup\n\t    if (hookRE.test(event)) {\n\t      vm._hasHookEvent = true;\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var vm = this;\n\t    function on () {\n\t      vm.$off(event, on);\n\t      fn.apply(vm, arguments);\n\t    }\n\t    on.fn = fn;\n\t    vm.$on(event, on);\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var vm = this;\n\t    // all\n\t    if (!arguments.length) {\n\t      vm._events = Object.create(null);\n\t      return vm\n\t    }\n\t    // specific event\n\t    var cbs = vm._events[event];\n\t    if (!cbs) {\n\t      return vm\n\t    }\n\t    if (arguments.length === 1) {\n\t      vm._events[event] = null;\n\t      return vm\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        cbs.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var vm = this;\n\t    var cbs = vm._events[event];\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        cbs[i].apply(vm, args);\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar activeInstance = null;\n\t\n\tfunction initLifecycle (vm) {\n\t  var options = vm.$options;\n\t\n\t  // locate first non-abstract parent\n\t  var parent = options.parent;\n\t  if (parent && !options.abstract) {\n\t    while (parent.$options.abstract && parent.$parent) {\n\t      parent = parent.$parent;\n\t    }\n\t    parent.$children.push(vm);\n\t  }\n\t\n\t  vm.$parent = parent;\n\t  vm.$root = parent ? parent.$root : vm;\n\t\n\t  vm.$children = [];\n\t  vm.$refs = {};\n\t\n\t  vm._watcher = null;\n\t  vm._inactive = false;\n\t  vm._isMounted = false;\n\t  vm._isDestroyed = false;\n\t  vm._isBeingDestroyed = false;\n\t}\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  Vue.prototype._mount = function (\n\t    el,\n\t    hydrating\n\t  ) {\n\t    var vm = this;\n\t    vm.$el = el;\n\t    if (!vm.$options.render) {\n\t      vm.$options.render = createEmptyVNode;\n\t      if (false) {\n\t        /* istanbul ignore if */\n\t        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n\t          warn(\n\t            'You are using the runtime-only build of Vue where the template ' +\n\t            'option is not available. Either pre-compile the templates into ' +\n\t            'render functions, or use the compiler-included build.',\n\t            vm\n\t          );\n\t        } else {\n\t          warn(\n\t            'Failed to mount component: template or render function not defined.',\n\t            vm\n\t          );\n\t        }\n\t      }\n\t    }\n\t    callHook(vm, 'beforeMount');\n\t    vm._watcher = new Watcher(vm, function () {\n\t      vm._update(vm._render(), hydrating);\n\t    }, noop);\n\t    hydrating = false;\n\t    // manually mounted instance, call mounted on self\n\t    // mounted is called for render-created child components in its inserted hook\n\t    if (vm.$vnode == null) {\n\t      vm._isMounted = true;\n\t      callHook(vm, 'mounted');\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype._update = function (vnode, hydrating) {\n\t    var vm = this;\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'beforeUpdate');\n\t    }\n\t    var prevEl = vm.$el;\n\t    var prevVnode = vm._vnode;\n\t    var prevActiveInstance = activeInstance;\n\t    activeInstance = vm;\n\t    vm._vnode = vnode;\n\t    // Vue.prototype.__patch__ is injected in entry points\n\t    // based on the rendering backend used.\n\t    if (!prevVnode) {\n\t      // initial render\n\t      vm.$el = vm.__patch__(\n\t        vm.$el, vnode, hydrating, false /* removeOnly */,\n\t        vm.$options._parentElm,\n\t        vm.$options._refElm\n\t      );\n\t    } else {\n\t      // updates\n\t      vm.$el = vm.__patch__(prevVnode, vnode);\n\t    }\n\t    activeInstance = prevActiveInstance;\n\t    // update __vue__ reference\n\t    if (prevEl) {\n\t      prevEl.__vue__ = null;\n\t    }\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = vm;\n\t    }\n\t    // if parent is an HOC, update its $el as well\n\t    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t      vm.$parent.$el = vm.$el;\n\t    }\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'updated');\n\t    }\n\t  };\n\t\n\t  Vue.prototype._updateFromParent = function (\n\t    propsData,\n\t    listeners,\n\t    parentVnode,\n\t    renderChildren\n\t  ) {\n\t    var vm = this;\n\t    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n\t    vm.$options._parentVnode = parentVnode;\n\t    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t    if (vm._vnode) { // update child tree's parent\n\t      vm._vnode.parent = parentVnode;\n\t    }\n\t    vm.$options._renderChildren = renderChildren;\n\t    // update props\n\t    if (propsData && vm.$options.props) {\n\t      observerState.shouldConvert = false;\n\t      if (false) {\n\t        observerState.isSettingProps = true;\n\t      }\n\t      var propKeys = vm.$options._propKeys || [];\n\t      for (var i = 0; i < propKeys.length; i++) {\n\t        var key = propKeys[i];\n\t        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t      }\n\t      observerState.shouldConvert = true;\n\t      if (false) {\n\t        observerState.isSettingProps = false;\n\t      }\n\t      vm.$options.propsData = propsData;\n\t    }\n\t    // update listeners\n\t    if (listeners) {\n\t      var oldListeners = vm.$options._parentListeners;\n\t      vm.$options._parentListeners = listeners;\n\t      updateComponentListeners(vm, listeners, oldListeners);\n\t    }\n\t    // resolve slots + force update if has children\n\t    if (hasChildren) {\n\t      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t      vm.$forceUpdate();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$forceUpdate = function () {\n\t    var vm = this;\n\t    if (vm._watcher) {\n\t      vm._watcher.update();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$destroy = function () {\n\t    var vm = this;\n\t    if (vm._isBeingDestroyed) {\n\t      return\n\t    }\n\t    callHook(vm, 'beforeDestroy');\n\t    vm._isBeingDestroyed = true;\n\t    // remove self from parent\n\t    var parent = vm.$parent;\n\t    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t      remove$1(parent.$children, vm);\n\t    }\n\t    // teardown watchers\n\t    if (vm._watcher) {\n\t      vm._watcher.teardown();\n\t    }\n\t    var i = vm._watchers.length;\n\t    while (i--) {\n\t      vm._watchers[i].teardown();\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (vm._data.__ob__) {\n\t      vm._data.__ob__.vmCount--;\n\t    }\n\t    // call the last hook...\n\t    vm._isDestroyed = true;\n\t    callHook(vm, 'destroyed');\n\t    // turn off all instance listeners.\n\t    vm.$off();\n\t    // remove __vue__ reference\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = null;\n\t    }\n\t    // invoke destroy hooks on current rendered tree\n\t    vm.__patch__(vm._vnode, null);\n\t  };\n\t}\n\t\n\tfunction callHook (vm, hook) {\n\t  var handlers = vm.$options[hook];\n\t  if (handlers) {\n\t    for (var i = 0, j = handlers.length; i < j; i++) {\n\t      handlers[i].call(vm);\n\t    }\n\t  }\n\t  if (vm._hasHookEvent) {\n\t    vm.$emit('hook:' + hook);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\n\tvar hooksToMerge = Object.keys(hooks);\n\t\n\tfunction createComponent (\n\t  Ctor,\n\t  data,\n\t  context,\n\t  children,\n\t  tag\n\t) {\n\t  if (!Ctor) {\n\t    return\n\t  }\n\t\n\t  var baseCtor = context.$options._base;\n\t  if (isObject(Ctor)) {\n\t    Ctor = baseCtor.extend(Ctor);\n\t  }\n\t\n\t  if (typeof Ctor !== 'function') {\n\t    if (false) {\n\t      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n\t    }\n\t    return\n\t  }\n\t\n\t  // async component\n\t  if (!Ctor.cid) {\n\t    if (Ctor.resolved) {\n\t      Ctor = Ctor.resolved;\n\t    } else {\n\t      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n\t        // it's ok to queue this on every render because\n\t        // $forceUpdate is buffered by the scheduler.\n\t        context.$forceUpdate();\n\t      });\n\t      if (!Ctor) {\n\t        // return nothing if this is indeed an async component\n\t        // wait for the callback to trigger parent update.\n\t        return\n\t      }\n\t    }\n\t  }\n\t\n\t  // resolve constructor options in case global mixins are applied after\n\t  // component constructor creation\n\t  resolveConstructorOptions(Ctor);\n\t\n\t  data = data || {};\n\t\n\t  // extract props\n\t  var propsData = extractProps(data, Ctor);\n\t\n\t  // functional component\n\t  if (Ctor.options.functional) {\n\t    return createFunctionalComponent(Ctor, propsData, data, context, children)\n\t  }\n\t\n\t  // extract listeners, since these needs to be treated as\n\t  // child component listeners instead of DOM listeners\n\t  var listeners = data.on;\n\t  // replace with listeners with .native modifier\n\t  data.on = data.nativeOn;\n\t\n\t  if (Ctor.options.abstract) {\n\t    // abstract components do not keep anything\n\t    // other than props & listeners\n\t    data = {};\n\t  }\n\t\n\t  // merge component management hooks onto the placeholder node\n\t  mergeHooks(data);\n\t\n\t  // return a placeholder vnode\n\t  var name = Ctor.options.name || tag;\n\t  var vnode = new VNode(\n\t    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n\t    data, undefined, undefined, undefined, context,\n\t    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n\t  );\n\t  return vnode\n\t}\n\t\n\tfunction createFunctionalComponent (\n\t  Ctor,\n\t  propsData,\n\t  data,\n\t  context,\n\t  children\n\t) {\n\t  var props = {};\n\t  var propOptions = Ctor.options.props;\n\t  if (propOptions) {\n\t    for (var key in propOptions) {\n\t      props[key] = validateProp(key, propOptions, propsData);\n\t    }\n\t  }\n\t  // ensure the createElement function in functional components\n\t  // gets a unique context - this is necessary for correct named slot check\n\t  var _context = Object.create(context);\n\t  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n\t  var vnode = Ctor.options.render.call(null, h, {\n\t    props: props,\n\t    data: data,\n\t    parent: context,\n\t    children: children,\n\t    slots: function () { return resolveSlots(children, context); }\n\t  });\n\t  if (vnode instanceof VNode) {\n\t    vnode.functionalContext = context;\n\t    if (data.slot) {\n\t      (vnode.data || (vnode.data = {})).slot = data.slot;\n\t    }\n\t  }\n\t  return vnode\n\t}\n\t\n\tfunction createComponentInstanceForVnode (\n\t  vnode, // we know it's MountedComponentVNode but flow doesn't\n\t  parent, // activeInstance in lifecycle state\n\t  parentElm,\n\t  refElm\n\t) {\n\t  var vnodeComponentOptions = vnode.componentOptions;\n\t  var options = {\n\t    _isComponent: true,\n\t    parent: parent,\n\t    propsData: vnodeComponentOptions.propsData,\n\t    _componentTag: vnodeComponentOptions.tag,\n\t    _parentVnode: vnode,\n\t    _parentListeners: vnodeComponentOptions.listeners,\n\t    _renderChildren: vnodeComponentOptions.children,\n\t    _parentElm: parentElm || null,\n\t    _refElm: refElm || null\n\t  };\n\t  // check inline-template render functions\n\t  var inlineTemplate = vnode.data.inlineTemplate;\n\t  if (inlineTemplate) {\n\t    options.render = inlineTemplate.render;\n\t    options.staticRenderFns = inlineTemplate.staticRenderFns;\n\t  }\n\t  return new vnodeComponentOptions.Ctor(options)\n\t}\n\t\n\tfunction init (\n\t  vnode,\n\t  hydrating,\n\t  parentElm,\n\t  refElm\n\t) {\n\t  if (!vnode.child || vnode.child._isDestroyed) {\n\t    var child = vnode.child = createComponentInstanceForVnode(\n\t      vnode,\n\t      activeInstance,\n\t      parentElm,\n\t      refElm\n\t    );\n\t    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t  } else if (vnode.data.keepAlive) {\n\t    // kept-alive components, treat as a patch\n\t    var mountedNode = vnode; // work around flow\n\t    prepatch(mountedNode, mountedNode);\n\t  }\n\t}\n\t\n\tfunction prepatch (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  var options = vnode.componentOptions;\n\t  var child = vnode.child = oldVnode.child;\n\t  child._updateFromParent(\n\t    options.propsData, // updated props\n\t    options.listeners, // updated listeners\n\t    vnode, // new parent vnode\n\t    options.children // new children\n\t  );\n\t}\n\t\n\tfunction insert (vnode) {\n\t  if (!vnode.child._isMounted) {\n\t    vnode.child._isMounted = true;\n\t    callHook(vnode.child, 'mounted');\n\t  }\n\t  if (vnode.data.keepAlive) {\n\t    vnode.child._inactive = false;\n\t    callHook(vnode.child, 'activated');\n\t  }\n\t}\n\t\n\tfunction destroy$1 (vnode) {\n\t  if (!vnode.child._isDestroyed) {\n\t    if (!vnode.data.keepAlive) {\n\t      vnode.child.$destroy();\n\t    } else {\n\t      vnode.child._inactive = true;\n\t      callHook(vnode.child, 'deactivated');\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponent (\n\t  factory,\n\t  baseCtor,\n\t  cb\n\t) {\n\t  if (factory.requested) {\n\t    // pool callbacks\n\t    factory.pendingCallbacks.push(cb);\n\t  } else {\n\t    factory.requested = true;\n\t    var cbs = factory.pendingCallbacks = [cb];\n\t    var sync = true;\n\t\n\t    var resolve = function (res) {\n\t      if (isObject(res)) {\n\t        res = baseCtor.extend(res);\n\t      }\n\t      // cache resolved\n\t      factory.resolved = res;\n\t      // invoke callbacks only if this is not a synchronous resolve\n\t      // (async resolves are shimmed as synchronous during SSR)\n\t      if (!sync) {\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          cbs[i](res);\n\t        }\n\t      }\n\t    };\n\t\n\t    var reject = function (reason) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed to resolve async component: \" + (String(factory)) +\n\t        (reason ? (\"\\nReason: \" + reason) : '')\n\t      );\n\t    };\n\t\n\t    var res = factory(resolve, reject);\n\t\n\t    // handle promise\n\t    if (res && typeof res.then === 'function' && !factory.resolved) {\n\t      res.then(resolve, reject);\n\t    }\n\t\n\t    sync = false;\n\t    // return in case resolved synchronously\n\t    return factory.resolved\n\t  }\n\t}\n\t\n\tfunction extractProps (data, Ctor) {\n\t  // we are only extracting raw values here.\n\t  // validation and default values are handled in the child\n\t  // component itself.\n\t  var propOptions = Ctor.options.props;\n\t  if (!propOptions) {\n\t    return\n\t  }\n\t  var res = {};\n\t  var attrs = data.attrs;\n\t  var props = data.props;\n\t  var domProps = data.domProps;\n\t  if (attrs || props || domProps) {\n\t    for (var key in propOptions) {\n\t      var altKey = hyphenate(key);\n\t      checkProp(res, props, key, altKey, true) ||\n\t      checkProp(res, attrs, key, altKey) ||\n\t      checkProp(res, domProps, key, altKey);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkProp (\n\t  res,\n\t  hash,\n\t  key,\n\t  altKey,\n\t  preserve\n\t) {\n\t  if (hash) {\n\t    if (hasOwn(hash, key)) {\n\t      res[key] = hash[key];\n\t      if (!preserve) {\n\t        delete hash[key];\n\t      }\n\t      return true\n\t    } else if (hasOwn(hash, altKey)) {\n\t      res[key] = hash[altKey];\n\t      if (!preserve) {\n\t        delete hash[altKey];\n\t      }\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mergeHooks (data) {\n\t  if (!data.hook) {\n\t    data.hook = {};\n\t  }\n\t  for (var i = 0; i < hooksToMerge.length; i++) {\n\t    var key = hooksToMerge[i];\n\t    var fromParent = data.hook[key];\n\t    var ours = hooks[key];\n\t    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t  }\n\t}\n\t\n\tfunction mergeHook$1 (one, two) {\n\t  return function (a, b, c, d) {\n\t    one(a, b, c, d);\n\t    two(a, b, c, d);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\t\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType,\n\t  alwaysNormalize\n\t) {\n\t  if (Array.isArray(data) || isPrimitive(data)) {\n\t    normalizationType = children;\n\t    children = data;\n\t    data = undefined;\n\t  }\n\t  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n\t  return _createElement(context, tag, data, children, normalizationType)\n\t}\n\t\n\tfunction _createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType\n\t) {\n\t  if (data && data.__ob__) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n\t      'Always create fresh vnode data objects in each render!',\n\t      context\n\t    );\n\t    return createEmptyVNode()\n\t  }\n\t  if (!tag) {\n\t    // in case of component :is set to falsy value\n\t    return createEmptyVNode()\n\t  }\n\t  // support single function children as default scoped slot\n\t  if (Array.isArray(children) &&\n\t      typeof children[0] === 'function') {\n\t    data = data || {};\n\t    data.scopedSlots = { default: children[0] };\n\t    children.length = 0;\n\t  }\n\t  if (normalizationType === ALWAYS_NORMALIZE) {\n\t    children = normalizeChildren(children);\n\t  } else if (normalizationType === SIMPLE_NORMALIZE) {\n\t    children = simpleNormalizeChildren(children);\n\t  }\n\t  var vnode, ns;\n\t  if (typeof tag === 'string') {\n\t    var Ctor;\n\t    ns = config.getTagNamespace(tag);\n\t    if (config.isReservedTag(tag)) {\n\t      // platform built-in elements\n\t      vnode = new VNode(\n\t        config.parsePlatformTagName(tag), data, children,\n\t        undefined, undefined, context\n\t      );\n\t    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t      // component\n\t      vnode = createComponent(Ctor, data, context, children, tag);\n\t    } else {\n\t      // unknown or unlisted namespaced elements\n\t      // check at runtime because it may get assigned a namespace when its\n\t      // parent normalizes children\n\t      vnode = new VNode(\n\t        tag, data, children,\n\t        undefined, undefined, context\n\t      );\n\t    }\n\t  } else {\n\t    // direct component options / constructor\n\t    vnode = createComponent(tag, data, context, children);\n\t  }\n\t  if (vnode) {\n\t    if (ns) { applyNS(vnode, ns); }\n\t    return vnode\n\t  } else {\n\t    return createEmptyVNode()\n\t  }\n\t}\n\t\n\tfunction applyNS (vnode, ns) {\n\t  vnode.ns = ns;\n\t  if (vnode.tag === 'foreignObject') {\n\t    // use default namespace inside foreignObject\n\t    return\n\t  }\n\t  if (vnode.children) {\n\t    for (var i = 0, l = vnode.children.length; i < l; i++) {\n\t      var child = vnode.children[i];\n\t      if (child.tag && !child.ns) {\n\t        applyNS(child, ns);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initRender (vm) {\n\t  vm.$vnode = null; // the placeholder node in parent tree\n\t  vm._vnode = null; // the root of the child tree\n\t  vm._staticTrees = null;\n\t  var parentVnode = vm.$options._parentVnode;\n\t  var renderContext = parentVnode && parentVnode.context;\n\t  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t  vm.$scopedSlots = {};\n\t  // bind the createElement fn to this instance\n\t  // so that we get proper render context inside it.\n\t  // args order: tag, data, children, normalizationType, alwaysNormalize\n\t  // internal version is used by render functions compiled from templates\n\t  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n\t  // normalization is always applied for the public version, used in\n\t  // user-written render functions.\n\t  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\t  if (vm.$options.el) {\n\t    vm.$mount(vm.$options.el);\n\t  }\n\t}\n\t\n\tfunction renderMixin (Vue) {\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    return nextTick(fn, this)\n\t  };\n\t\n\t  Vue.prototype._render = function () {\n\t    var vm = this;\n\t    var ref = vm.$options;\n\t    var render = ref.render;\n\t    var staticRenderFns = ref.staticRenderFns;\n\t    var _parentVnode = ref._parentVnode;\n\t\n\t    if (vm._isMounted) {\n\t      // clone slot nodes on re-renders\n\t      for (var key in vm.$slots) {\n\t        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t      }\n\t    }\n\t\n\t    if (_parentVnode && _parentVnode.data.scopedSlots) {\n\t      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n\t    }\n\t\n\t    if (staticRenderFns && !vm._staticTrees) {\n\t      vm._staticTrees = [];\n\t    }\n\t    // set parent vnode. this allows render functions to have access\n\t    // to the data on the placeholder node.\n\t    vm.$vnode = _parentVnode;\n\t    // render self\n\t    var vnode;\n\t    try {\n\t      vnode = render.call(vm._renderProxy, vm.$createElement);\n\t    } catch (e) {\n\t      /* istanbul ignore else */\n\t      if (config.errorHandler) {\n\t        config.errorHandler.call(null, e, vm);\n\t      } else {\n\t        if (false) {\n\t          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n\t        }\n\t        throw e\n\t      }\n\t      // return previous vnode to prevent render error causing blank component\n\t      vnode = vm._vnode;\n\t    }\n\t    // return empty vnode in case the render function errored out\n\t    if (!(vnode instanceof VNode)) {\n\t      if (false) {\n\t        warn(\n\t          'Multiple root nodes returned from render function. Render function ' +\n\t          'should return a single root node.',\n\t          vm\n\t        );\n\t      }\n\t      vnode = createEmptyVNode();\n\t    }\n\t    // set parent\n\t    vnode.parent = _parentVnode;\n\t    return vnode\n\t  };\n\t\n\t  // toString for mustaches\n\t  Vue.prototype._s = _toString;\n\t  // convert text to vnode\n\t  Vue.prototype._v = createTextVNode;\n\t  // number conversion\n\t  Vue.prototype._n = toNumber;\n\t  // empty vnode\n\t  Vue.prototype._e = createEmptyVNode;\n\t  // loose equal\n\t  Vue.prototype._q = looseEqual;\n\t  // loose indexOf\n\t  Vue.prototype._i = looseIndexOf;\n\t\n\t  // render static tree by index\n\t  Vue.prototype._m = function renderStatic (\n\t    index,\n\t    isInFor\n\t  ) {\n\t    var tree = this._staticTrees[index];\n\t    // if has already-rendered static tree and not inside v-for,\n\t    // we can reuse the same tree by doing a shallow clone.\n\t    if (tree && !isInFor) {\n\t      return Array.isArray(tree)\n\t        ? cloneVNodes(tree)\n\t        : cloneVNode(tree)\n\t    }\n\t    // otherwise, render a fresh tree.\n\t    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t    markStatic(tree, (\"__static__\" + index), false);\n\t    return tree\n\t  };\n\t\n\t  // mark node as static (v-once)\n\t  Vue.prototype._o = function markOnce (\n\t    tree,\n\t    index,\n\t    key\n\t  ) {\n\t    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n\t    return tree\n\t  };\n\t\n\t  function markStatic (tree, key, isOnce) {\n\t    if (Array.isArray(tree)) {\n\t      for (var i = 0; i < tree.length; i++) {\n\t        if (tree[i] && typeof tree[i] !== 'string') {\n\t          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n\t        }\n\t      }\n\t    } else {\n\t      markStaticNode(tree, key, isOnce);\n\t    }\n\t  }\n\t\n\t  function markStaticNode (node, key, isOnce) {\n\t    node.isStatic = true;\n\t    node.key = key;\n\t    node.isOnce = isOnce;\n\t  }\n\t\n\t  // filter resolution helper\n\t  Vue.prototype._f = function resolveFilter (id) {\n\t    return resolveAsset(this.$options, 'filters', id, true) || identity\n\t  };\n\t\n\t  // render v-for\n\t  Vue.prototype._l = function renderList (\n\t    val,\n\t    render\n\t  ) {\n\t    var ret, i, l, keys, key;\n\t    if (Array.isArray(val) || typeof val === 'string') {\n\t      ret = new Array(val.length);\n\t      for (i = 0, l = val.length; i < l; i++) {\n\t        ret[i] = render(val[i], i);\n\t      }\n\t    } else if (typeof val === 'number') {\n\t      ret = new Array(val);\n\t      for (i = 0; i < val; i++) {\n\t        ret[i] = render(i + 1, i);\n\t      }\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      ret = new Array(keys.length);\n\t      for (i = 0, l = keys.length; i < l; i++) {\n\t        key = keys[i];\n\t        ret[i] = render(val[key], key, i);\n\t      }\n\t    }\n\t    return ret\n\t  };\n\t\n\t  // renderSlot\n\t  Vue.prototype._t = function (\n\t    name,\n\t    fallback,\n\t    props,\n\t    bindObject\n\t  ) {\n\t    var scopedSlotFn = this.$scopedSlots[name];\n\t    if (scopedSlotFn) { // scoped slot\n\t      props = props || {};\n\t      if (bindObject) {\n\t        extend(props, bindObject);\n\t      }\n\t      return scopedSlotFn(props) || fallback\n\t    } else {\n\t      var slotNodes = this.$slots[name];\n\t      // warn duplicate slot usage\n\t      if (slotNodes && (\"production\") !== 'production') {\n\t        slotNodes._rendered && warn(\n\t          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n\t          \"- this will likely cause render errors.\",\n\t          this\n\t        );\n\t        slotNodes._rendered = true;\n\t      }\n\t      return slotNodes || fallback\n\t    }\n\t  };\n\t\n\t  // apply v-bind object\n\t  Vue.prototype._b = function bindProps (\n\t    data,\n\t    tag,\n\t    value,\n\t    asProp\n\t  ) {\n\t    if (value) {\n\t      if (!isObject(value)) {\n\t        (\"production\") !== 'production' && warn(\n\t          'v-bind without argument expects an Object or Array value',\n\t          this\n\t        );\n\t      } else {\n\t        if (Array.isArray(value)) {\n\t          value = toObject(value);\n\t        }\n\t        for (var key in value) {\n\t          if (key === 'class' || key === 'style') {\n\t            data[key] = value[key];\n\t          } else {\n\t            var hash = asProp || config.mustUseProp(tag, key)\n\t              ? data.domProps || (data.domProps = {})\n\t              : data.attrs || (data.attrs = {});\n\t            hash[key] = value[key];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return data\n\t  };\n\t\n\t  // check v-on keyCodes\n\t  Vue.prototype._k = function checkKeyCodes (\n\t    eventKeyCode,\n\t    key,\n\t    builtInAlias\n\t  ) {\n\t    var keyCodes = config.keyCodes[key] || builtInAlias;\n\t    if (Array.isArray(keyCodes)) {\n\t      return keyCodes.indexOf(eventKeyCode) === -1\n\t    } else {\n\t      return keyCodes !== eventKeyCode\n\t    }\n\t  };\n\t}\n\t\n\tfunction resolveSlots (\n\t  children,\n\t  context\n\t) {\n\t  var slots = {};\n\t  if (!children) {\n\t    return slots\n\t  }\n\t  var defaultSlot = [];\n\t  var name, child;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    child = children[i];\n\t    // named slots should only be respected if the vnode was rendered in the\n\t    // same context.\n\t    if ((child.context === context || child.functionalContext === context) &&\n\t        child.data && (name = child.data.slot)) {\n\t      var slot = (slots[name] || (slots[name] = []));\n\t      if (child.tag === 'template') {\n\t        slot.push.apply(slot, child.children);\n\t      } else {\n\t        slot.push(child);\n\t      }\n\t    } else {\n\t      defaultSlot.push(child);\n\t    }\n\t  }\n\t  // ignore single whitespace\n\t  if (defaultSlot.length && !(\n\t    defaultSlot.length === 1 &&\n\t    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n\t  )) {\n\t    slots.default = defaultSlot;\n\t  }\n\t  return slots\n\t}\n\t\n\t/*  */\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  Vue.prototype._init = function (options) {\n\t    var vm = this;\n\t    // a uid\n\t    vm._uid = uid++;\n\t    // a flag to avoid this being observed\n\t    vm._isVue = true;\n\t    // merge options\n\t    if (options && options._isComponent) {\n\t      // optimize internal component instantiation\n\t      // since dynamic options merging is pretty slow, and none of the\n\t      // internal component options needs special treatment.\n\t      initInternalComponent(vm, options);\n\t    } else {\n\t      vm.$options = mergeOptions(\n\t        resolveConstructorOptions(vm.constructor),\n\t        options || {},\n\t        vm\n\t      );\n\t    }\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      initProxy(vm);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t    // expose real self\n\t    vm._self = vm;\n\t    initLifecycle(vm);\n\t    initEvents(vm);\n\t    callHook(vm, 'beforeCreate');\n\t    initState(vm);\n\t    callHook(vm, 'created');\n\t    initRender(vm);\n\t  };\n\t}\n\t\n\tfunction initInternalComponent (vm, options) {\n\t  var opts = vm.$options = Object.create(vm.constructor.options);\n\t  // doing this because it's faster than dynamic enumeration.\n\t  opts.parent = options.parent;\n\t  opts.propsData = options.propsData;\n\t  opts._parentVnode = options._parentVnode;\n\t  opts._parentListeners = options._parentListeners;\n\t  opts._renderChildren = options._renderChildren;\n\t  opts._componentTag = options._componentTag;\n\t  opts._parentElm = options._parentElm;\n\t  opts._refElm = options._refElm;\n\t  if (options.render) {\n\t    opts.render = options.render;\n\t    opts.staticRenderFns = options.staticRenderFns;\n\t  }\n\t}\n\t\n\tfunction resolveConstructorOptions (Ctor) {\n\t  var options = Ctor.options;\n\t  if (Ctor.super) {\n\t    var superOptions = Ctor.super.options;\n\t    var cachedSuperOptions = Ctor.superOptions;\n\t    var extendOptions = Ctor.extendOptions;\n\t    if (superOptions !== cachedSuperOptions) {\n\t      // super option changed\n\t      Ctor.superOptions = superOptions;\n\t      extendOptions.render = options.render;\n\t      extendOptions.staticRenderFns = options.staticRenderFns;\n\t      extendOptions._scopeId = options._scopeId;\n\t      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n\t      if (options.name) {\n\t        options.components[options.name] = Ctor;\n\t      }\n\t    }\n\t  }\n\t  return options\n\t}\n\t\n\tfunction Vue$3 (options) {\n\t  if (false) {\n\t    warn('Vue is a constructor and should be called with the `new` keyword');\n\t  }\n\t  this._init(options);\n\t}\n\t\n\tinitMixin(Vue$3);\n\tstateMixin(Vue$3);\n\teventsMixin(Vue$3);\n\tlifecycleMixin(Vue$3);\n\trenderMixin(Vue$3);\n\t\n\t/*  */\n\t\n\tfunction initUse (Vue) {\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initMixin$1 (Vue) {\n\t  Vue.mixin = function (mixin) {\n\t    this.options = mergeOptions(this.options, mixin);\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initExtend (Vue) {\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   */\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var SuperId = Super.cid;\n\t    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t    if (cachedCtors[SuperId]) {\n\t      return cachedCtors[SuperId]\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn(\n\t          'Invalid component name: \"' + name + '\". Component names ' +\n\t          'can only contain alphanumeric characters and the hyphen, ' +\n\t          'and must start with a letter.'\n\t        );\n\t      }\n\t    }\n\t    var Sub = function VueComponent (options) {\n\t      this._init(options);\n\t    };\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(\n\t      Super.options,\n\t      extendOptions\n\t    );\n\t    Sub['super'] = Super;\n\t    // allow further extension/mixin/plugin usage\n\t    Sub.extend = Super.extend;\n\t    Sub.mixin = Super.mixin;\n\t    Sub.use = Super.use;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // keep a reference to the super options at extension time.\n\t    // later at instantiation we can check if Super's options have\n\t    // been updated.\n\t    Sub.superOptions = Super.options;\n\t    Sub.extendOptions = extendOptions;\n\t    // cache constructor\n\t    cachedCtors[SuperId] = Sub;\n\t    return Sub\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initAssetRegisters (Vue) {\n\t  /**\n\t   * Create asset registration methods.\n\t   */\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (\n\t      id,\n\t      definition\n\t    ) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id]\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && config.isReservedTag(id)) {\n\t            warn(\n\t              'Do not use built-in or reserved HTML elements as component ' +\n\t              'id: ' + id\n\t            );\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = definition.name || id;\n\t          definition = this.options._base.extend(definition);\n\t        }\n\t        if (type === 'directive' && typeof definition === 'function') {\n\t          definition = { bind: definition, update: definition };\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\t/*  */\n\t\n\tvar patternTypes = [String, RegExp];\n\t\n\tfunction matches (pattern, name) {\n\t  if (typeof pattern === 'string') {\n\t    return pattern.split(',').indexOf(name) > -1\n\t  } else {\n\t    return pattern.test(name)\n\t  }\n\t}\n\t\n\tvar KeepAlive = {\n\t  name: 'keep-alive',\n\t  abstract: true,\n\t  props: {\n\t    include: patternTypes,\n\t    exclude: patternTypes\n\t  },\n\t  created: function created () {\n\t    this.cache = Object.create(null);\n\t  },\n\t  render: function render () {\n\t    var vnode = getFirstComponentChild(this.$slots.default);\n\t    if (vnode && vnode.componentOptions) {\n\t      var opts = vnode.componentOptions;\n\t      // check pattern\n\t      var name = opts.Ctor.options.name || opts.tag;\n\t      if (name && (\n\t        (this.include && !matches(this.include, name)) ||\n\t        (this.exclude && matches(this.exclude, name))\n\t      )) {\n\t        return vnode\n\t      }\n\t      var key = vnode.key == null\n\t        // same constructor may get registered as different local components\n\t        // so cid alone is not enough (#3269)\n\t        ? opts.Ctor.cid + (opts.tag ? (\"::\" + (opts.tag)) : '')\n\t        : vnode.key;\n\t      if (this.cache[key]) {\n\t        vnode.child = this.cache[key].child;\n\t      } else {\n\t        this.cache[key] = vnode;\n\t      }\n\t      vnode.data.keepAlive = true;\n\t    }\n\t    return vnode\n\t  },\n\t  destroyed: function destroyed () {\n\t    var this$1 = this;\n\t\n\t    for (var key in this.cache) {\n\t      var vnode = this$1.cache[key];\n\t      callHook(vnode.child, 'deactivated');\n\t      vnode.child.$destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar builtInComponents = {\n\t  KeepAlive: KeepAlive\n\t};\n\t\n\t/*  */\n\t\n\tfunction initGlobalAPI (Vue) {\n\t  // config\n\t  var configDef = {};\n\t  configDef.get = function () { return config; };\n\t  if (false) {\n\t    configDef.set = function () {\n\t      warn(\n\t        'Do not replace the Vue.config object, set individual fields instead.'\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue, 'config', configDef);\n\t  Vue.util = util;\n\t  Vue.set = set$1;\n\t  Vue.delete = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  Vue.options = Object.create(null);\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue.options[type + 's'] = Object.create(null);\n\t  });\n\t\n\t  // this is used to identify the \"base\" constructor to extend all plain-object\n\t  // components with in Weex's multi-instance scenarios.\n\t  Vue.options._base = Vue;\n\t\n\t  extend(Vue.options.components, builtInComponents);\n\t\n\t  initUse(Vue);\n\t  initMixin$1(Vue);\n\t  initExtend(Vue);\n\t  initAssetRegisters(Vue);\n\t}\n\t\n\tinitGlobalAPI(Vue$3);\n\t\n\tObject.defineProperty(Vue$3.prototype, '$isServer', {\n\t  get: isServerRendering\n\t});\n\t\n\tVue$3.version = '2.1.8';\n\t\n\t/*  */\n\t\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function (tag, attr) {\n\t  return (\n\t    (attr === 'value' && acceptValue(tag)) ||\n\t    (attr === 'selected' && tag === 'option') ||\n\t    (attr === 'checked' && tag === 'input') ||\n\t    (attr === 'muted' && tag === 'video')\n\t  )\n\t};\n\t\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\t\n\tvar isBooleanAttr = makeMap(\n\t  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n\t  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n\t  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n\t  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n\t  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n\t  'truespeed,typemustmatch,visible'\n\t);\n\t\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\n\tvar isXlink = function (name) {\n\t  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n\t};\n\t\n\tvar getXlinkProp = function (name) {\n\t  return isXlink(name) ? name.slice(6, name.length) : ''\n\t};\n\t\n\tvar isFalsyAttrValue = function (val) {\n\t  return val == null || val === false\n\t};\n\t\n\t/*  */\n\t\n\tfunction genClassForVnode (vnode) {\n\t  var data = vnode.data;\n\t  var parentNode = vnode;\n\t  var childNode = vnode;\n\t  while (childNode.child) {\n\t    childNode = childNode.child._vnode;\n\t    if (childNode.data) {\n\t      data = mergeClassData(childNode.data, data);\n\t    }\n\t  }\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data) {\n\t      data = mergeClassData(data, parentNode.data);\n\t    }\n\t  }\n\t  return genClassFromData(data)\n\t}\n\t\n\tfunction mergeClassData (child, parent) {\n\t  return {\n\t    staticClass: concat(child.staticClass, parent.staticClass),\n\t    class: child.class\n\t      ? [child.class, parent.class]\n\t      : parent.class\n\t  }\n\t}\n\t\n\tfunction genClassFromData (data) {\n\t  var dynamicClass = data.class;\n\t  var staticClass = data.staticClass;\n\t  if (staticClass || dynamicClass) {\n\t    return concat(staticClass, stringifyClass(dynamicClass))\n\t  }\n\t  /* istanbul ignore next */\n\t  return ''\n\t}\n\t\n\tfunction concat (a, b) {\n\t  return a ? b ? (a + ' ' + b) : a : (b || '')\n\t}\n\t\n\tfunction stringifyClass (value) {\n\t  var res = '';\n\t  if (!value) {\n\t    return res\n\t  }\n\t  if (typeof value === 'string') {\n\t    return value\n\t  }\n\t  if (Array.isArray(value)) {\n\t    var stringified;\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      if (value[i]) {\n\t        if ((stringified = stringifyClass(value[i]))) {\n\t          res += stringified + ' ';\n\t        }\n\t      }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) { res += key + ' '; }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  /* istanbul ignore next */\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar namespaceMap = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  math: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\t\n\tvar isHTMLTag = makeMap(\n\t  'html,body,base,head,link,meta,style,title,' +\n\t  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n\t  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n\t  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n\t  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n\t  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n\t  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n\t  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n\t  'output,progress,select,textarea,' +\n\t  'details,dialog,menu,menuitem,summary,' +\n\t  'content,element,shadow,template'\n\t);\n\t\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap(\n\t  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n\t  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n\t  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n\t  true\n\t);\n\t\n\tvar isPreTag = function (tag) { return tag === 'pre'; };\n\t\n\tvar isReservedTag = function (tag) {\n\t  return isHTMLTag(tag) || isSVG(tag)\n\t};\n\t\n\tfunction getTagNamespace (tag) {\n\t  if (isSVG(tag)) {\n\t    return 'svg'\n\t  }\n\t  // basic support for MathML\n\t  // note it doesn't support other MathML elements being component roots\n\t  if (tag === 'math') {\n\t    return 'math'\n\t  }\n\t}\n\t\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement (tag) {\n\t  /* istanbul ignore if */\n\t  if (!inBrowser) {\n\t    return true\n\t  }\n\t  if (isReservedTag(tag)) {\n\t    return false\n\t  }\n\t  tag = tag.toLowerCase();\n\t  /* istanbul ignore if */\n\t  if (unknownElementCache[tag] != null) {\n\t    return unknownElementCache[tag]\n\t  }\n\t  var el = document.createElement(tag);\n\t  if (tag.indexOf('-') > -1) {\n\t    // http://stackoverflow.com/a/28210364/1070244\n\t    return (unknownElementCache[tag] = (\n\t      el.constructor === window.HTMLUnknownElement ||\n\t      el.constructor === window.HTMLElement\n\t    ))\n\t  } else {\n\t    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t */\n\tfunction query (el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn(\n\t        'Cannot find element: ' + selector\n\t      );\n\t      return document.createElement('div')\n\t    }\n\t  }\n\t  return el\n\t}\n\t\n\t/*  */\n\t\n\tfunction createElement$1 (tagName, vnode) {\n\t  var elm = document.createElement(tagName);\n\t  if (tagName !== 'select') {\n\t    return elm\n\t  }\n\t  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n\t    elm.setAttribute('multiple', 'multiple');\n\t  }\n\t  return elm\n\t}\n\t\n\tfunction createElementNS (namespace, tagName) {\n\t  return document.createElementNS(namespaceMap[namespace], tagName)\n\t}\n\t\n\tfunction createTextNode (text) {\n\t  return document.createTextNode(text)\n\t}\n\t\n\tfunction createComment (text) {\n\t  return document.createComment(text)\n\t}\n\t\n\tfunction insertBefore (parentNode, newNode, referenceNode) {\n\t  parentNode.insertBefore(newNode, referenceNode);\n\t}\n\t\n\tfunction removeChild (node, child) {\n\t  node.removeChild(child);\n\t}\n\t\n\tfunction appendChild (node, child) {\n\t  node.appendChild(child);\n\t}\n\t\n\tfunction parentNode (node) {\n\t  return node.parentNode\n\t}\n\t\n\tfunction nextSibling (node) {\n\t  return node.nextSibling\n\t}\n\t\n\tfunction tagName (node) {\n\t  return node.tagName\n\t}\n\t\n\tfunction setTextContent (node, text) {\n\t  node.textContent = text;\n\t}\n\t\n\tfunction setAttribute (node, key, val) {\n\t  node.setAttribute(key, val);\n\t}\n\t\n\t\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\t\n\t/*  */\n\t\n\tvar ref = {\n\t  create: function create (_, vnode) {\n\t    registerRef(vnode);\n\t  },\n\t  update: function update (oldVnode, vnode) {\n\t    if (oldVnode.data.ref !== vnode.data.ref) {\n\t      registerRef(oldVnode, true);\n\t      registerRef(vnode);\n\t    }\n\t  },\n\t  destroy: function destroy (vnode) {\n\t    registerRef(vnode, true);\n\t  }\n\t};\n\t\n\tfunction registerRef (vnode, isRemoval) {\n\t  var key = vnode.data.ref;\n\t  if (!key) { return }\n\t\n\t  var vm = vnode.context;\n\t  var ref = vnode.child || vnode.elm;\n\t  var refs = vm.$refs;\n\t  if (isRemoval) {\n\t    if (Array.isArray(refs[key])) {\n\t      remove$1(refs[key], ref);\n\t    } else if (refs[key] === ref) {\n\t      refs[key] = undefined;\n\t    }\n\t  } else {\n\t    if (vnode.data.refInFor) {\n\t      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t        refs[key].push(ref);\n\t      } else {\n\t        refs[key] = [ref];\n\t      }\n\t    } else {\n\t      refs[key] = ref;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Virtual DOM patching algorithm based on Snabbdom by\n\t * Simon Friis Vindum (@paldepind)\n\t * Licensed under the MIT License\n\t * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n\t *\n\t * modified by Evan You (@yyx990803)\n\t *\n\t\n\t/*\n\t * Not type-checking this because this file is perf-critical and the cost\n\t * of making flow understand it is not worth it.\n\t */\n\t\n\tvar emptyNode = new VNode('', {}, []);\n\t\n\tvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\t\n\tfunction isUndef (s) {\n\t  return s == null\n\t}\n\t\n\tfunction isDef (s) {\n\t  return s != null\n\t}\n\t\n\tfunction sameVnode (vnode1, vnode2) {\n\t  return (\n\t    vnode1.key === vnode2.key &&\n\t    vnode1.tag === vnode2.tag &&\n\t    vnode1.isComment === vnode2.isComment &&\n\t    !vnode1.data === !vnode2.data\n\t  )\n\t}\n\t\n\tfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n\t  var i, key;\n\t  var map = {};\n\t  for (i = beginIdx; i <= endIdx; ++i) {\n\t    key = children[i].key;\n\t    if (isDef(key)) { map[key] = i; }\n\t  }\n\t  return map\n\t}\n\t\n\tfunction createPatchFunction (backend) {\n\t  var i, j;\n\t  var cbs = {};\n\t\n\t  var modules = backend.modules;\n\t  var nodeOps = backend.nodeOps;\n\t\n\t  for (i = 0; i < hooks$1.length; ++i) {\n\t    cbs[hooks$1[i]] = [];\n\t    for (j = 0; j < modules.length; ++j) {\n\t      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n\t    }\n\t  }\n\t\n\t  function emptyNodeAt (elm) {\n\t    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n\t  }\n\t\n\t  function createRmCb (childElm, listeners) {\n\t    function remove$$1 () {\n\t      if (--remove$$1.listeners === 0) {\n\t        removeNode(childElm);\n\t      }\n\t    }\n\t    remove$$1.listeners = listeners;\n\t    return remove$$1\n\t  }\n\t\n\t  function removeNode (el) {\n\t    var parent = nodeOps.parentNode(el);\n\t    // element may have already been removed due to v-html / v-text\n\t    if (parent) {\n\t      nodeOps.removeChild(parent, el);\n\t    }\n\t  }\n\t\n\t  var inPre = 0;\n\t  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t    vnode.isRootInsert = !nested; // for transition enter check\n\t    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t      return\n\t    }\n\t\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    var tag = vnode.tag;\n\t    if (isDef(tag)) {\n\t      if (false) {\n\t        if (data && data.pre) {\n\t          inPre++;\n\t        }\n\t        if (\n\t          !inPre &&\n\t          !vnode.ns &&\n\t          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n\t          config.isUnknownElement(tag)\n\t        ) {\n\t          warn(\n\t            'Unknown custom element: <' + tag + '> - did you ' +\n\t            'register the component correctly? For recursive components, ' +\n\t            'make sure to provide the \"name\" option.',\n\t            vnode.context\n\t          );\n\t        }\n\t      }\n\t      vnode.elm = vnode.ns\n\t        ? nodeOps.createElementNS(vnode.ns, tag)\n\t        : nodeOps.createElement(tag, vnode);\n\t      setScope(vnode);\n\t\n\t      /* istanbul ignore if */\n\t      {\n\t        createChildren(vnode, children, insertedVnodeQueue);\n\t        if (isDef(data)) {\n\t          invokeCreateHooks(vnode, insertedVnodeQueue);\n\t        }\n\t        insert(parentElm, vnode.elm, refElm);\n\t      }\n\t\n\t      if (false) {\n\t        inPre--;\n\t      }\n\t    } else if (vnode.isComment) {\n\t      vnode.elm = nodeOps.createComment(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    } else {\n\t      vnode.elm = nodeOps.createTextNode(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    }\n\t  }\n\t\n\t  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i = vnode.data;\n\t    if (isDef(i)) {\n\t      var isReactivated = isDef(vnode.child) && i.keepAlive;\n\t      if (isDef(i = i.hook) && isDef(i = i.init)) {\n\t        i(vnode, false /* hydrating */, parentElm, refElm);\n\t      }\n\t      // after calling the init hook, if the vnode is a child component\n\t      // it should've created a child instance and mounted it. the child\n\t      // component also has set the placeholder vnode's elm.\n\t      // in that case we can just return the element and be done.\n\t      if (isDef(vnode.child)) {\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        if (isReactivated) {\n\t          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t        }\n\t        return true\n\t      }\n\t    }\n\t  }\n\t\n\t  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i;\n\t    // hack for #4339: a reactivated component with inner transition\n\t    // does not trigger because the inner node's created hooks are not called\n\t    // again. It's not ideal to involve module-specific logic in here but\n\t    // there doesn't seem to be a better way to do it.\n\t    var innerNode = vnode;\n\t    while (innerNode.child) {\n\t      innerNode = innerNode.child._vnode;\n\t      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t        for (i = 0; i < cbs.activate.length; ++i) {\n\t          cbs.activate[i](emptyNode, innerNode);\n\t        }\n\t        insertedVnodeQueue.push(innerNode);\n\t        break\n\t      }\n\t    }\n\t    // unlike a newly created component,\n\t    // a reactivated keep-alive component doesn't insert itself\n\t    insert(parentElm, vnode.elm, refElm);\n\t  }\n\t\n\t  function insert (parent, elm, ref) {\n\t    if (parent) {\n\t      if (ref) {\n\t        nodeOps.insertBefore(parent, elm, ref);\n\t      } else {\n\t        nodeOps.appendChild(parent, elm);\n\t      }\n\t    }\n\t  }\n\t\n\t  function createChildren (vnode, children, insertedVnodeQueue) {\n\t    if (Array.isArray(children)) {\n\t      for (var i = 0; i < children.length; ++i) {\n\t        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t      }\n\t    } else if (isPrimitive(vnode.text)) {\n\t      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t    }\n\t  }\n\t\n\t  function isPatchable (vnode) {\n\t    while (vnode.child) {\n\t      vnode = vnode.child._vnode;\n\t    }\n\t    return isDef(vnode.tag)\n\t  }\n\t\n\t  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n\t    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t      cbs.create[i$1](emptyNode, vnode);\n\t    }\n\t    i = vnode.data.hook; // Reuse variable\n\t    if (isDef(i)) {\n\t      if (i.create) { i.create(emptyNode, vnode); }\n\t      if (i.insert) { insertedVnodeQueue.push(vnode); }\n\t    }\n\t  }\n\t\n\t  function initComponent (vnode, insertedVnodeQueue) {\n\t    if (vnode.data.pendingInsert) {\n\t      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t    }\n\t    vnode.elm = vnode.child.$el;\n\t    if (isPatchable(vnode)) {\n\t      invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      setScope(vnode);\n\t    } else {\n\t      // empty component root.\n\t      // skip all element-related modules except for ref (#3455)\n\t      registerRef(vnode);\n\t      // make sure to invoke the insert hook\n\t      insertedVnodeQueue.push(vnode);\n\t    }\n\t  }\n\t\n\t  // set scope id attribute for scoped CSS.\n\t  // this is implemented as a special case to avoid the overhead\n\t  // of going through the normal attribute patching process.\n\t  function setScope (vnode) {\n\t    var i;\n\t    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t    if (isDef(i = activeInstance) &&\n\t        i !== vnode.context &&\n\t        isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t  }\n\t\n\t  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t    }\n\t  }\n\t\n\t  function invokeDestroyHook (vnode) {\n\t    var i, j;\n\t    var data = vnode.data;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n\t      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n\t    }\n\t    if (isDef(i = vnode.children)) {\n\t      for (j = 0; j < vnode.children.length; ++j) {\n\t        invokeDestroyHook(vnode.children[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      var ch = vnodes[startIdx];\n\t      if (isDef(ch)) {\n\t        if (isDef(ch.tag)) {\n\t          removeAndInvokeRemoveHook(ch);\n\t          invokeDestroyHook(ch);\n\t        } else { // Text node\n\t          removeNode(ch.elm);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeAndInvokeRemoveHook (vnode, rm) {\n\t    if (rm || isDef(vnode.data)) {\n\t      var listeners = cbs.remove.length + 1;\n\t      if (!rm) {\n\t        // directly removing\n\t        rm = createRmCb(vnode.elm, listeners);\n\t      } else {\n\t        // we have a recursively passed down rm callback\n\t        // increase the listeners count\n\t        rm.listeners += listeners;\n\t      }\n\t      // recursively invoke hooks on child component root node\n\t      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n\t        removeAndInvokeRemoveHook(i, rm);\n\t      }\n\t      for (i = 0; i < cbs.remove.length; ++i) {\n\t        cbs.remove[i](vnode, rm);\n\t      }\n\t      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t        i(vnode, rm);\n\t      } else {\n\t        rm();\n\t      }\n\t    } else {\n\t      removeNode(vnode.elm);\n\t    }\n\t  }\n\t\n\t  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t    var oldStartIdx = 0;\n\t    var newStartIdx = 0;\n\t    var oldEndIdx = oldCh.length - 1;\n\t    var oldStartVnode = oldCh[0];\n\t    var oldEndVnode = oldCh[oldEndIdx];\n\t    var newEndIdx = newCh.length - 1;\n\t    var newStartVnode = newCh[0];\n\t    var newEndVnode = newCh[newEndIdx];\n\t    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\t\n\t    // removeOnly is a special flag used only by <transition-group>\n\t    // to ensure removed elements stay in correct relative positions\n\t    // during leaving transitions\n\t    var canMove = !removeOnly;\n\t\n\t    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t      if (isUndef(oldStartVnode)) {\n\t        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t      } else if (isUndef(oldEndVnode)) {\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else {\n\t        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n\t        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t        if (isUndef(idxInOld)) { // New element\n\t          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t          newStartVnode = newCh[++newStartIdx];\n\t        } else {\n\t          elmToMove = oldCh[idxInOld];\n\t          /* istanbul ignore if */\n\t          if (false) {\n\t            warn(\n\t              'It seems there are duplicate keys that is causing an update error. ' +\n\t              'Make sure each v-for item has a unique key.'\n\t            );\n\t          }\n\t          if (sameVnode(elmToMove, newStartVnode)) {\n\t            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t            oldCh[idxInOld] = undefined;\n\t            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          } else {\n\t            // same key but different element. treat as new element\n\t            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (oldStartIdx > oldEndIdx) {\n\t      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t    } else if (newStartIdx > newEndIdx) {\n\t      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t    }\n\t  }\n\t\n\t  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t    if (oldVnode === vnode) {\n\t      return\n\t    }\n\t    // reuse element for static trees.\n\t    // note we only do this if the vnode is cloned -\n\t    // if the new node is not cloned it means the render functions have been\n\t    // reset by the hot-reload-api and we need to do a proper re-render.\n\t    if (vnode.isStatic &&\n\t        oldVnode.isStatic &&\n\t        vnode.key === oldVnode.key &&\n\t        (vnode.isCloned || vnode.isOnce)) {\n\t      vnode.elm = oldVnode.elm;\n\t      vnode.child = oldVnode.child;\n\t      return\n\t    }\n\t    var i;\n\t    var data = vnode.data;\n\t    var hasData = isDef(data);\n\t    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t      i(oldVnode, vnode);\n\t    }\n\t    var elm = vnode.elm = oldVnode.elm;\n\t    var oldCh = oldVnode.children;\n\t    var ch = vnode.children;\n\t    if (hasData && isPatchable(vnode)) {\n\t      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n\t      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n\t    }\n\t    if (isUndef(vnode.text)) {\n\t      if (isDef(oldCh) && isDef(ch)) {\n\t        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n\t      } else if (isDef(ch)) {\n\t        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n\t        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t      } else if (isDef(oldCh)) {\n\t        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t      } else if (isDef(oldVnode.text)) {\n\t        nodeOps.setTextContent(elm, '');\n\t      }\n\t    } else if (oldVnode.text !== vnode.text) {\n\t      nodeOps.setTextContent(elm, vnode.text);\n\t    }\n\t    if (hasData) {\n\t      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n\t    }\n\t  }\n\t\n\t  function invokeInsertHook (vnode, queue, initial) {\n\t    // delay insert hooks for component root nodes, invoke them after the\n\t    // element is really inserted\n\t    if (initial && vnode.parent) {\n\t      vnode.parent.data.pendingInsert = queue;\n\t    } else {\n\t      for (var i = 0; i < queue.length; ++i) {\n\t        queue[i].data.hook.insert(queue[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var bailed = false;\n\t  // list of modules that can skip create hook during hydration because they\n\t  // are already rendered on the client or has no need for initialization\n\t  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\t\n\t  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t  function hydrate (elm, vnode, insertedVnodeQueue) {\n\t    if (false) {\n\t      if (!assertNodeMatch(elm, vnode)) {\n\t        return false\n\t      }\n\t    }\n\t    vnode.elm = elm;\n\t    var tag = vnode.tag;\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n\t      if (isDef(i = vnode.child)) {\n\t        // child component. it should have hydrated its own tree.\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return true\n\t      }\n\t    }\n\t    if (isDef(tag)) {\n\t      if (isDef(children)) {\n\t        // empty element, allow client to pick up and populate children\n\t        if (!elm.hasChildNodes()) {\n\t          createChildren(vnode, children, insertedVnodeQueue);\n\t        } else {\n\t          var childrenMatch = true;\n\t          var childNode = elm.firstChild;\n\t          for (var i$1 = 0; i$1 < children.length; i$1++) {\n\t            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t              childrenMatch = false;\n\t              break\n\t            }\n\t            childNode = childNode.nextSibling;\n\t          }\n\t          // if childNode is not null, it means the actual childNodes list is\n\t          // longer than the virtual children list.\n\t          if (!childrenMatch || childNode) {\n\t            if (false) {\n\t              bailed = true;\n\t              console.warn('Parent: ', elm);\n\t              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n\t            }\n\t            return false\n\t          }\n\t        }\n\t      }\n\t      if (isDef(data)) {\n\t        for (var key in data) {\n\t          if (!isRenderedModule(key)) {\n\t            invokeCreateHooks(vnode, insertedVnodeQueue);\n\t            break\n\t          }\n\t        }\n\t      }\n\t    } else if (elm.data !== vnode.text) {\n\t      elm.data = vnode.text;\n\t    }\n\t    return true\n\t  }\n\t\n\t  function assertNodeMatch (node, vnode) {\n\t    if (vnode.tag) {\n\t      return (\n\t        vnode.tag.indexOf('vue-component') === 0 ||\n\t        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n\t      )\n\t    } else {\n\t      return node.nodeType === (vnode.isComment ? 8 : 3)\n\t    }\n\t  }\n\t\n\t  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t    if (!vnode) {\n\t      if (oldVnode) { invokeDestroyHook(oldVnode); }\n\t      return\n\t    }\n\t\n\t    var elm, parent;\n\t    var isInitialPatch = false;\n\t    var insertedVnodeQueue = [];\n\t\n\t    if (!oldVnode) {\n\t      // empty mount (likely as component), create new root element\n\t      isInitialPatch = true;\n\t      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t    } else {\n\t      var isRealElement = isDef(oldVnode.nodeType);\n\t      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t        // patch existing root node\n\t        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t      } else {\n\t        if (isRealElement) {\n\t          // mounting to a real element\n\t          // check if this is server-rendered content and if we can perform\n\t          // a successful hydration.\n\t          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n\t            oldVnode.removeAttribute('server-rendered');\n\t            hydrating = true;\n\t          }\n\t          if (hydrating) {\n\t            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t              invokeInsertHook(vnode, insertedVnodeQueue, true);\n\t              return oldVnode\n\t            } else if (false) {\n\t              warn(\n\t                'The client-side rendered virtual DOM tree is not matching ' +\n\t                'server-rendered content. This is likely caused by incorrect ' +\n\t                'HTML markup, for example nesting block-level elements inside ' +\n\t                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n\t                'full client-side render.'\n\t              );\n\t            }\n\t          }\n\t          // either not server-rendered, or hydration failed.\n\t          // create an empty node and replace it\n\t          oldVnode = emptyNodeAt(oldVnode);\n\t        }\n\t        // replacing existing element\n\t        elm = oldVnode.elm;\n\t        parent = nodeOps.parentNode(elm);\n\t        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));\n\t\n\t        if (vnode.parent) {\n\t          // component root element replaced.\n\t          // update parent placeholder node element, recursively\n\t          var ancestor = vnode.parent;\n\t          while (ancestor) {\n\t            ancestor.elm = vnode.elm;\n\t            ancestor = ancestor.parent;\n\t          }\n\t          if (isPatchable(vnode)) {\n\t            for (var i = 0; i < cbs.create.length; ++i) {\n\t              cbs.create[i](emptyNode, vnode.parent);\n\t            }\n\t          }\n\t        }\n\t\n\t        if (parent !== null) {\n\t          removeVnodes(parent, [oldVnode], 0, 0);\n\t        } else if (isDef(oldVnode.tag)) {\n\t          invokeDestroyHook(oldVnode);\n\t        }\n\t      }\n\t    }\n\t\n\t    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t    return vnode.elm\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar directives = {\n\t  create: updateDirectives,\n\t  update: updateDirectives,\n\t  destroy: function unbindDirectives (vnode) {\n\t    updateDirectives(vnode, emptyNode);\n\t  }\n\t};\n\t\n\tfunction updateDirectives (oldVnode, vnode) {\n\t  if (oldVnode.data.directives || vnode.data.directives) {\n\t    _update(oldVnode, vnode);\n\t  }\n\t}\n\t\n\tfunction _update (oldVnode, vnode) {\n\t  var isCreate = oldVnode === emptyNode;\n\t  var isDestroy = vnode === emptyNode;\n\t  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\t\n\t  var dirsWithInsert = [];\n\t  var dirsWithPostpatch = [];\n\t\n\t  var key, oldDir, dir;\n\t  for (key in newDirs) {\n\t    oldDir = oldDirs[key];\n\t    dir = newDirs[key];\n\t    if (!oldDir) {\n\t      // new directive, bind\n\t      callHook$1(dir, 'bind', vnode, oldVnode);\n\t      if (dir.def && dir.def.inserted) {\n\t        dirsWithInsert.push(dir);\n\t      }\n\t    } else {\n\t      // existing directive, update\n\t      dir.oldValue = oldDir.value;\n\t      callHook$1(dir, 'update', vnode, oldVnode);\n\t      if (dir.def && dir.def.componentUpdated) {\n\t        dirsWithPostpatch.push(dir);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dirsWithInsert.length) {\n\t    var callInsert = function () {\n\t      for (var i = 0; i < dirsWithInsert.length; i++) {\n\t        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t      }\n\t    };\n\t    if (isCreate) {\n\t      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n\t    } else {\n\t      callInsert();\n\t    }\n\t  }\n\t\n\t  if (dirsWithPostpatch.length) {\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t      }\n\t    }, 'dir-postpatch');\n\t  }\n\t\n\t  if (!isCreate) {\n\t    for (key in oldDirs) {\n\t      if (!newDirs[key]) {\n\t        // no longer present, unbind\n\t        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar emptyModifiers = Object.create(null);\n\t\n\tfunction normalizeDirectives$1 (\n\t  dirs,\n\t  vm\n\t) {\n\t  var res = Object.create(null);\n\t  if (!dirs) {\n\t    return res\n\t  }\n\t  var i, dir;\n\t  for (i = 0; i < dirs.length; i++) {\n\t    dir = dirs[i];\n\t    if (!dir.modifiers) {\n\t      dir.modifiers = emptyModifiers;\n\t    }\n\t    res[getRawDirName(dir)] = dir;\n\t    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getRawDirName (dir) {\n\t  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n\t}\n\t\n\tfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n\t  var fn = dir.def && dir.def[hook];\n\t  if (fn) {\n\t    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t  }\n\t}\n\t\n\tvar baseModules = [\n\t  ref,\n\t  directives\n\t];\n\t\n\t/*  */\n\t\n\tfunction updateAttrs (oldVnode, vnode) {\n\t  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n\t    return\n\t  }\n\t  var key, cur, old;\n\t  var elm = vnode.elm;\n\t  var oldAttrs = oldVnode.data.attrs || {};\n\t  var attrs = vnode.data.attrs || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (attrs.__ob__) {\n\t    attrs = vnode.data.attrs = extend({}, attrs);\n\t  }\n\t\n\t  for (key in attrs) {\n\t    cur = attrs[key];\n\t    old = oldAttrs[key];\n\t    if (old !== cur) {\n\t      setAttr(elm, key, cur);\n\t    }\n\t  }\n\t  // #4391: in IE9, setting type can reset value for input[type=radio]\n\t  /* istanbul ignore if */\n\t  if (isIE9 && attrs.value !== oldAttrs.value) {\n\t    setAttr(elm, 'value', attrs.value);\n\t  }\n\t  for (key in oldAttrs) {\n\t    if (attrs[key] == null) {\n\t      if (isXlink(key)) {\n\t        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t      } else if (!isEnumeratedAttr(key)) {\n\t        elm.removeAttribute(key);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction setAttr (el, key, value) {\n\t  if (isBooleanAttr(key)) {\n\t    // set attribute for blank value\n\t    // e.g. <option disabled>Select one</option>\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, key);\n\t    }\n\t  } else if (isEnumeratedAttr(key)) {\n\t    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t  } else if (isXlink(key)) {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t    } else {\n\t      el.setAttributeNS(xlinkNS, key, value);\n\t    }\n\t  } else {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, value);\n\t    }\n\t  }\n\t}\n\t\n\tvar attrs = {\n\t  create: updateAttrs,\n\t  update: updateAttrs\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateClass (oldVnode, vnode) {\n\t  var el = vnode.elm;\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t  if (!data.staticClass && !data.class &&\n\t      (!oldData || (!oldData.staticClass && !oldData.class))) {\n\t    return\n\t  }\n\t\n\t  var cls = genClassForVnode(vnode);\n\t\n\t  // handle transition classes\n\t  var transitionClass = el._transitionClasses;\n\t  if (transitionClass) {\n\t    cls = concat(cls, stringifyClass(transitionClass));\n\t  }\n\t\n\t  // set the class\n\t  if (cls !== el._prevClass) {\n\t    el.setAttribute('class', cls);\n\t    el._prevClass = cls;\n\t  }\n\t}\n\t\n\tvar klass = {\n\t  create: updateClass,\n\t  update: updateClass\n\t};\n\t\n\t/*  */\n\t\n\tvar target$1;\n\t\n\tfunction add$2 (event, handler, once, capture) {\n\t  if (once) {\n\t    var oldHandler = handler;\n\t    handler = function (ev) {\n\t      remove$3(event, handler, capture);\n\t      arguments.length === 1\n\t        ? oldHandler(ev)\n\t        : oldHandler.apply(null, arguments);\n\t    };\n\t  }\n\t  target$1.addEventListener(event, handler, capture);\n\t}\n\t\n\tfunction remove$3 (event, handler, capture) {\n\t  target$1.removeEventListener(event, handler, capture);\n\t}\n\t\n\tfunction updateDOMListeners (oldVnode, vnode) {\n\t  if (!oldVnode.data.on && !vnode.data.on) {\n\t    return\n\t  }\n\t  var on = vnode.data.on || {};\n\t  var oldOn = oldVnode.data.on || {};\n\t  target$1 = vnode.elm;\n\t  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n\t}\n\t\n\tvar events = {\n\t  create: updateDOMListeners,\n\t  update: updateDOMListeners\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateDOMProps (oldVnode, vnode) {\n\t  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n\t    return\n\t  }\n\t  var key, cur;\n\t  var elm = vnode.elm;\n\t  var oldProps = oldVnode.data.domProps || {};\n\t  var props = vnode.data.domProps || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (props.__ob__) {\n\t    props = vnode.data.domProps = extend({}, props);\n\t  }\n\t\n\t  for (key in oldProps) {\n\t    if (props[key] == null) {\n\t      elm[key] = '';\n\t    }\n\t  }\n\t  for (key in props) {\n\t    cur = props[key];\n\t    // ignore children if the node has textContent or innerHTML,\n\t    // as these will throw away existing DOM nodes and cause removal errors\n\t    // on subsequent patches (#3360)\n\t    if (key === 'textContent' || key === 'innerHTML') {\n\t      if (vnode.children) { vnode.children.length = 0; }\n\t      if (cur === oldProps[key]) { continue }\n\t    }\n\t    // #4521: if a click event triggers update before the change event is\n\t    // dispatched on a checkbox/radio input, the input's checked state will\n\t    // be reset and fail to trigger another update.\n\t    /* istanbul ignore next */\n\t    if (key === 'checked' && !isDirty(elm, cur)) {\n\t      continue\n\t    }\n\t    if (key === 'value') {\n\t      // store value as _value as well since\n\t      // non-string values will be stringified\n\t      elm._value = cur;\n\t      // avoid resetting cursor position when value is the same\n\t      var strCur = cur == null ? '' : String(cur);\n\t      if (shouldUpdateValue(elm, vnode, strCur)) {\n\t        elm.value = strCur;\n\t      }\n\t    } else {\n\t      elm[key] = cur;\n\t    }\n\t  }\n\t}\n\t\n\t// check platforms/web/util/attrs.js acceptValue\n\t\n\t\n\tfunction shouldUpdateValue (\n\t  elm,\n\t  vnode,\n\t  checkVal\n\t) {\n\t  if (!elm.composing && (\n\t    vnode.tag === 'option' ||\n\t    isDirty(elm, checkVal) ||\n\t    isInputChanged(vnode, checkVal)\n\t  )) {\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tfunction isDirty (elm, checkVal) {\n\t  return document.activeElement !== elm && elm.value !== checkVal\n\t}\n\t\n\tfunction isInputChanged (vnode, newVal) {\n\t  var value = vnode.elm.value;\n\t  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n\t  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n\t    return toNumber(value) !== toNumber(newVal)\n\t  }\n\t  if (modifiers && modifiers.trim) {\n\t    return value.trim() !== newVal.trim()\n\t  }\n\t  return value !== newVal\n\t}\n\t\n\tvar domProps = {\n\t  create: updateDOMProps,\n\t  update: updateDOMProps\n\t};\n\t\n\t/*  */\n\t\n\tvar parseStyleText = cached(function (cssText) {\n\t  var res = {};\n\t  var listDelimiter = /;(?![^(]*\\))/g;\n\t  var propertyDelimiter = /:(.+)/;\n\t  cssText.split(listDelimiter).forEach(function (item) {\n\t    if (item) {\n\t      var tmp = item.split(propertyDelimiter);\n\t      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t    }\n\t  });\n\t  return res\n\t});\n\t\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData (data) {\n\t  var style = normalizeStyleBinding(data.style);\n\t  // static style is pre-processed into an object during compilation\n\t  // and is always a fresh object, so it's safe to merge into it\n\t  return data.staticStyle\n\t    ? extend(data.staticStyle, style)\n\t    : style\n\t}\n\t\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding (bindingStyle) {\n\t  if (Array.isArray(bindingStyle)) {\n\t    return toObject(bindingStyle)\n\t  }\n\t  if (typeof bindingStyle === 'string') {\n\t    return parseStyleText(bindingStyle)\n\t  }\n\t  return bindingStyle\n\t}\n\t\n\t/**\n\t * parent component style should be after child's\n\t * so that parent component's style could override it\n\t */\n\tfunction getStyle (vnode, checkChild) {\n\t  var res = {};\n\t  var styleData;\n\t\n\t  if (checkChild) {\n\t    var childNode = vnode;\n\t    while (childNode.child) {\n\t      childNode = childNode.child._vnode;\n\t      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t        extend(res, styleData);\n\t      }\n\t    }\n\t  }\n\t\n\t  if ((styleData = normalizeStyleData(vnode.data))) {\n\t    extend(res, styleData);\n\t  }\n\t\n\t  var parentNode = vnode;\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t      extend(res, styleData);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function (el, name, val) {\n\t  /* istanbul ignore if */\n\t  if (cssVarRE.test(name)) {\n\t    el.style.setProperty(name, val);\n\t  } else if (importantRE.test(val)) {\n\t    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t  } else {\n\t    el.style[normalize(name)] = val;\n\t  }\n\t};\n\t\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\t\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t  testEl = testEl || document.createElement('div');\n\t  prop = camelize(prop);\n\t  if (prop !== 'filter' && (prop in testEl.style)) {\n\t    return prop\n\t  }\n\t  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t  for (var i = 0; i < prefixes.length; i++) {\n\t    var prefixed = prefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return prefixed\n\t    }\n\t  }\n\t});\n\t\n\tfunction updateStyle (oldVnode, vnode) {\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t\n\t  if (!data.staticStyle && !data.style &&\n\t      !oldData.staticStyle && !oldData.style) {\n\t    return\n\t  }\n\t\n\t  var cur, name;\n\t  var el = vnode.elm;\n\t  var oldStaticStyle = oldVnode.data.staticStyle;\n\t  var oldStyleBinding = oldVnode.data.style || {};\n\t\n\t  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t  var oldStyle = oldStaticStyle || oldStyleBinding;\n\t\n\t  var style = normalizeStyleBinding(vnode.data.style) || {};\n\t\n\t  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\t\n\t  var newStyle = getStyle(vnode, true);\n\t\n\t  for (name in oldStyle) {\n\t    if (newStyle[name] == null) {\n\t      setProp(el, name, '');\n\t    }\n\t  }\n\t  for (name in newStyle) {\n\t    cur = newStyle[name];\n\t    if (cur !== oldStyle[name]) {\n\t      // ie9 setting to null has no effect, must use empty string\n\t      setProp(el, name, cur == null ? '' : cur);\n\t    }\n\t  }\n\t}\n\t\n\tvar style = {\n\t  create: updateStyle,\n\t  update: updateStyle\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Add class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction addClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n\t    } else {\n\t      el.classList.add(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      el.setAttribute('class', (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction removeClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n\t    } else {\n\t      el.classList.remove(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    el.setAttribute('class', cur.trim());\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\t\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t  /* istanbul ignore if */\n\t  if (window.ontransitionend === undefined &&\n\t    window.onwebkittransitionend !== undefined) {\n\t    transitionProp = 'WebkitTransition';\n\t    transitionEndEvent = 'webkitTransitionEnd';\n\t  }\n\t  if (window.onanimationend === undefined &&\n\t    window.onwebkitanimationend !== undefined) {\n\t    animationProp = 'WebkitAnimation';\n\t    animationEndEvent = 'webkitAnimationEnd';\n\t  }\n\t}\n\t\n\tvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\n\tfunction nextFrame (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t}\n\t\n\tfunction addTransitionClass (el, cls) {\n\t  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t  addClass(el, cls);\n\t}\n\t\n\tfunction removeTransitionClass (el, cls) {\n\t  if (el._transitionClasses) {\n\t    remove$1(el._transitionClasses, cls);\n\t  }\n\t  removeClass(el, cls);\n\t}\n\t\n\tfunction whenTransitionEnds (\n\t  el,\n\t  expectedType,\n\t  cb\n\t) {\n\t  var ref = getTransitionInfo(el, expectedType);\n\t  var type = ref.type;\n\t  var timeout = ref.timeout;\n\t  var propCount = ref.propCount;\n\t  if (!type) { return cb() }\n\t  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t  var ended = 0;\n\t  var end = function () {\n\t    el.removeEventListener(event, onEnd);\n\t    cb();\n\t  };\n\t  var onEnd = function (e) {\n\t    if (e.target === el) {\n\t      if (++ended >= propCount) {\n\t        end();\n\t      }\n\t    }\n\t  };\n\t  setTimeout(function () {\n\t    if (ended < propCount) {\n\t      end();\n\t    }\n\t  }, timeout + 1);\n\t  el.addEventListener(event, onEnd);\n\t}\n\t\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\t\n\tfunction getTransitionInfo (el, expectedType) {\n\t  var styles = window.getComputedStyle(el);\n\t  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n\t  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n\t  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\t\n\t  var type;\n\t  var timeout = 0;\n\t  var propCount = 0;\n\t  /* istanbul ignore if */\n\t  if (expectedType === TRANSITION) {\n\t    if (transitionTimeout > 0) {\n\t      type = TRANSITION;\n\t      timeout = transitionTimeout;\n\t      propCount = transitionDurations.length;\n\t    }\n\t  } else if (expectedType === ANIMATION) {\n\t    if (animationTimeout > 0) {\n\t      type = ANIMATION;\n\t      timeout = animationTimeout;\n\t      propCount = animationDurations.length;\n\t    }\n\t  } else {\n\t    timeout = Math.max(transitionTimeout, animationTimeout);\n\t    type = timeout > 0\n\t      ? transitionTimeout > animationTimeout\n\t        ? TRANSITION\n\t        : ANIMATION\n\t      : null;\n\t    propCount = type\n\t      ? type === TRANSITION\n\t        ? transitionDurations.length\n\t        : animationDurations.length\n\t      : 0;\n\t  }\n\t  var hasTransform =\n\t    type === TRANSITION &&\n\t    transformRE.test(styles[transitionProp + 'Property']);\n\t  return {\n\t    type: type,\n\t    timeout: timeout,\n\t    propCount: propCount,\n\t    hasTransform: hasTransform\n\t  }\n\t}\n\t\n\tfunction getTimeout (delays, durations) {\n\t  /* istanbul ignore next */\n\t  while (delays.length < durations.length) {\n\t    delays = delays.concat(delays);\n\t  }\n\t\n\t  return Math.max.apply(null, durations.map(function (d, i) {\n\t    return toMs(d) + toMs(delays[i])\n\t  }))\n\t}\n\t\n\tfunction toMs (s) {\n\t  return Number(s.slice(0, -1)) * 1000\n\t}\n\t\n\t/*  */\n\t\n\tfunction enter (vnode, toggleDisplay) {\n\t  var el = vnode.elm;\n\t\n\t  // call leave callback now\n\t  if (el._leaveCb) {\n\t    el._leaveCb.cancelled = true;\n\t    el._leaveCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._enterCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var enterClass = data.enterClass;\n\t  var enterToClass = data.enterToClass;\n\t  var enterActiveClass = data.enterActiveClass;\n\t  var appearClass = data.appearClass;\n\t  var appearToClass = data.appearToClass;\n\t  var appearActiveClass = data.appearActiveClass;\n\t  var beforeEnter = data.beforeEnter;\n\t  var enter = data.enter;\n\t  var afterEnter = data.afterEnter;\n\t  var enterCancelled = data.enterCancelled;\n\t  var beforeAppear = data.beforeAppear;\n\t  var appear = data.appear;\n\t  var afterAppear = data.afterAppear;\n\t  var appearCancelled = data.appearCancelled;\n\t\n\t  // activeInstance will always be the <transition> component managing this\n\t  // transition. One edge case to check is when the <transition> is placed\n\t  // as the root node of a child component. In that case we need to check\n\t  // <transition>'s parent for appear check.\n\t  var context = activeInstance;\n\t  var transitionNode = activeInstance.$vnode;\n\t  while (transitionNode && transitionNode.parent) {\n\t    transitionNode = transitionNode.parent;\n\t    context = transitionNode.context;\n\t  }\n\t\n\t  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\t\n\t  if (isAppear && !appear && appear !== '') {\n\t    return\n\t  }\n\t\n\t  var startClass = isAppear ? appearClass : enterClass;\n\t  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n\t  var toClass = isAppear ? appearToClass : enterToClass;\n\t  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n\t  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n\t  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n\t  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    enterHook &&\n\t    // enterHook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (enterHook._length || enterHook.length) > 1;\n\t\n\t  var cb = el._enterCb = once(function () {\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, toClass);\n\t      removeTransitionClass(el, activeClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, startClass);\n\t      }\n\t      enterCancelledHook && enterCancelledHook(el);\n\t    } else {\n\t      afterEnterHook && afterEnterHook(el);\n\t    }\n\t    el._enterCb = null;\n\t  });\n\t\n\t  if (!vnode.data.show) {\n\t    // remove pending leave element on enter by injecting an insert hook\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t      var parent = el.parentNode;\n\t      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t      if (pendingNode &&\n\t          pendingNode.context === vnode.context &&\n\t          pendingNode.tag === vnode.tag &&\n\t          pendingNode.elm._leaveCb) {\n\t        pendingNode.elm._leaveCb();\n\t      }\n\t      enterHook && enterHook(el, cb);\n\t    }, 'transition-insert');\n\t  }\n\t\n\t  // start enter transition\n\t  beforeEnterHook && beforeEnterHook(el);\n\t  if (expectsCSS) {\n\t    addTransitionClass(el, startClass);\n\t    addTransitionClass(el, activeClass);\n\t    nextFrame(function () {\n\t      addTransitionClass(el, toClass);\n\t      removeTransitionClass(el, startClass);\n\t      if (!cb.cancelled && !userWantsControl) {\n\t        whenTransitionEnds(el, type, cb);\n\t      }\n\t    });\n\t  }\n\t\n\t  if (vnode.data.show) {\n\t    toggleDisplay && toggleDisplay();\n\t    enterHook && enterHook(el, cb);\n\t  }\n\t\n\t  if (!expectsCSS && !userWantsControl) {\n\t    cb();\n\t  }\n\t}\n\t\n\tfunction leave (vnode, rm) {\n\t  var el = vnode.elm;\n\t\n\t  // call enter callback now\n\t  if (el._enterCb) {\n\t    el._enterCb.cancelled = true;\n\t    el._enterCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return rm()\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._leaveCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var leaveClass = data.leaveClass;\n\t  var leaveToClass = data.leaveToClass;\n\t  var leaveActiveClass = data.leaveActiveClass;\n\t  var beforeLeave = data.beforeLeave;\n\t  var leave = data.leave;\n\t  var afterLeave = data.afterLeave;\n\t  var leaveCancelled = data.leaveCancelled;\n\t  var delayLeave = data.delayLeave;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    leave &&\n\t    // leave hook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (leave._length || leave.length) > 1;\n\t\n\t  var cb = el._leaveCb = once(function () {\n\t    if (el.parentNode && el.parentNode._pending) {\n\t      el.parentNode._pending[vnode.key] = null;\n\t    }\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, leaveToClass);\n\t      removeTransitionClass(el, leaveActiveClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, leaveClass);\n\t      }\n\t      leaveCancelled && leaveCancelled(el);\n\t    } else {\n\t      rm();\n\t      afterLeave && afterLeave(el);\n\t    }\n\t    el._leaveCb = null;\n\t  });\n\t\n\t  if (delayLeave) {\n\t    delayLeave(performLeave);\n\t  } else {\n\t    performLeave();\n\t  }\n\t\n\t  function performLeave () {\n\t    // the delayed leave may have already been cancelled\n\t    if (cb.cancelled) {\n\t      return\n\t    }\n\t    // record leaving element\n\t    if (!vnode.data.show) {\n\t      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t    }\n\t    beforeLeave && beforeLeave(el);\n\t    if (expectsCSS) {\n\t      addTransitionClass(el, leaveClass);\n\t      addTransitionClass(el, leaveActiveClass);\n\t      nextFrame(function () {\n\t        addTransitionClass(el, leaveToClass);\n\t        removeTransitionClass(el, leaveClass);\n\t        if (!cb.cancelled && !userWantsControl) {\n\t          whenTransitionEnds(el, type, cb);\n\t        }\n\t      });\n\t    }\n\t    leave && leave(el, cb);\n\t    if (!expectsCSS && !userWantsControl) {\n\t      cb();\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveTransition (def$$1) {\n\t  if (!def$$1) {\n\t    return\n\t  }\n\t  /* istanbul ignore else */\n\t  if (typeof def$$1 === 'object') {\n\t    var res = {};\n\t    if (def$$1.css !== false) {\n\t      extend(res, autoCssTransition(def$$1.name || 'v'));\n\t    }\n\t    extend(res, def$$1);\n\t    return res\n\t  } else if (typeof def$$1 === 'string') {\n\t    return autoCssTransition(def$$1)\n\t  }\n\t}\n\t\n\tvar autoCssTransition = cached(function (name) {\n\t  return {\n\t    enterClass: (name + \"-enter\"),\n\t    leaveClass: (name + \"-leave\"),\n\t    appearClass: (name + \"-enter\"),\n\t    enterToClass: (name + \"-enter-to\"),\n\t    leaveToClass: (name + \"-leave-to\"),\n\t    appearToClass: (name + \"-enter-to\"),\n\t    enterActiveClass: (name + \"-enter-active\"),\n\t    leaveActiveClass: (name + \"-leave-active\"),\n\t    appearActiveClass: (name + \"-enter-active\")\n\t  }\n\t});\n\t\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (!called) {\n\t      called = true;\n\t      fn();\n\t    }\n\t  }\n\t}\n\t\n\tfunction _enter (_, vnode) {\n\t  if (!vnode.data.show) {\n\t    enter(vnode);\n\t  }\n\t}\n\t\n\tvar transition = inBrowser ? {\n\t  create: _enter,\n\t  activate: _enter,\n\t  remove: function remove (vnode, rm) {\n\t    /* istanbul ignore else */\n\t    if (!vnode.data.show) {\n\t      leave(vnode, rm);\n\t    } else {\n\t      rm();\n\t    }\n\t  }\n\t} : {};\n\t\n\tvar platformModules = [\n\t  attrs,\n\t  klass,\n\t  events,\n\t  domProps,\n\t  style,\n\t  transition\n\t];\n\t\n\t/*  */\n\t\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\t\n\tvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\t\n\t/**\n\t * Not type checking this file because flow doesn't like attaching\n\t * properties to Elements.\n\t */\n\t\n\tvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\t\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t  // http://www.matts411.com/post/internet-explorer-9-oninput/\n\t  document.addEventListener('selectionchange', function () {\n\t    var el = document.activeElement;\n\t    if (el && el.vmodel) {\n\t      trigger(el, 'input');\n\t    }\n\t  });\n\t}\n\t\n\tvar model = {\n\t  inserted: function inserted (el, binding, vnode) {\n\t    if (false) {\n\t      if (!modelableTagRE.test(vnode.tag)) {\n\t        warn(\n\t          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n\t          'If you are working with contenteditable, it\\'s recommended to ' +\n\t          'wrap a library dedicated for that purpose inside a custom component.',\n\t          vnode.context\n\t        );\n\t      }\n\t    }\n\t    if (vnode.tag === 'select') {\n\t      var cb = function () {\n\t        setSelected(el, binding, vnode.context);\n\t      };\n\t      cb();\n\t      /* istanbul ignore if */\n\t      if (isIE || isEdge) {\n\t        setTimeout(cb, 0);\n\t      }\n\t    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n\t      el._vModifiers = binding.modifiers;\n\t      if (!binding.modifiers.lazy) {\n\t        if (!isAndroid) {\n\t          el.addEventListener('compositionstart', onCompositionStart);\n\t          el.addEventListener('compositionend', onCompositionEnd);\n\t        }\n\t        /* istanbul ignore if */\n\t        if (isIE9) {\n\t          el.vmodel = true;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  componentUpdated: function componentUpdated (el, binding, vnode) {\n\t    if (vnode.tag === 'select') {\n\t      setSelected(el, binding, vnode.context);\n\t      // in case the options rendered by v-for have changed,\n\t      // it's possible that the value is out-of-sync with the rendered options.\n\t      // detect such cases and filter out values that no longer has a matching\n\t      // option in the DOM.\n\t      var needReset = el.multiple\n\t        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n\t        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t      if (needReset) {\n\t        trigger(el, 'change');\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction setSelected (el, binding, vm) {\n\t  var value = binding.value;\n\t  var isMultiple = el.multiple;\n\t  if (isMultiple && !Array.isArray(value)) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n\t      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var selected, option;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    option = el.options[i];\n\t    if (isMultiple) {\n\t      selected = looseIndexOf(value, getValue(option)) > -1;\n\t      if (option.selected !== selected) {\n\t        option.selected = selected;\n\t      }\n\t    } else {\n\t      if (looseEqual(getValue(option), value)) {\n\t        if (el.selectedIndex !== i) {\n\t          el.selectedIndex = i;\n\t        }\n\t        return\n\t      }\n\t    }\n\t  }\n\t  if (!isMultiple) {\n\t    el.selectedIndex = -1;\n\t  }\n\t}\n\t\n\tfunction hasNoMatchingOption (value, options) {\n\t  for (var i = 0, l = options.length; i < l; i++) {\n\t    if (looseEqual(getValue(options[i]), value)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\tfunction getValue (option) {\n\t  return '_value' in option\n\t    ? option._value\n\t    : option.value\n\t}\n\t\n\tfunction onCompositionStart (e) {\n\t  e.target.composing = true;\n\t}\n\t\n\tfunction onCompositionEnd (e) {\n\t  e.target.composing = false;\n\t  trigger(e.target, 'input');\n\t}\n\t\n\tfunction trigger (el, type) {\n\t  var e = document.createEvent('HTMLEvents');\n\t  e.initEvent(type, true, true);\n\t  el.dispatchEvent(e);\n\t}\n\t\n\t/*  */\n\t\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode (vnode) {\n\t  return vnode.child && (!vnode.data || !vnode.data.transition)\n\t    ? locateNode(vnode.child._vnode)\n\t    : vnode\n\t}\n\t\n\tvar show = {\n\t  bind: function bind (el, ref, vnode) {\n\t    var value = ref.value;\n\t\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    var originalDisplay = el.__vOriginalDisplay =\n\t      el.style.display === 'none' ? '' : el.style.display;\n\t    if (value && transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      enter(vnode, function () {\n\t        el.style.display = originalDisplay;\n\t      });\n\t    } else {\n\t      el.style.display = value ? originalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  update: function update (el, ref, vnode) {\n\t    var value = ref.value;\n\t    var oldValue = ref.oldValue;\n\t\n\t    /* istanbul ignore if */\n\t    if (value === oldValue) { return }\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      if (value) {\n\t        enter(vnode, function () {\n\t          el.style.display = el.__vOriginalDisplay;\n\t        });\n\t      } else {\n\t        leave(vnode, function () {\n\t          el.style.display = 'none';\n\t        });\n\t      }\n\t    } else {\n\t      el.style.display = value ? el.__vOriginalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  unbind: function unbind (\n\t    el,\n\t    binding,\n\t    vnode,\n\t    oldVnode,\n\t    isDestroy\n\t  ) {\n\t    if (!isDestroy) {\n\t      el.style.display = el.__vOriginalDisplay;\n\t    }\n\t  }\n\t};\n\t\n\tvar platformDirectives = {\n\t  model: model,\n\t  show: show\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\t\n\tvar transitionProps = {\n\t  name: String,\n\t  appear: Boolean,\n\t  css: Boolean,\n\t  mode: String,\n\t  type: String,\n\t  enterClass: String,\n\t  leaveClass: String,\n\t  enterToClass: String,\n\t  leaveToClass: String,\n\t  enterActiveClass: String,\n\t  leaveActiveClass: String,\n\t  appearClass: String,\n\t  appearActiveClass: String,\n\t  appearToClass: String\n\t};\n\t\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild (vnode) {\n\t  var compOptions = vnode && vnode.componentOptions;\n\t  if (compOptions && compOptions.Ctor.options.abstract) {\n\t    return getRealChild(getFirstComponentChild(compOptions.children))\n\t  } else {\n\t    return vnode\n\t  }\n\t}\n\t\n\tfunction extractTransitionData (comp) {\n\t  var data = {};\n\t  var options = comp.$options;\n\t  // props\n\t  for (var key in options.propsData) {\n\t    data[key] = comp[key];\n\t  }\n\t  // events.\n\t  // extract listeners and pass them directly to the transition methods\n\t  var listeners = options._parentListeners;\n\t  for (var key$1 in listeners) {\n\t    data[camelize(key$1)] = listeners[key$1].fn;\n\t  }\n\t  return data\n\t}\n\t\n\tfunction placeholder (h, rawChild) {\n\t  return /\\d-keep-alive$/.test(rawChild.tag)\n\t    ? h('keep-alive')\n\t    : null\n\t}\n\t\n\tfunction hasParentTransition (vnode) {\n\t  while ((vnode = vnode.parent)) {\n\t    if (vnode.data.transition) {\n\t      return true\n\t    }\n\t  }\n\t}\n\t\n\tfunction isSameChild (child, oldChild) {\n\t  return oldChild.key === child.key && oldChild.tag === child.tag\n\t}\n\t\n\tvar Transition = {\n\t  name: 'transition',\n\t  props: transitionProps,\n\t  abstract: true,\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var children = this.$slots.default;\n\t    if (!children) {\n\t      return\n\t    }\n\t\n\t    // filter out text nodes (possible whitespaces)\n\t    children = children.filter(function (c) { return c.tag; });\n\t    /* istanbul ignore if */\n\t    if (!children.length) {\n\t      return\n\t    }\n\t\n\t    // warn multiple elements\n\t    if (false) {\n\t      warn(\n\t        '<transition> can only be used on a single element. Use ' +\n\t        '<transition-group> for lists.',\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var mode = this.mode;\n\t\n\t    // warn invalid mode\n\t    if (false) {\n\t      warn(\n\t        'invalid <transition> mode: ' + mode,\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var rawChild = children[0];\n\t\n\t    // if this is a component root node and the component's\n\t    // parent container node also has transition, skip.\n\t    if (hasParentTransition(this.$vnode)) {\n\t      return rawChild\n\t    }\n\t\n\t    // apply transition data to child\n\t    // use getRealChild() to ignore abstract components e.g. keep-alive\n\t    var child = getRealChild(rawChild);\n\t    /* istanbul ignore if */\n\t    if (!child) {\n\t      return rawChild\n\t    }\n\t\n\t    if (this._leaving) {\n\t      return placeholder(h, rawChild)\n\t    }\n\t\n\t    var key = child.key = child.key == null || child.isStatic\n\t      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n\t      : child.key;\n\t    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t    var oldRawChild = this._vnode;\n\t    var oldChild = getRealChild(oldRawChild);\n\t\n\t    // mark v-show\n\t    // so that the transition module can hand over the control to the directive\n\t    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n\t      child.data.show = true;\n\t    }\n\t\n\t    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t      // replace old child transition data with fresh one\n\t      // important for dynamic transitions!\n\t      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t      // handle transition mode\n\t      if (mode === 'out-in') {\n\t        // return placeholder node and queue update when leave finishes\n\t        this._leaving = true;\n\t        mergeVNodeHook(oldData, 'afterLeave', function () {\n\t          this$1._leaving = false;\n\t          this$1.$forceUpdate();\n\t        }, key);\n\t        return placeholder(h, rawChild)\n\t      } else if (mode === 'in-out') {\n\t        var delayedLeave;\n\t        var performLeave = function () { delayedLeave(); };\n\t        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n\t        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n\t        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t          delayedLeave = leave;\n\t        }, key);\n\t      }\n\t    }\n\t\n\t    return rawChild\n\t  }\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\t\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final disired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\t\n\tvar props = extend({\n\t  tag: String,\n\t  moveClass: String\n\t}, transitionProps);\n\t\n\tdelete props.mode;\n\t\n\tvar TransitionGroup = {\n\t  props: props,\n\t\n\t  render: function render (h) {\n\t    var tag = this.tag || this.$vnode.data.tag || 'span';\n\t    var map = Object.create(null);\n\t    var prevChildren = this.prevChildren = this.children;\n\t    var rawChildren = this.$slots.default || [];\n\t    var children = this.children = [];\n\t    var transitionData = extractTransitionData(this);\n\t\n\t    for (var i = 0; i < rawChildren.length; i++) {\n\t      var c = rawChildren[i];\n\t      if (c.tag) {\n\t        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t          children.push(c);\n\t          map[c.key] = c\n\t          ;(c.data || (c.data = {})).transition = transitionData;\n\t        } else if (false) {\n\t          var opts = c.componentOptions;\n\t          var name = opts\n\t            ? (opts.Ctor.options.name || opts.tag)\n\t            : c.tag;\n\t          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n\t        }\n\t      }\n\t    }\n\t\n\t    if (prevChildren) {\n\t      var kept = [];\n\t      var removed = [];\n\t      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t        var c$1 = prevChildren[i$1];\n\t        c$1.data.transition = transitionData;\n\t        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\t        if (map[c$1.key]) {\n\t          kept.push(c$1);\n\t        } else {\n\t          removed.push(c$1);\n\t        }\n\t      }\n\t      this.kept = h(tag, null, kept);\n\t      this.removed = removed;\n\t    }\n\t\n\t    return h(tag, null, children)\n\t  },\n\t\n\t  beforeUpdate: function beforeUpdate () {\n\t    // force removing pass\n\t    this.__patch__(\n\t      this._vnode,\n\t      this.kept,\n\t      false, // hydrating\n\t      true // removeOnly (!important, avoids unnecessary moves)\n\t    );\n\t    this._vnode = this.kept;\n\t  },\n\t\n\t  updated: function updated () {\n\t    var children = this.prevChildren;\n\t    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n\t    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t      return\n\t    }\n\t\n\t    // we divide the work into three loops to avoid mixing DOM reads and writes\n\t    // in each iteration - which helps prevent layout thrashing.\n\t    children.forEach(callPendingCbs);\n\t    children.forEach(recordPosition);\n\t    children.forEach(applyTranslation);\n\t\n\t    // force reflow to put everything in position\n\t    var f = document.body.offsetHeight; // eslint-disable-line\n\t\n\t    children.forEach(function (c) {\n\t      if (c.data.moved) {\n\t        var el = c.elm;\n\t        var s = el.style;\n\t        addTransitionClass(el, moveClass);\n\t        s.transform = s.WebkitTransform = s.transitionDuration = '';\n\t        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n\t          if (!e || /transform$/.test(e.propertyName)) {\n\t            el.removeEventListener(transitionEndEvent, cb);\n\t            el._moveCb = null;\n\t            removeTransitionClass(el, moveClass);\n\t          }\n\t        });\n\t      }\n\t    });\n\t  },\n\t\n\t  methods: {\n\t    hasMove: function hasMove (el, moveClass) {\n\t      /* istanbul ignore if */\n\t      if (!hasTransition) {\n\t        return false\n\t      }\n\t      if (this._hasMove != null) {\n\t        return this._hasMove\n\t      }\n\t      addTransitionClass(el, moveClass);\n\t      var info = getTransitionInfo(el);\n\t      removeTransitionClass(el, moveClass);\n\t      return (this._hasMove = info.hasTransform)\n\t    }\n\t  }\n\t};\n\t\n\tfunction callPendingCbs (c) {\n\t  /* istanbul ignore if */\n\t  if (c.elm._moveCb) {\n\t    c.elm._moveCb();\n\t  }\n\t  /* istanbul ignore if */\n\t  if (c.elm._enterCb) {\n\t    c.elm._enterCb();\n\t  }\n\t}\n\t\n\tfunction recordPosition (c) {\n\t  c.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\t\n\tfunction applyTranslation (c) {\n\t  var oldPos = c.data.pos;\n\t  var newPos = c.data.newPos;\n\t  var dx = oldPos.left - newPos.left;\n\t  var dy = oldPos.top - newPos.top;\n\t  if (dx || dy) {\n\t    c.data.moved = true;\n\t    var s = c.elm.style;\n\t    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t    s.transitionDuration = '0s';\n\t  }\n\t}\n\t\n\tvar platformComponents = {\n\t  Transition: Transition,\n\t  TransitionGroup: TransitionGroup\n\t};\n\t\n\t/*  */\n\t\n\t// install platform specific utils\n\tVue$3.config.isUnknownElement = isUnknownElement;\n\tVue$3.config.isReservedTag = isReservedTag;\n\tVue$3.config.getTagNamespace = getTagNamespace;\n\tVue$3.config.mustUseProp = mustUseProp;\n\t\n\t// install platform runtime directives & components\n\textend(Vue$3.options.directives, platformDirectives);\n\textend(Vue$3.options.components, platformComponents);\n\t\n\t// install platform patch function\n\tVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\t\n\t// wrap mount\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && inBrowser ? query(el) : undefined;\n\t  return this._mount(el, hydrating)\n\t};\n\t\n\tif (false) {\n\t  console[console.info ? 'info' : 'log'](\n\t    \"You are running Vue in development mode.\\n\" +\n\t    \"Make sure to turn on production mode when deploying for production.\\n\" +\n\t    \"See more tips at https://vuejs.org/guide/deployment.html\"\n\t  );\n\t}\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue$3);\n\t    } else if (\n\t      false\n\t    ) {\n\t      console[console.info ? 'info' : 'log'](\n\t        'Download the Vue Devtools extension for a better development experience:\\n' +\n\t        'https://github.com/vuejs/vue-devtools'\n\t      );\n\t    }\n\t  }\n\t}, 0);\n\t\n\t/*  */\n\t\n\t// check whether current browser encodes a char inside attribute values\n\tfunction shouldDecode (content, encoded) {\n\t  var div = document.createElement('div');\n\t  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n\t  return div.innerHTML.indexOf(encoded) > 0\n\t}\n\t\n\t// #3663\n\t// IE encodes newlines inside attribute values while other browsers don't\n\tvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\t\n\t/*  */\n\t\n\tvar decoder;\n\t\n\tfunction decode (html) {\n\t  decoder = decoder || document.createElement('div');\n\t  decoder.innerHTML = html;\n\t  return decoder.textContent\n\t}\n\t\n\t/*  */\n\t\n\tvar isUnaryTag = makeMap(\n\t  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n\t  'link,meta,param,source,track,wbr',\n\t  true\n\t);\n\t\n\t// Elements that you can, intentionally, leave open\n\t// (and which close themselves)\n\tvar canBeLeftOpenTag = makeMap(\n\t  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n\t  true\n\t);\n\t\n\t// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n\t// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\tvar isNonPhrasingTag = makeMap(\n\t  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n\t  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n\t  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n\t  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n\t  'title,tr,track',\n\t  true\n\t);\n\t\n\t/**\n\t * Not type-checking this file because it's mostly vendor code.\n\t */\n\t\n\t/*!\n\t * HTML Parser By John Resig (ejohn.org)\n\t * Modified by Juriy \"kangax\" Zaytsev\n\t * Original code by Erik Arvidsson, Mozilla Public License\n\t * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n\t */\n\t\n\t// Regular Expressions for parsing tags and attributes\n\tvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\n\tvar singleAttrAssign = /(?:=)/;\n\tvar singleAttrValues = [\n\t  // attr value double quotes\n\t  /\"([^\"]*)\"+/.source,\n\t  // attr value, single quotes\n\t  /'([^']*)'+/.source,\n\t  // attr value, no quotes\n\t  /([^\\s\"'=<>`]+)/.source\n\t];\n\tvar attribute = new RegExp(\n\t  '^\\\\s*' + singleAttrIdentifier.source +\n\t  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n\t  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n\t);\n\t\n\t// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n\t// but for Vue templates we can enforce a simple charset\n\tvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n\tvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n\tvar startTagOpen = new RegExp('^<' + qnameCapture);\n\tvar startTagClose = /^\\s*(\\/?)>/;\n\tvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n\tvar doctype = /^<!DOCTYPE [^>]+>/i;\n\tvar comment = /^<!--/;\n\tvar conditionalComment = /^<!\\[/;\n\t\n\tvar IS_REGEX_CAPTURING_BROKEN = false;\n\t'x'.replace(/x(.)?/g, function (m, g) {\n\t  IS_REGEX_CAPTURING_BROKEN = g === '';\n\t});\n\t\n\t// Special Elements (can contain anything)\n\tvar isScriptOrStyle = makeMap('script,style', true);\n\tvar hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };\n\tvar isSpecialTag = function (tag, isSFC, stack) {\n\t  if (isScriptOrStyle(tag)) {\n\t    return true\n\t  }\n\t  if (isSFC && stack.length === 1) {\n\t    // top-level template that has no pre-processor\n\t    if (tag === 'template' && !stack[0].attrs.some(hasLang)) {\n\t      return false\n\t    } else {\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t};\n\t\n\tvar reCache = {};\n\t\n\tvar ltRE = /&lt;/g;\n\tvar gtRE = /&gt;/g;\n\tvar nlRE = /&#10;/g;\n\tvar ampRE = /&amp;/g;\n\tvar quoteRE = /&quot;/g;\n\t\n\tfunction decodeAttr (value, shouldDecodeNewlines) {\n\t  if (shouldDecodeNewlines) {\n\t    value = value.replace(nlRE, '\\n');\n\t  }\n\t  return value\n\t    .replace(ltRE, '<')\n\t    .replace(gtRE, '>')\n\t    .replace(ampRE, '&')\n\t    .replace(quoteRE, '\"')\n\t}\n\t\n\tfunction parseHTML (html, options) {\n\t  var stack = [];\n\t  var expectHTML = options.expectHTML;\n\t  var isUnaryTag$$1 = options.isUnaryTag || no;\n\t  var index = 0;\n\t  var last, lastTag;\n\t  while (html) {\n\t    last = html;\n\t    // Make sure we're not in a script or style element\n\t    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {\n\t      var textEnd = html.indexOf('<');\n\t      if (textEnd === 0) {\n\t        // Comment:\n\t        if (comment.test(html)) {\n\t          var commentEnd = html.indexOf('-->');\n\t\n\t          if (commentEnd >= 0) {\n\t            advance(commentEnd + 3);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\t        if (conditionalComment.test(html)) {\n\t          var conditionalEnd = html.indexOf(']>');\n\t\n\t          if (conditionalEnd >= 0) {\n\t            advance(conditionalEnd + 2);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // Doctype:\n\t        var doctypeMatch = html.match(doctype);\n\t        if (doctypeMatch) {\n\t          advance(doctypeMatch[0].length);\n\t          continue\n\t        }\n\t\n\t        // End tag:\n\t        var endTagMatch = html.match(endTag);\n\t        if (endTagMatch) {\n\t          var curIndex = index;\n\t          advance(endTagMatch[0].length);\n\t          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);\n\t          continue\n\t        }\n\t\n\t        // Start tag:\n\t        var startTagMatch = parseStartTag();\n\t        if (startTagMatch) {\n\t          handleStartTag(startTagMatch);\n\t          continue\n\t        }\n\t      }\n\t\n\t      var text = (void 0), rest$1 = (void 0), next = (void 0);\n\t      if (textEnd > 0) {\n\t        rest$1 = html.slice(textEnd);\n\t        while (\n\t          !endTag.test(rest$1) &&\n\t          !startTagOpen.test(rest$1) &&\n\t          !comment.test(rest$1) &&\n\t          !conditionalComment.test(rest$1)\n\t        ) {\n\t          // < in plain text, be forgiving and treat it as text\n\t          next = rest$1.indexOf('<', 1);\n\t          if (next < 0) { break }\n\t          textEnd += next;\n\t          rest$1 = html.slice(textEnd);\n\t        }\n\t        text = html.substring(0, textEnd);\n\t        advance(textEnd);\n\t      }\n\t\n\t      if (textEnd < 0) {\n\t        text = html;\n\t        html = '';\n\t      }\n\t\n\t      if (options.chars && text) {\n\t        options.chars(text);\n\t      }\n\t    } else {\n\t      var stackedTag = lastTag.toLowerCase();\n\t      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n\t      var endTagLength = 0;\n\t      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n\t        endTagLength = endTag.length;\n\t        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n\t          text = text\n\t            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n\t            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n\t        }\n\t        if (options.chars) {\n\t          options.chars(text);\n\t        }\n\t        return ''\n\t      });\n\t      index += html.length - rest.length;\n\t      html = rest;\n\t      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);\n\t    }\n\t\n\t    if (html === last && options.chars) {\n\t      options.chars(html);\n\t      break\n\t    }\n\t  }\n\t\n\t  // Clean up any remaining tags\n\t  parseEndTag();\n\t\n\t  function advance (n) {\n\t    index += n;\n\t    html = html.substring(n);\n\t  }\n\t\n\t  function parseStartTag () {\n\t    var start = html.match(startTagOpen);\n\t    if (start) {\n\t      var match = {\n\t        tagName: start[1],\n\t        attrs: [],\n\t        start: index\n\t      };\n\t      advance(start[0].length);\n\t      var end, attr;\n\t      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n\t        advance(attr[0].length);\n\t        match.attrs.push(attr);\n\t      }\n\t      if (end) {\n\t        match.unarySlash = end[1];\n\t        advance(end[0].length);\n\t        match.end = index;\n\t        return match\n\t      }\n\t    }\n\t  }\n\t\n\t  function handleStartTag (match) {\n\t    var tagName = match.tagName;\n\t    var unarySlash = match.unarySlash;\n\t\n\t    if (expectHTML) {\n\t      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n\t        parseEndTag('', lastTag);\n\t      }\n\t      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n\t        parseEndTag('', tagName);\n\t      }\n\t    }\n\t\n\t    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\t\n\t    var l = match.attrs.length;\n\t    var attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      var args = match.attrs[i];\n\t      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\t      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n\t        if (args[3] === '') { delete args[3]; }\n\t        if (args[4] === '') { delete args[4]; }\n\t        if (args[5] === '') { delete args[5]; }\n\t      }\n\t      var value = args[3] || args[4] || args[5] || '';\n\t      attrs[i] = {\n\t        name: args[1],\n\t        value: decodeAttr(\n\t          value,\n\t          options.shouldDecodeNewlines\n\t        )\n\t      };\n\t    }\n\t\n\t    if (!unary) {\n\t      stack.push({ tag: tagName, attrs: attrs });\n\t      lastTag = tagName;\n\t      unarySlash = '';\n\t    }\n\t\n\t    if (options.start) {\n\t      options.start(tagName, attrs, unary, match.start, match.end);\n\t    }\n\t  }\n\t\n\t  function parseEndTag (tag, tagName, start, end) {\n\t    var pos;\n\t    if (start == null) { start = index; }\n\t    if (end == null) { end = index; }\n\t\n\t    // Find the closest opened tag of the same type\n\t    if (tagName) {\n\t      var needle = tagName.toLowerCase();\n\t      for (pos = stack.length - 1; pos >= 0; pos--) {\n\t        if (stack[pos].tag.toLowerCase() === needle) {\n\t          break\n\t        }\n\t      }\n\t    } else {\n\t      // If no tag name is provided, clean shop\n\t      pos = 0;\n\t    }\n\t\n\t    if (pos >= 0) {\n\t      // Close all the open elements, up the stack\n\t      for (var i = stack.length - 1; i >= pos; i--) {\n\t        if (options.end) {\n\t          options.end(stack[i].tag, start, end);\n\t        }\n\t      }\n\t\n\t      // Remove the open elements from the stack\n\t      stack.length = pos;\n\t      lastTag = pos && stack[pos - 1].tag;\n\t    } else if (tagName.toLowerCase() === 'br') {\n\t      if (options.start) {\n\t        options.start(tagName, [], true, start, end);\n\t      }\n\t    } else if (tagName.toLowerCase() === 'p') {\n\t      if (options.start) {\n\t        options.start(tagName, [], false, start, end);\n\t      }\n\t      if (options.end) {\n\t        options.end(tagName, start, end);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction parseFilters (exp) {\n\t  var inSingle = false;\n\t  var inDouble = false;\n\t  var inTemplateString = false;\n\t  var inRegex = false;\n\t  var curly = 0;\n\t  var square = 0;\n\t  var paren = 0;\n\t  var lastFilterIndex = 0;\n\t  var c, prev, i, expression, filters;\n\t\n\t  for (i = 0; i < exp.length; i++) {\n\t    prev = c;\n\t    c = exp.charCodeAt(i);\n\t    if (inSingle) {\n\t      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n\t    } else if (inDouble) {\n\t      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n\t    } else if (inTemplateString) {\n\t      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n\t    } else if (inRegex) {\n\t      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n\t    } else if (\n\t      c === 0x7C && // pipe\n\t      exp.charCodeAt(i + 1) !== 0x7C &&\n\t      exp.charCodeAt(i - 1) !== 0x7C &&\n\t      !curly && !square && !paren\n\t    ) {\n\t      if (expression === undefined) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        expression = exp.slice(0, i).trim();\n\t      } else {\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22: inDouble = true; break         // \"\n\t        case 0x27: inSingle = true; break         // '\n\t        case 0x60: inTemplateString = true; break // `\n\t        case 0x28: paren++; break                 // (\n\t        case 0x29: paren--; break                 // )\n\t        case 0x5B: square++; break                // [\n\t        case 0x5D: square--; break                // ]\n\t        case 0x7B: curly++; break                 // {\n\t        case 0x7D: curly--; break                 // }\n\t      }\n\t      if (c === 0x2f) { // /\n\t        var j = i - 1;\n\t        var p = (void 0);\n\t        // find first non-whitespace prev char\n\t        for (; j >= 0; j--) {\n\t          p = exp.charAt(j);\n\t          if (p !== ' ') { break }\n\t        }\n\t        if (!p || !/[\\w$]/.test(p)) {\n\t          inRegex = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (expression === undefined) {\n\t    expression = exp.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  function pushFilter () {\n\t    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n\t    lastFilterIndex = i + 1;\n\t  }\n\t\n\t  if (filters) {\n\t    for (i = 0; i < filters.length; i++) {\n\t      expression = wrapFilter(expression, filters[i]);\n\t    }\n\t  }\n\t\n\t  return expression\n\t}\n\t\n\tfunction wrapFilter (exp, filter) {\n\t  var i = filter.indexOf('(');\n\t  if (i < 0) {\n\t    // _f: resolveFilter\n\t    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n\t  } else {\n\t    var name = filter.slice(0, i);\n\t    var args = filter.slice(i + 1);\n\t    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]/\\\\]/g;\n\t\n\tvar buildRegex = cached(function (delimiters) {\n\t  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n\t  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n\t  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n\t});\n\t\n\tfunction parseText (\n\t  text,\n\t  delimiters\n\t) {\n\t  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\t  if (!tagRE.test(text)) {\n\t    return\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index;\n\t  while ((match = tagRE.exec(text))) {\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n\t    }\n\t    // tag token\n\t    var exp = parseFilters(match[1].trim());\n\t    tokens.push((\"_s(\" + exp + \")\"));\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push(JSON.stringify(text.slice(lastIndex)));\n\t  }\n\t  return tokens.join('+')\n\t}\n\t\n\t/*  */\n\t\n\tfunction baseWarn (msg) {\n\t  console.error((\"[Vue parser]: \" + msg));\n\t}\n\t\n\tfunction pluckModuleFunction (\n\t  modules,\n\t  key\n\t) {\n\t  return modules\n\t    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n\t    : []\n\t}\n\t\n\tfunction addProp (el, name, value) {\n\t  (el.props || (el.props = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addAttr (el, name, value) {\n\t  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addDirective (\n\t  el,\n\t  name,\n\t  rawName,\n\t  value,\n\t  arg,\n\t  modifiers\n\t) {\n\t  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n\t}\n\t\n\tfunction addHandler (\n\t  el,\n\t  name,\n\t  value,\n\t  modifiers,\n\t  important\n\t) {\n\t  // check capture modifier\n\t  if (modifiers && modifiers.capture) {\n\t    delete modifiers.capture;\n\t    name = '!' + name; // mark the event as captured\n\t  }\n\t  if (modifiers && modifiers.once) {\n\t    delete modifiers.once;\n\t    name = '~' + name; // mark the event as once\n\t  }\n\t  var events;\n\t  if (modifiers && modifiers.native) {\n\t    delete modifiers.native;\n\t    events = el.nativeEvents || (el.nativeEvents = {});\n\t  } else {\n\t    events = el.events || (el.events = {});\n\t  }\n\t  var newHandler = { value: value, modifiers: modifiers };\n\t  var handlers = events[name];\n\t  /* istanbul ignore if */\n\t  if (Array.isArray(handlers)) {\n\t    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n\t  } else if (handlers) {\n\t    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n\t  } else {\n\t    events[name] = newHandler;\n\t  }\n\t}\n\t\n\tfunction getBindingAttr (\n\t  el,\n\t  name,\n\t  getStatic\n\t) {\n\t  var dynamicValue =\n\t    getAndRemoveAttr(el, ':' + name) ||\n\t    getAndRemoveAttr(el, 'v-bind:' + name);\n\t  if (dynamicValue != null) {\n\t    return parseFilters(dynamicValue)\n\t  } else if (getStatic !== false) {\n\t    var staticValue = getAndRemoveAttr(el, name);\n\t    if (staticValue != null) {\n\t      return JSON.stringify(staticValue)\n\t    }\n\t  }\n\t}\n\t\n\tfunction getAndRemoveAttr (el, name) {\n\t  var val;\n\t  if ((val = el.attrsMap[name]) != null) {\n\t    var list = el.attrsList;\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      if (list[i].name === name) {\n\t        list.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t  }\n\t  return val\n\t}\n\t\n\tvar len;\n\tvar str;\n\tvar chr;\n\tvar index$1;\n\tvar expressionPos;\n\tvar expressionEndPos;\n\t\n\t/**\n\t * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n\t *\n\t * for loop possible cases:\n\t *\n\t * - test\n\t * - test[idx]\n\t * - test[test1[idx]]\n\t * - test[\"a\"][idx]\n\t * - xxx.test[a[a].test1[idx]]\n\t * - test.xxx.a[\"asa\"][test1[idx]]\n\t *\n\t */\n\t\n\tfunction parseModel (val) {\n\t  str = val;\n\t  len = str.length;\n\t  index$1 = expressionPos = expressionEndPos = 0;\n\t\n\t  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n\t    return {\n\t      exp: val,\n\t      idx: null\n\t    }\n\t  }\n\t\n\t  while (!eof()) {\n\t    chr = next();\n\t    /* istanbul ignore if */\n\t    if (isStringStart(chr)) {\n\t      parseString(chr);\n\t    } else if (chr === 0x5B) {\n\t      parseBracket(chr);\n\t    }\n\t  }\n\t\n\t  return {\n\t    exp: val.substring(0, expressionPos),\n\t    idx: val.substring(expressionPos + 1, expressionEndPos)\n\t  }\n\t}\n\t\n\tfunction next () {\n\t  return str.charCodeAt(++index$1)\n\t}\n\t\n\tfunction eof () {\n\t  return index$1 >= len\n\t}\n\t\n\tfunction isStringStart (chr) {\n\t  return chr === 0x22 || chr === 0x27\n\t}\n\t\n\tfunction parseBracket (chr) {\n\t  var inBracket = 1;\n\t  expressionPos = index$1;\n\t  while (!eof()) {\n\t    chr = next();\n\t    if (isStringStart(chr)) {\n\t      parseString(chr);\n\t      continue\n\t    }\n\t    if (chr === 0x5B) { inBracket++; }\n\t    if (chr === 0x5D) { inBracket--; }\n\t    if (inBracket === 0) {\n\t      expressionEndPos = index$1;\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseString (chr) {\n\t  var stringQuote = chr;\n\t  while (!eof()) {\n\t    chr = next();\n\t    if (chr === stringQuote) {\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar dirRE = /^v-|^@|^:/;\n\tvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n\tvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\tvar bindRE = /^:|^v-bind:/;\n\tvar onRE = /^@|^v-on:/;\n\tvar argRE = /:(.*)$/;\n\tvar modifierRE = /\\.[^.]+/g;\n\t\n\tvar decodeHTMLCached = cached(decode);\n\t\n\t// configurable state\n\tvar warn$1;\n\tvar platformGetTagNamespace;\n\tvar platformMustUseProp;\n\tvar platformIsPreTag;\n\tvar preTransforms;\n\tvar transforms;\n\tvar postTransforms;\n\tvar delimiters;\n\t\n\t/**\n\t * Convert HTML string to AST.\n\t */\n\tfunction parse (\n\t  template,\n\t  options\n\t) {\n\t  warn$1 = options.warn || baseWarn;\n\t  platformGetTagNamespace = options.getTagNamespace || no;\n\t  platformMustUseProp = options.mustUseProp || no;\n\t  platformIsPreTag = options.isPreTag || no;\n\t  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n\t  transforms = pluckModuleFunction(options.modules, 'transformNode');\n\t  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\t  delimiters = options.delimiters;\n\t  var stack = [];\n\t  var preserveWhitespace = options.preserveWhitespace !== false;\n\t  var root;\n\t  var currentParent;\n\t  var inVPre = false;\n\t  var inPre = false;\n\t  var warned = false;\n\t  parseHTML(template, {\n\t    expectHTML: options.expectHTML,\n\t    isUnaryTag: options.isUnaryTag,\n\t    shouldDecodeNewlines: options.shouldDecodeNewlines,\n\t    start: function start (tag, attrs, unary) {\n\t      // check namespace.\n\t      // inherit parent ns if there is one\n\t      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\t\n\t      // handle IE svg bug\n\t      /* istanbul ignore if */\n\t      if (isIE && ns === 'svg') {\n\t        attrs = guardIESVGBug(attrs);\n\t      }\n\t\n\t      var element = {\n\t        type: 1,\n\t        tag: tag,\n\t        attrsList: attrs,\n\t        attrsMap: makeAttrsMap(attrs),\n\t        parent: currentParent,\n\t        children: []\n\t      };\n\t      if (ns) {\n\t        element.ns = ns;\n\t      }\n\t\n\t      if (isForbiddenTag(element) && !isServerRendering()) {\n\t        element.forbidden = true;\n\t        (\"production\") !== 'production' && warn$1(\n\t          'Templates should only be responsible for mapping the state to the ' +\n\t          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n\t          \"<\" + tag + \">\" + ', as they will not be parsed.'\n\t        );\n\t      }\n\t\n\t      // apply pre-transforms\n\t      for (var i = 0; i < preTransforms.length; i++) {\n\t        preTransforms[i](element, options);\n\t      }\n\t\n\t      if (!inVPre) {\n\t        processPre(element);\n\t        if (element.pre) {\n\t          inVPre = true;\n\t        }\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = true;\n\t      }\n\t      if (inVPre) {\n\t        processRawAttrs(element);\n\t      } else {\n\t        processFor(element);\n\t        processIf(element);\n\t        processOnce(element);\n\t        processKey(element);\n\t\n\t        // determine whether this is a plain element after\n\t        // removing structural attributes\n\t        element.plain = !element.key && !attrs.length;\n\t\n\t        processRef(element);\n\t        processSlot(element);\n\t        processComponent(element);\n\t        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n\t          transforms[i$1](element, options);\n\t        }\n\t        processAttrs(element);\n\t      }\n\t\n\t      function checkRootConstraints (el) {\n\t        if (false) {\n\t          if (el.tag === 'slot' || el.tag === 'template') {\n\t            warned = true;\n\t            warn$1(\n\t              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n\t              'contain multiple nodes:\\n' + template\n\t            );\n\t          }\n\t          if (el.attrsMap.hasOwnProperty('v-for')) {\n\t            warned = true;\n\t            warn$1(\n\t              'Cannot use v-for on stateful component root element because ' +\n\t              'it renders multiple elements:\\n' + template\n\t            );\n\t          }\n\t        }\n\t      }\n\t\n\t      // tree management\n\t      if (!root) {\n\t        root = element;\n\t        checkRootConstraints(root);\n\t      } else if (!stack.length) {\n\t        // allow root elements with v-if, v-else-if and v-else\n\t        if (root.if && (element.elseif || element.else)) {\n\t          checkRootConstraints(element);\n\t          addIfCondition(root, {\n\t            exp: element.elseif,\n\t            block: element\n\t          });\n\t        } else if (false) {\n\t          warned = true;\n\t          warn$1(\n\t            \"Component template should contain exactly one root element:\" +\n\t            \"\\n\\n\" + template + \"\\n\\n\" +\n\t            \"If you are using v-if on multiple elements, \" +\n\t            \"use v-else-if to chain them instead.\"\n\t          );\n\t        }\n\t      }\n\t      if (currentParent && !element.forbidden) {\n\t        if (element.elseif || element.else) {\n\t          processIfConditions(element, currentParent);\n\t        } else if (element.slotScope) { // scoped slot\n\t          currentParent.plain = false;\n\t          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n\t        } else {\n\t          currentParent.children.push(element);\n\t          element.parent = currentParent;\n\t        }\n\t      }\n\t      if (!unary) {\n\t        currentParent = element;\n\t        stack.push(element);\n\t      }\n\t      // apply post-transforms\n\t      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n\t        postTransforms[i$2](element, options);\n\t      }\n\t    },\n\t\n\t    end: function end () {\n\t      // remove trailing whitespace\n\t      var element = stack[stack.length - 1];\n\t      var lastNode = element.children[element.children.length - 1];\n\t      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n\t        element.children.pop();\n\t      }\n\t      // pop stack\n\t      stack.length -= 1;\n\t      currentParent = stack[stack.length - 1];\n\t      // check pre state\n\t      if (element.pre) {\n\t        inVPre = false;\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = false;\n\t      }\n\t    },\n\t\n\t    chars: function chars (text) {\n\t      if (!currentParent) {\n\t        if (false) {\n\t          warned = true;\n\t          warn$1(\n\t            'Component template requires a root element, rather than just text:\\n\\n' + template\n\t          );\n\t        }\n\t        return\n\t      }\n\t      // IE textarea placeholder bug\n\t      /* istanbul ignore if */\n\t      if (isIE &&\n\t          currentParent.tag === 'textarea' &&\n\t          currentParent.attrsMap.placeholder === text) {\n\t        return\n\t      }\n\t      var children = currentParent.children;\n\t      text = inPre || text.trim()\n\t        ? decodeHTMLCached(text)\n\t        // only preserve whitespace if its not right after a starting tag\n\t        : preserveWhitespace && children.length ? ' ' : '';\n\t      if (text) {\n\t        var expression;\n\t        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n\t          children.push({\n\t            type: 2,\n\t            expression: expression,\n\t            text: text\n\t          });\n\t        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n\t          currentParent.children.push({\n\t            type: 3,\n\t            text: text\n\t          });\n\t        }\n\t      }\n\t    }\n\t  });\n\t  return root\n\t}\n\t\n\tfunction processPre (el) {\n\t  if (getAndRemoveAttr(el, 'v-pre') != null) {\n\t    el.pre = true;\n\t  }\n\t}\n\t\n\tfunction processRawAttrs (el) {\n\t  var l = el.attrsList.length;\n\t  if (l) {\n\t    var attrs = el.attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      attrs[i] = {\n\t        name: el.attrsList[i].name,\n\t        value: JSON.stringify(el.attrsList[i].value)\n\t      };\n\t    }\n\t  } else if (!el.pre) {\n\t    // non root node in pre blocks with no attributes\n\t    el.plain = true;\n\t  }\n\t}\n\t\n\tfunction processKey (el) {\n\t  var exp = getBindingAttr(el, 'key');\n\t  if (exp) {\n\t    if (false) {\n\t      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n\t    }\n\t    el.key = exp;\n\t  }\n\t}\n\t\n\tfunction processRef (el) {\n\t  var ref = getBindingAttr(el, 'ref');\n\t  if (ref) {\n\t    el.ref = ref;\n\t    el.refInFor = checkInFor(el);\n\t  }\n\t}\n\t\n\tfunction processFor (el) {\n\t  var exp;\n\t  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n\t    var inMatch = exp.match(forAliasRE);\n\t    if (!inMatch) {\n\t      (\"production\") !== 'production' && warn$1(\n\t        (\"Invalid v-for expression: \" + exp)\n\t      );\n\t      return\n\t    }\n\t    el.for = inMatch[2].trim();\n\t    var alias = inMatch[1].trim();\n\t    var iteratorMatch = alias.match(forIteratorRE);\n\t    if (iteratorMatch) {\n\t      el.alias = iteratorMatch[1].trim();\n\t      el.iterator1 = iteratorMatch[2].trim();\n\t      if (iteratorMatch[3]) {\n\t        el.iterator2 = iteratorMatch[3].trim();\n\t      }\n\t    } else {\n\t      el.alias = alias;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processIf (el) {\n\t  var exp = getAndRemoveAttr(el, 'v-if');\n\t  if (exp) {\n\t    el.if = exp;\n\t    addIfCondition(el, {\n\t      exp: exp,\n\t      block: el\n\t    });\n\t  } else {\n\t    if (getAndRemoveAttr(el, 'v-else') != null) {\n\t      el.else = true;\n\t    }\n\t    var elseif = getAndRemoveAttr(el, 'v-else-if');\n\t    if (elseif) {\n\t      el.elseif = elseif;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processIfConditions (el, parent) {\n\t  var prev = findPrevElement(parent.children);\n\t  if (prev && prev.if) {\n\t    addIfCondition(prev, {\n\t      exp: el.elseif,\n\t      block: el\n\t    });\n\t  } else if (false) {\n\t    warn$1(\n\t      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n\t      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n\t    );\n\t  }\n\t}\n\t\n\tfunction findPrevElement (children) {\n\t  var i = children.length;\n\t  while (i--) {\n\t    if (children[i].type === 1) {\n\t      return children[i]\n\t    } else {\n\t      if (false) {\n\t        warn$1(\n\t          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n\t          \"will be ignored.\"\n\t        );\n\t      }\n\t      children.pop();\n\t    }\n\t  }\n\t}\n\t\n\tfunction addIfCondition (el, condition) {\n\t  if (!el.ifConditions) {\n\t    el.ifConditions = [];\n\t  }\n\t  el.ifConditions.push(condition);\n\t}\n\t\n\tfunction processOnce (el) {\n\t  var once = getAndRemoveAttr(el, 'v-once');\n\t  if (once != null) {\n\t    el.once = true;\n\t  }\n\t}\n\t\n\tfunction processSlot (el) {\n\t  if (el.tag === 'slot') {\n\t    el.slotName = getBindingAttr(el, 'name');\n\t    if (false) {\n\t      warn$1(\n\t        \"`key` does not work on <slot> because slots are abstract outlets \" +\n\t        \"and can possibly expand into multiple elements. \" +\n\t        \"Use the key on a wrapping element instead.\"\n\t      );\n\t    }\n\t  } else {\n\t    var slotTarget = getBindingAttr(el, 'slot');\n\t    if (slotTarget) {\n\t      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n\t    }\n\t    if (el.tag === 'template') {\n\t      el.slotScope = getAndRemoveAttr(el, 'scope');\n\t    }\n\t  }\n\t}\n\t\n\tfunction processComponent (el) {\n\t  var binding;\n\t  if ((binding = getBindingAttr(el, 'is'))) {\n\t    el.component = binding;\n\t  }\n\t  if (getAndRemoveAttr(el, 'inline-template') != null) {\n\t    el.inlineTemplate = true;\n\t  }\n\t}\n\t\n\tfunction processAttrs (el) {\n\t  var list = el.attrsList;\n\t  var i, l, name, rawName, value, arg, modifiers, isProp;\n\t  for (i = 0, l = list.length; i < l; i++) {\n\t    name = rawName = list[i].name;\n\t    value = list[i].value;\n\t    if (dirRE.test(name)) {\n\t      // mark element as dynamic\n\t      el.hasBindings = true;\n\t      // modifiers\n\t      modifiers = parseModifiers(name);\n\t      if (modifiers) {\n\t        name = name.replace(modifierRE, '');\n\t      }\n\t      if (bindRE.test(name)) { // v-bind\n\t        name = name.replace(bindRE, '');\n\t        value = parseFilters(value);\n\t        isProp = false;\n\t        if (modifiers) {\n\t          if (modifiers.prop) {\n\t            isProp = true;\n\t            name = camelize(name);\n\t            if (name === 'innerHtml') { name = 'innerHTML'; }\n\t          }\n\t          if (modifiers.camel) {\n\t            name = camelize(name);\n\t          }\n\t        }\n\t        if (isProp || platformMustUseProp(el.tag, name)) {\n\t          addProp(el, name, value);\n\t        } else {\n\t          addAttr(el, name, value);\n\t        }\n\t      } else if (onRE.test(name)) { // v-on\n\t        name = name.replace(onRE, '');\n\t        addHandler(el, name, value, modifiers);\n\t      } else { // normal directives\n\t        name = name.replace(dirRE, '');\n\t        // parse arg\n\t        var argMatch = name.match(argRE);\n\t        if (argMatch && (arg = argMatch[1])) {\n\t          name = name.slice(0, -(arg.length + 1));\n\t        }\n\t        addDirective(el, name, rawName, value, arg, modifiers);\n\t        if (false) {\n\t          checkForAliasModel(el, value);\n\t        }\n\t      }\n\t    } else {\n\t      // literal attribute\n\t      if (false) {\n\t        var expression = parseText(value, delimiters);\n\t        if (expression) {\n\t          warn$1(\n\t            name + \"=\\\"\" + value + \"\\\": \" +\n\t            'Interpolation inside attributes has been removed. ' +\n\t            'Use v-bind or the colon shorthand instead. For example, ' +\n\t            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n\t          );\n\t        }\n\t      }\n\t      addAttr(el, name, JSON.stringify(value));\n\t      // #4530 also bind special attributes as props even if they are static\n\t      // so that patches between dynamic/static are consistent\n\t      if (platformMustUseProp(el.tag, name)) {\n\t        if (name === 'value') {\n\t          addProp(el, name, JSON.stringify(value));\n\t        } else {\n\t          addProp(el, name, 'true');\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkInFor (el) {\n\t  var parent = el;\n\t  while (parent) {\n\t    if (parent.for !== undefined) {\n\t      return true\n\t    }\n\t    parent = parent.parent;\n\t  }\n\t  return false\n\t}\n\t\n\tfunction parseModifiers (name) {\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var ret = {};\n\t    match.forEach(function (m) { ret[m.slice(1)] = true; });\n\t    return ret\n\t  }\n\t}\n\t\n\tfunction makeAttrsMap (attrs) {\n\t  var map = {};\n\t  for (var i = 0, l = attrs.length; i < l; i++) {\n\t    if (false) {\n\t      warn$1('duplicate attribute: ' + attrs[i].name);\n\t    }\n\t    map[attrs[i].name] = attrs[i].value;\n\t  }\n\t  return map\n\t}\n\t\n\tfunction isForbiddenTag (el) {\n\t  return (\n\t    el.tag === 'style' ||\n\t    (el.tag === 'script' && (\n\t      !el.attrsMap.type ||\n\t      el.attrsMap.type === 'text/javascript'\n\t    ))\n\t  )\n\t}\n\t\n\tvar ieNSBug = /^xmlns:NS\\d+/;\n\tvar ieNSPrefix = /^NS\\d+:/;\n\t\n\t/* istanbul ignore next */\n\tfunction guardIESVGBug (attrs) {\n\t  var res = [];\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    if (!ieNSBug.test(attr.name)) {\n\t      attr.name = attr.name.replace(ieNSPrefix, '');\n\t      res.push(attr);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkForAliasModel (el, value) {\n\t  var _el = el;\n\t  while (_el) {\n\t    if (_el.for && _el.alias === value) {\n\t      warn$1(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n\t        \"You are binding v-model directly to a v-for iteration alias. \" +\n\t        \"This will not be able to modify the v-for source array because \" +\n\t        \"writing to the alias is like modifying a function local variable. \" +\n\t        \"Consider using an array of objects and use v-model on an object property instead.\"\n\t      );\n\t    }\n\t    _el = _el.parent;\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar isStaticKey;\n\tvar isPlatformReservedTag;\n\t\n\tvar genStaticKeysCached = cached(genStaticKeys$1);\n\t\n\t/**\n\t * Goal of the optimizer: walk the generated template AST tree\n\t * and detect sub-trees that are purely static, i.e. parts of\n\t * the DOM that never needs to change.\n\t *\n\t * Once we detect these sub-trees, we can:\n\t *\n\t * 1. Hoist them into constants, so that we no longer need to\n\t *    create fresh nodes for them on each re-render;\n\t * 2. Completely skip them in the patching process.\n\t */\n\tfunction optimize (root, options) {\n\t  if (!root) { return }\n\t  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n\t  isPlatformReservedTag = options.isReservedTag || no;\n\t  // first pass: mark all non-static nodes.\n\t  markStatic(root);\n\t  // second pass: mark static roots.\n\t  markStaticRoots(root, false);\n\t}\n\t\n\tfunction genStaticKeys$1 (keys) {\n\t  return makeMap(\n\t    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n\t    (keys ? ',' + keys : '')\n\t  )\n\t}\n\t\n\tfunction markStatic (node) {\n\t  node.static = isStatic(node);\n\t  if (node.type === 1) {\n\t    // do not make component slot content static. this avoids\n\t    // 1. components not able to mutate slot nodes\n\t    // 2. static slot content fails for hot-reloading\n\t    if (\n\t      !isPlatformReservedTag(node.tag) &&\n\t      node.tag !== 'slot' &&\n\t      node.attrsMap['inline-template'] == null\n\t    ) {\n\t      return\n\t    }\n\t    for (var i = 0, l = node.children.length; i < l; i++) {\n\t      var child = node.children[i];\n\t      markStatic(child);\n\t      if (!child.static) {\n\t        node.static = false;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction markStaticRoots (node, isInFor) {\n\t  if (node.type === 1) {\n\t    if (node.static || node.once) {\n\t      node.staticInFor = isInFor;\n\t    }\n\t    // For a node to qualify as a static root, it should have children that\n\t    // are not just static text. Otherwise the cost of hoisting out will\n\t    // outweigh the benefits and it's better off to just always render it fresh.\n\t    if (node.static && node.children.length && !(\n\t      node.children.length === 1 &&\n\t      node.children[0].type === 3\n\t    )) {\n\t      node.staticRoot = true;\n\t      return\n\t    } else {\n\t      node.staticRoot = false;\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0, l = node.children.length; i < l; i++) {\n\t        markStaticRoots(node.children[i], isInFor || !!node.for);\n\t      }\n\t    }\n\t    if (node.ifConditions) {\n\t      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n\t    }\n\t  }\n\t}\n\t\n\tfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n\t  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n\t    markStaticRoots(conditionBlocks[i].block, isInFor);\n\t  }\n\t}\n\t\n\tfunction isStatic (node) {\n\t  if (node.type === 2) { // expression\n\t    return false\n\t  }\n\t  if (node.type === 3) { // text\n\t    return true\n\t  }\n\t  return !!(node.pre || (\n\t    !node.hasBindings && // no dynamic bindings\n\t    !node.if && !node.for && // not v-if or v-for or v-else\n\t    !isBuiltInTag(node.tag) && // not a built-in\n\t    isPlatformReservedTag(node.tag) && // not a component\n\t    !isDirectChildOfTemplateFor(node) &&\n\t    Object.keys(node).every(isStaticKey)\n\t  ))\n\t}\n\t\n\tfunction isDirectChildOfTemplateFor (node) {\n\t  while (node.parent) {\n\t    node = node.parent;\n\t    if (node.tag !== 'template') {\n\t      return false\n\t    }\n\t    if (node.for) {\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\t/*  */\n\t\n\tvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n\tvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40,\n\t  'delete': [8, 46]\n\t};\n\t\n\tvar modifierCode = {\n\t  stop: '$event.stopPropagation();',\n\t  prevent: '$event.preventDefault();',\n\t  self: 'if($event.target !== $event.currentTarget)return;',\n\t  ctrl: 'if(!$event.ctrlKey)return;',\n\t  shift: 'if(!$event.shiftKey)return;',\n\t  alt: 'if(!$event.altKey)return;',\n\t  meta: 'if(!$event.metaKey)return;'\n\t};\n\t\n\tfunction genHandlers (events, native) {\n\t  var res = native ? 'nativeOn:{' : 'on:{';\n\t  for (var name in events) {\n\t    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n\t  }\n\t  return res.slice(0, -1) + '}'\n\t}\n\t\n\tfunction genHandler (\n\t  name,\n\t  handler\n\t) {\n\t  if (!handler) {\n\t    return 'function(){}'\n\t  } else if (Array.isArray(handler)) {\n\t    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n\t  } else if (!handler.modifiers) {\n\t    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n\t      ? handler.value\n\t      : (\"function($event){\" + (handler.value) + \"}\")\n\t  } else {\n\t    var code = '';\n\t    var keys = [];\n\t    for (var key in handler.modifiers) {\n\t      if (modifierCode[key]) {\n\t        code += modifierCode[key];\n\t      } else {\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (keys.length) {\n\t      code = genKeyFilter(keys) + code;\n\t    }\n\t    var handlerCode = simplePathRE.test(handler.value)\n\t      ? handler.value + '($event)'\n\t      : handler.value;\n\t    return 'function($event){' + code + handlerCode + '}'\n\t  }\n\t}\n\t\n\tfunction genKeyFilter (keys) {\n\t  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n\t}\n\t\n\tfunction genFilterCode (key) {\n\t  var keyVal = parseInt(key, 10);\n\t  if (keyVal) {\n\t    return (\"$event.keyCode!==\" + keyVal)\n\t  }\n\t  var alias = keyCodes[key];\n\t  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n\t}\n\t\n\t/*  */\n\t\n\tfunction bind$2 (el, dir) {\n\t  el.wrapData = function (code) {\n\t    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar baseDirectives = {\n\t  bind: bind$2,\n\t  cloak: noop\n\t};\n\t\n\t/*  */\n\t\n\t// configurable state\n\tvar warn$2;\n\tvar transforms$1;\n\tvar dataGenFns;\n\tvar platformDirectives$1;\n\tvar isPlatformReservedTag$1;\n\tvar staticRenderFns;\n\tvar onceCount;\n\tvar currentOptions;\n\t\n\tfunction generate (\n\t  ast,\n\t  options\n\t) {\n\t  // save previous staticRenderFns so generate calls can be nested\n\t  var prevStaticRenderFns = staticRenderFns;\n\t  var currentStaticRenderFns = staticRenderFns = [];\n\t  var prevOnceCount = onceCount;\n\t  onceCount = 0;\n\t  currentOptions = options;\n\t  warn$2 = options.warn || baseWarn;\n\t  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n\t  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n\t  platformDirectives$1 = options.directives || {};\n\t  isPlatformReservedTag$1 = options.isReservedTag || no;\n\t  var code = ast ? genElement(ast) : '_c(\"div\")';\n\t  staticRenderFns = prevStaticRenderFns;\n\t  onceCount = prevOnceCount;\n\t  return {\n\t    render: (\"with(this){return \" + code + \"}\"),\n\t    staticRenderFns: currentStaticRenderFns\n\t  }\n\t}\n\t\n\tfunction genElement (el) {\n\t  if (el.staticRoot && !el.staticProcessed) {\n\t    return genStatic(el)\n\t  } else if (el.once && !el.onceProcessed) {\n\t    return genOnce(el)\n\t  } else if (el.for && !el.forProcessed) {\n\t    return genFor(el)\n\t  } else if (el.if && !el.ifProcessed) {\n\t    return genIf(el)\n\t  } else if (el.tag === 'template' && !el.slotTarget) {\n\t    return genChildren(el) || 'void 0'\n\t  } else if (el.tag === 'slot') {\n\t    return genSlot(el)\n\t  } else {\n\t    // component or element\n\t    var code;\n\t    if (el.component) {\n\t      code = genComponent(el.component, el);\n\t    } else {\n\t      var data = el.plain ? undefined : genData(el);\n\t\n\t      var children = el.inlineTemplate ? null : genChildren(el, true);\n\t      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n\t    }\n\t    // module transforms\n\t    for (var i = 0; i < transforms$1.length; i++) {\n\t      code = transforms$1[i](el, code);\n\t    }\n\t    return code\n\t  }\n\t}\n\t\n\t// hoist static sub-trees out\n\tfunction genStatic (el) {\n\t  el.staticProcessed = true;\n\t  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n\t  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n\t}\n\t\n\t// v-once\n\tfunction genOnce (el) {\n\t  el.onceProcessed = true;\n\t  if (el.if && !el.ifProcessed) {\n\t    return genIf(el)\n\t  } else if (el.staticInFor) {\n\t    var key = '';\n\t    var parent = el.parent;\n\t    while (parent) {\n\t      if (parent.for) {\n\t        key = parent.key;\n\t        break\n\t      }\n\t      parent = parent.parent;\n\t    }\n\t    if (!key) {\n\t      (\"production\") !== 'production' && warn$2(\n\t        \"v-once can only be used inside v-for that is keyed. \"\n\t      );\n\t      return genElement(el)\n\t    }\n\t    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n\t  } else {\n\t    return genStatic(el)\n\t  }\n\t}\n\t\n\tfunction genIf (el) {\n\t  el.ifProcessed = true; // avoid recursion\n\t  return genIfConditions(el.ifConditions.slice())\n\t}\n\t\n\tfunction genIfConditions (conditions) {\n\t  if (!conditions.length) {\n\t    return '_e()'\n\t  }\n\t\n\t  var condition = conditions.shift();\n\t  if (condition.exp) {\n\t    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n\t  } else {\n\t    return (\"\" + (genTernaryExp(condition.block)))\n\t  }\n\t\n\t  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\t  function genTernaryExp (el) {\n\t    return el.once ? genOnce(el) : genElement(el)\n\t  }\n\t}\n\t\n\tfunction genFor (el) {\n\t  var exp = el.for;\n\t  var alias = el.alias;\n\t  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n\t  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\t  el.forProcessed = true; // avoid recursion\n\t  return \"_l((\" + exp + \"),\" +\n\t    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n\t      \"return \" + (genElement(el)) +\n\t    '})'\n\t}\n\t\n\tfunction genData (el) {\n\t  var data = '{';\n\t\n\t  // directives first.\n\t  // directives may mutate the el's other properties before they are generated.\n\t  var dirs = genDirectives(el);\n\t  if (dirs) { data += dirs + ','; }\n\t\n\t  // key\n\t  if (el.key) {\n\t    data += \"key:\" + (el.key) + \",\";\n\t  }\n\t  // ref\n\t  if (el.ref) {\n\t    data += \"ref:\" + (el.ref) + \",\";\n\t  }\n\t  if (el.refInFor) {\n\t    data += \"refInFor:true,\";\n\t  }\n\t  // pre\n\t  if (el.pre) {\n\t    data += \"pre:true,\";\n\t  }\n\t  // record original tag name for components using \"is\" attribute\n\t  if (el.component) {\n\t    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n\t  }\n\t  // module data generation functions\n\t  for (var i = 0; i < dataGenFns.length; i++) {\n\t    data += dataGenFns[i](el);\n\t  }\n\t  // attributes\n\t  if (el.attrs) {\n\t    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n\t  }\n\t  // DOM props\n\t  if (el.props) {\n\t    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n\t  }\n\t  // event handlers\n\t  if (el.events) {\n\t    data += (genHandlers(el.events)) + \",\";\n\t  }\n\t  if (el.nativeEvents) {\n\t    data += (genHandlers(el.nativeEvents, true)) + \",\";\n\t  }\n\t  // slot target\n\t  if (el.slotTarget) {\n\t    data += \"slot:\" + (el.slotTarget) + \",\";\n\t  }\n\t  // scoped slots\n\t  if (el.scopedSlots) {\n\t    data += (genScopedSlots(el.scopedSlots)) + \",\";\n\t  }\n\t  // inline-template\n\t  if (el.inlineTemplate) {\n\t    var inlineTemplate = genInlineTemplate(el);\n\t    if (inlineTemplate) {\n\t      data += inlineTemplate + \",\";\n\t    }\n\t  }\n\t  data = data.replace(/,$/, '') + '}';\n\t  // v-bind data wrap\n\t  if (el.wrapData) {\n\t    data = el.wrapData(data);\n\t  }\n\t  return data\n\t}\n\t\n\tfunction genDirectives (el) {\n\t  var dirs = el.directives;\n\t  if (!dirs) { return }\n\t  var res = 'directives:[';\n\t  var hasRuntime = false;\n\t  var i, l, dir, needRuntime;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    dir = dirs[i];\n\t    needRuntime = true;\n\t    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n\t    if (gen) {\n\t      // compile-time directive that manipulates AST.\n\t      // returns true if it also needs a runtime counterpart.\n\t      needRuntime = !!gen(el, dir, warn$2);\n\t    }\n\t    if (needRuntime) {\n\t      hasRuntime = true;\n\t      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n\t    }\n\t  }\n\t  if (hasRuntime) {\n\t    return res.slice(0, -1) + ']'\n\t  }\n\t}\n\t\n\tfunction genInlineTemplate (el) {\n\t  var ast = el.children[0];\n\t  if (false) {\n\t    warn$2('Inline-template components must have exactly one child element.');\n\t  }\n\t  if (ast.type === 1) {\n\t    var inlineRenderFns = generate(ast, currentOptions);\n\t    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n\t  }\n\t}\n\t\n\tfunction genScopedSlots (slots) {\n\t  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n\t}\n\t\n\tfunction genScopedSlot (key, el) {\n\t  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n\t    \"return \" + (el.tag === 'template'\n\t      ? genChildren(el) || 'void 0'\n\t      : genElement(el)) + \"}\"\n\t}\n\t\n\tfunction genChildren (el, checkSkip) {\n\t  var children = el.children;\n\t  if (children.length) {\n\t    var el$1 = children[0];\n\t    // optimize single v-for\n\t    if (children.length === 1 &&\n\t        el$1.for &&\n\t        el$1.tag !== 'template' &&\n\t        el$1.tag !== 'slot') {\n\t      return genElement(el$1)\n\t    }\n\t    var normalizationType = getNormalizationType(children);\n\t    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n\t        ? normalizationType ? (\",\" + normalizationType) : ''\n\t        : ''))\n\t  }\n\t}\n\t\n\t// determine the normalization needed for the children array.\n\t// 0: no normalization needed\n\t// 1: simple normalization needed (possible 1-level deep nested array)\n\t// 2: full normalization needed\n\tfunction getNormalizationType (children) {\n\t  var res = 0;\n\t  for (var i = 0; i < children.length; i++) {\n\t    var el = children[i];\n\t    if (needsNormalization(el) ||\n\t        (el.if && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n\t      res = 2;\n\t      break\n\t    }\n\t    if (maybeComponent(el) ||\n\t        (el.if && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n\t      res = 1;\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction needsNormalization (el) {\n\t  return el.for || el.tag === 'template' || el.tag === 'slot'\n\t}\n\t\n\tfunction maybeComponent (el) {\n\t  return el.type === 1 && !isPlatformReservedTag$1(el.tag)\n\t}\n\t\n\tfunction genNode (node) {\n\t  if (node.type === 1) {\n\t    return genElement(node)\n\t  } else {\n\t    return genText(node)\n\t  }\n\t}\n\t\n\tfunction genText (text) {\n\t  return (\"_v(\" + (text.type === 2\n\t    ? text.expression // no need for () because already wrapped in _s()\n\t    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n\t}\n\t\n\tfunction genSlot (el) {\n\t  var slotName = el.slotName || '\"default\"';\n\t  var children = genChildren(el);\n\t  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n\t  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n\t  var bind$$1 = el.attrsMap['v-bind'];\n\t  if ((attrs || bind$$1) && !children) {\n\t    res += \",null\";\n\t  }\n\t  if (attrs) {\n\t    res += \",\" + attrs;\n\t  }\n\t  if (bind$$1) {\n\t    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n\t  }\n\t  return res + ')'\n\t}\n\t\n\t// componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\tfunction genComponent (componentName, el) {\n\t  var children = el.inlineTemplate ? null : genChildren(el, true);\n\t  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n\t}\n\t\n\tfunction genProps (props) {\n\t  var res = '';\n\t  for (var i = 0; i < props.length; i++) {\n\t    var prop = props[i];\n\t    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n\t  }\n\t  return res.slice(0, -1)\n\t}\n\t\n\t// #3895, #4268\n\tfunction transformSpecialNewlines (text) {\n\t  return text\n\t    .replace(/\\u2028/g, '\\\\u2028')\n\t    .replace(/\\u2029/g, '\\\\u2029')\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Compile a template.\n\t */\n\tfunction compile$1 (\n\t  template,\n\t  options\n\t) {\n\t  var ast = parse(template.trim(), options);\n\t  optimize(ast, options);\n\t  var code = generate(ast, options);\n\t  return {\n\t    ast: ast,\n\t    render: code.render,\n\t    staticRenderFns: code.staticRenderFns\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// operators like typeof, instanceof and in are allowed\n\tvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n\t  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n\t  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n\t  'extends,finally,continue,debugger,function,arguments'\n\t).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\t// check valid identifier for v-for\n\tvar identRE = /[A-Za-z_$][\\w$]*/;\n\t// strip strings in expressions\n\tvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\t\n\t// detect problematic expressions in a template\n\tfunction detectErrors (ast) {\n\t  var errors = [];\n\t  if (ast) {\n\t    checkNode(ast, errors);\n\t  }\n\t  return errors\n\t}\n\t\n\tfunction checkNode (node, errors) {\n\t  if (node.type === 1) {\n\t    for (var name in node.attrsMap) {\n\t      if (dirRE.test(name)) {\n\t        var value = node.attrsMap[name];\n\t        if (value) {\n\t          if (name === 'v-for') {\n\t            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n\t          } else {\n\t            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0; i < node.children.length; i++) {\n\t        checkNode(node.children[i], errors);\n\t      }\n\t    }\n\t  } else if (node.type === 2) {\n\t    checkExpression(node.expression, node.text, errors);\n\t  }\n\t}\n\t\n\tfunction checkFor (node, text, errors) {\n\t  checkExpression(node.for || '', text, errors);\n\t  checkIdentifier(node.alias, 'v-for alias', text, errors);\n\t  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n\t  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n\t}\n\t\n\tfunction checkIdentifier (ident, type, text, errors) {\n\t  if (typeof ident === 'string' && !identRE.test(ident)) {\n\t    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n\t  }\n\t}\n\t\n\tfunction checkExpression (exp, text, errors) {\n\t  try {\n\t    new Function((\"return \" + exp));\n\t  } catch (e) {\n\t    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\t    if (keywordMatch) {\n\t      errors.push(\n\t        \"- avoid using JavaScript keyword as property name: \" +\n\t        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n\t      );\n\t    } else {\n\t      errors.push((\"- invalid expression: \" + text));\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction transformNode (el, options) {\n\t  var warn = options.warn || baseWarn;\n\t  var staticClass = getAndRemoveAttr(el, 'class');\n\t  if (false) {\n\t    var expression = parseText(staticClass, options.delimiters);\n\t    if (expression) {\n\t      warn(\n\t        \"class=\\\"\" + staticClass + \"\\\": \" +\n\t        'Interpolation inside attributes has been removed. ' +\n\t        'Use v-bind or the colon shorthand instead. For example, ' +\n\t        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n\t      );\n\t    }\n\t  }\n\t  if (staticClass) {\n\t    el.staticClass = JSON.stringify(staticClass);\n\t  }\n\t  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n\t  if (classBinding) {\n\t    el.classBinding = classBinding;\n\t  }\n\t}\n\t\n\tfunction genData$1 (el) {\n\t  var data = '';\n\t  if (el.staticClass) {\n\t    data += \"staticClass:\" + (el.staticClass) + \",\";\n\t  }\n\t  if (el.classBinding) {\n\t    data += \"class:\" + (el.classBinding) + \",\";\n\t  }\n\t  return data\n\t}\n\t\n\tvar klass$1 = {\n\t  staticKeys: ['staticClass'],\n\t  transformNode: transformNode,\n\t  genData: genData$1\n\t};\n\t\n\t/*  */\n\t\n\tfunction transformNode$1 (el, options) {\n\t  var warn = options.warn || baseWarn;\n\t  var staticStyle = getAndRemoveAttr(el, 'style');\n\t  if (staticStyle) {\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      var expression = parseText(staticStyle, options.delimiters);\n\t      if (expression) {\n\t        warn(\n\t          \"style=\\\"\" + staticStyle + \"\\\": \" +\n\t          'Interpolation inside attributes has been removed. ' +\n\t          'Use v-bind or the colon shorthand instead. For example, ' +\n\t          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n\t        );\n\t      }\n\t    }\n\t    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n\t  }\n\t\n\t  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n\t  if (styleBinding) {\n\t    el.styleBinding = styleBinding;\n\t  }\n\t}\n\t\n\tfunction genData$2 (el) {\n\t  var data = '';\n\t  if (el.staticStyle) {\n\t    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n\t  }\n\t  if (el.styleBinding) {\n\t    data += \"style:(\" + (el.styleBinding) + \"),\";\n\t  }\n\t  return data\n\t}\n\t\n\tvar style$1 = {\n\t  staticKeys: ['staticStyle'],\n\t  transformNode: transformNode$1,\n\t  genData: genData$2\n\t};\n\t\n\tvar modules$1 = [\n\t  klass$1,\n\t  style$1\n\t];\n\t\n\t/*  */\n\t\n\tvar warn$3;\n\t\n\tfunction model$1 (\n\t  el,\n\t  dir,\n\t  _warn\n\t) {\n\t  warn$3 = _warn;\n\t  var value = dir.value;\n\t  var modifiers = dir.modifiers;\n\t  var tag = el.tag;\n\t  var type = el.attrsMap.type;\n\t  if (false) {\n\t    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\t    if (tag === 'input' && dynamicType) {\n\t      warn$3(\n\t        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n\t      );\n\t    }\n\t  }\n\t  if (tag === 'select') {\n\t    genSelect(el, value, modifiers);\n\t  } else if (tag === 'input' && type === 'checkbox') {\n\t    genCheckboxModel(el, value, modifiers);\n\t  } else if (tag === 'input' && type === 'radio') {\n\t    genRadioModel(el, value, modifiers);\n\t  } else {\n\t    genDefaultModel(el, value, modifiers);\n\t  }\n\t  // ensure runtime directive metadata\n\t  return true\n\t}\n\t\n\tfunction genCheckboxModel (\n\t  el,\n\t  value,\n\t  modifiers\n\t) {\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var number = modifiers && modifiers.number;\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n\t  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n\t  addProp(el, 'checked',\n\t    \"Array.isArray(\" + value + \")\" +\n\t      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n\t        trueValueBinding === 'true'\n\t          ? (\":(\" + value + \")\")\n\t          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n\t      )\n\t  );\n\t  addHandler(el, 'change',\n\t    \"var $$a=\" + value + \",\" +\n\t        '$$el=$event.target,' +\n\t        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n\t    'if(Array.isArray($$a)){' +\n\t      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n\t          '$$i=_i($$a,$$v);' +\n\t      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n\t      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n\t    \"}else{\" + value + \"=$$c}\",\n\t    null, true\n\t  );\n\t}\n\t\n\tfunction genRadioModel (\n\t    el,\n\t    value,\n\t    modifiers\n\t) {\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var number = modifiers && modifiers.number;\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n\t  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n\t  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n\t}\n\t\n\tfunction genDefaultModel (\n\t  el,\n\t  value,\n\t  modifiers\n\t) {\n\t  if (false) {\n\t    if (el.tag === 'input' && el.attrsMap.value) {\n\t      warn$3(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n\t        'inline value attributes will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t    if (el.tag === 'textarea' && el.children.length) {\n\t      warn$3(\n\t        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        'inline content inside <textarea> will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t  }\n\t\n\t  var type = el.attrsMap.type;\n\t  var ref = modifiers || {};\n\t  var lazy = ref.lazy;\n\t  var number = ref.number;\n\t  var trim = ref.trim;\n\t  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n\t  var needCompositionGuard = !lazy && type !== 'range';\n\t  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\t\n\t  var valueExpression = isNative\n\t    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n\t    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n\t  valueExpression = number || type === 'number'\n\t    ? (\"_n(\" + valueExpression + \")\")\n\t    : valueExpression;\n\t\n\t  var code = genAssignmentCode(value, valueExpression);\n\t  if (isNative && needCompositionGuard) {\n\t    code = \"if($event.target.composing)return;\" + code;\n\t  }\n\t\n\t  // inputs with type=\"file\" are read only and setting the input's\n\t  // value will throw an error.\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n\t      \"File inputs are read only. Use a v-on:change listener instead.\"\n\t    );\n\t  }\n\t\n\t  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n\t  addHandler(el, event, code, null, true);\n\t  if (trim || number || type === 'number') {\n\t    addHandler(el, 'blur', '$forceUpdate()');\n\t  }\n\t}\n\t\n\tfunction genSelect (\n\t    el,\n\t    value,\n\t    modifiers\n\t) {\n\t  if (false) {\n\t    el.children.some(checkOptionWarning);\n\t  }\n\t\n\t  var number = modifiers && modifiers.number;\n\t  var assignment = \"Array.prototype.filter\" +\n\t    \".call($event.target.options,function(o){return o.selected})\" +\n\t    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n\t    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n\t    (el.attrsMap.multiple == null ? '[0]' : '');\n\t\n\t  var code = genAssignmentCode(value, assignment);\n\t  addHandler(el, 'change', code, null, true);\n\t}\n\t\n\tfunction checkOptionWarning (option) {\n\t  if (option.type === 1 &&\n\t    option.tag === 'option' &&\n\t    option.attrsMap.selected != null) {\n\t    warn$3(\n\t      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n\t      'inline selected attributes on <option> will be ignored when using v-model. ' +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tfunction genAssignmentCode (value, assignment) {\n\t  var modelRs = parseModel(value);\n\t  if (modelRs.idx === null) {\n\t    return (value + \"=\" + assignment)\n\t  } else {\n\t    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n\t      \"if (!Array.isArray($$exp)){\" +\n\t        value + \"=\" + assignment + \"}\" +\n\t      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction text (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction html (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\tvar directives$1 = {\n\t  model: model$1,\n\t  text: text,\n\t  html: html\n\t};\n\t\n\t/*  */\n\t\n\tvar cache = Object.create(null);\n\t\n\tvar baseOptions = {\n\t  expectHTML: true,\n\t  modules: modules$1,\n\t  staticKeys: genStaticKeys(modules$1),\n\t  directives: directives$1,\n\t  isReservedTag: isReservedTag,\n\t  isUnaryTag: isUnaryTag,\n\t  mustUseProp: mustUseProp,\n\t  getTagNamespace: getTagNamespace,\n\t  isPreTag: isPreTag\n\t};\n\t\n\tfunction compile$$1 (\n\t  template,\n\t  options\n\t) {\n\t  options = options\n\t    ? extend(extend({}, baseOptions), options)\n\t    : baseOptions;\n\t  return compile$1(template, options)\n\t}\n\t\n\tfunction compileToFunctions (\n\t  template,\n\t  options,\n\t  vm\n\t) {\n\t  var _warn = (options && options.warn) || warn;\n\t  // detect possible CSP restriction\n\t  /* istanbul ignore if */\n\t  if (false) {\n\t    try {\n\t      new Function('return 1');\n\t    } catch (e) {\n\t      if (e.toString().match(/unsafe-eval|CSP/)) {\n\t        _warn(\n\t          'It seems you are using the standalone build of Vue.js in an ' +\n\t          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n\t          'The template compiler cannot work in this environment. Consider ' +\n\t          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n\t          'templates into render functions.'\n\t        );\n\t      }\n\t    }\n\t  }\n\t  var key = options && options.delimiters\n\t    ? String(options.delimiters) + template\n\t    : template;\n\t  if (cache[key]) {\n\t    return cache[key]\n\t  }\n\t  var res = {};\n\t  var compiled = compile$$1(template, options);\n\t  res.render = makeFunction(compiled.render);\n\t  var l = compiled.staticRenderFns.length;\n\t  res.staticRenderFns = new Array(l);\n\t  for (var i = 0; i < l; i++) {\n\t    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n\t  }\n\t  if (false) {\n\t    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n\t      _warn(\n\t        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n\t        detectErrors(compiled.ast).join('\\n') +\n\t        '\\n\\n',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  return (cache[key] = res)\n\t}\n\t\n\tfunction makeFunction (code) {\n\t  try {\n\t    return new Function(code)\n\t  } catch (e) {\n\t    return noop\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar idToTemplate = cached(function (id) {\n\t  var el = query(id);\n\t  return el && el.innerHTML\n\t});\n\t\n\tvar mount = Vue$3.prototype.$mount;\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && query(el);\n\t\n\t  /* istanbul ignore if */\n\t  if (el === document.body || el === document.documentElement) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n\t    );\n\t    return this\n\t  }\n\t\n\t  var options = this.$options;\n\t  // resolve template/el and convert to render function\n\t  if (!options.render) {\n\t    var template = options.template;\n\t    if (template) {\n\t      if (typeof template === 'string') {\n\t        if (template.charAt(0) === '#') {\n\t          template = idToTemplate(template);\n\t          /* istanbul ignore if */\n\t          if (false) {\n\t            warn(\n\t              (\"Template element not found or is empty: \" + (options.template)),\n\t              this\n\t            );\n\t          }\n\t        }\n\t      } else if (template.nodeType) {\n\t        template = template.innerHTML;\n\t      } else {\n\t        if (false) {\n\t          warn('invalid template option:' + template, this);\n\t        }\n\t        return this\n\t      }\n\t    } else if (el) {\n\t      template = getOuterHTML(el);\n\t    }\n\t    if (template) {\n\t      var ref = compileToFunctions(template, {\n\t        warn: warn,\n\t        shouldDecodeNewlines: shouldDecodeNewlines,\n\t        delimiters: options.delimiters\n\t      }, this);\n\t      var render = ref.render;\n\t      var staticRenderFns = ref.staticRenderFns;\n\t      options.render = render;\n\t      options.staticRenderFns = staticRenderFns;\n\t    }\n\t  }\n\t  return mount.call(this, el, hydrating)\n\t};\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t */\n\tfunction getOuterHTML (el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\tVue$3.compile = compileToFunctions;\n\t\n\tmodule.exports = Vue$3;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(8)\n\t  , core      = __webpack_require__(7)\n\t  , ctx       = __webpack_require__(37)\n\t  , hide      = __webpack_require__(12)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(43)('keys')\n\t  , uid    = __webpack_require__(46);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(20);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RopeSequence = __webpack_require__(162)\n\tvar ref = __webpack_require__(4);\n\tvar Mapping = ref.Mapping;\n\tvar ref$1 = __webpack_require__(2);\n\tvar Selection = ref$1.Selection;\n\tvar Plugin = ref$1.Plugin;\n\tvar PluginKey = ref$1.PluginKey;\n\t\n\t// ProseMirror's history isn't simply a way to roll back to a previous\n\t// state, because ProseMirror supports applying changes without adding\n\t// them to the history (for example during collaboration).\n\t//\n\t// To this end, each 'Branch' (one for the undo history and one for\n\t// the redo history) keeps an array of 'Items', which can optionally\n\t// hold a step (an actual undoable change), and always hold a position\n\t// map (which is needed to move changes below them to apply to the\n\t// current document).\n\t//\n\t// An item that has both a step and a selection JSON representation is\n\t// the start of an 'event' — a group of changes that will be undone\n\t// or redone at once. (It stores only the JSON, since that way we don't\n\t// have to provide a document until the selection is actually applied,\n\t// which is useful when compressing.)\n\t\n\t// Used to schedule history compression\n\tvar max_empty_items = 500\n\t\n\tvar Branch = function Branch(items, eventCount) {\n\t  this.items = items\n\t  this.eventCount = eventCount\n\t};\n\t\n\t// : (Node, bool, ?Item) → ?{transform: Transform, selection: Object}\n\t// Pop the latest event off the branch's history and apply it\n\t// to a document transform.\n\tBranch.prototype.popEvent = function popEvent (state, preserveItems) {\n\t    var this$1 = this;\n\t\n\t  if (this.eventCount == 0) { return null }\n\t\n\t  var end = this.items.length\n\t  for (;; end--) {\n\t    var next = this$1.items.get(end - 1)\n\t    if (next.selection) { --end; break }\n\t  }\n\t\n\t  var remap, mapFrom\n\t  if (preserveItems) {\n\t    remap = this.remapping(end, this.items.length)\n\t    mapFrom = remap.maps.length\n\t  }\n\t  var transform = state.tr\n\t  var selection, remaining\n\t  var addAfter = [], addBefore = []\n\t\n\t  this.items.forEach(function (item, i) {\n\t    if (!item.step) {\n\t      if (!remap) {\n\t        remap = this$1.remapping(end, i + 1)\n\t        mapFrom = remap.maps.length\n\t      }\n\t      mapFrom--\n\t      addBefore.push(item)\n\t      return\n\t    }\n\t\n\t    if (remap) {\n\t      addBefore.push(new Item(item.map))\n\t      var step = item.step.map(remap.slice(mapFrom)), map\n\t\n\t      if (step && transform.maybeStep(step).doc) {\n\t        map = transform.mapping.maps[transform.mapping.maps.length - 1]\n\t        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n\t      }\n\t      mapFrom--\n\t      if (map) { remap.appendMap(map, mapFrom) }\n\t    } else {\n\t      transform.maybeStep(item.step)\n\t    }\n\t\n\t    if (item.selection) {\n\t      selection = remap ? Selection.mapJSON(item.selection, remap.slice(mapFrom)) : item.selection\n\t      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1)\n\t      return false\n\t    }\n\t  }, this.items.length, 0)\n\t\n\t  return {remaining: remaining, transform: transform, selection: selection}\n\t};\n\t\n\t// : (Transform, Selection, Object)\n\t// Create a new branch with the given transform added.\n\tBranch.prototype.addTransform = function addTransform (transform, selection, histOptions) {\n\t  var newItems = [], eventCount = this.eventCount + (selection ? 1 : 0)\n\t  var oldItems = this.items, lastItem = !histOptions.preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\t\n\t  for (var i = 0; i < transform.steps.length; i++) {\n\t    var step = transform.steps[i].invert(transform.docs[i])\n\t    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0)\n\t    if (merged = lastItem && lastItem.merge(item)) {\n\t      item = merged\n\t      if (i) { newItems.pop() }\n\t      else { oldItems = oldItems.slice(0, oldItems.length - 1) }\n\t    }\n\t    newItems.push(item)\n\t    selection = null\n\t    if (!histOptions.preserveItems) { lastItem = item }\n\t  }\n\t  var overflow = this.eventCount - histOptions.depth\n\t  if (overflow > DEPTH_OVERFLOW) { oldItems = cutOffEvents(oldItems, overflow) }\n\t  return new Branch(oldItems.append(newItems), eventCount)\n\t};\n\t\n\tBranch.prototype.remapping = function remapping (from, to) {\n\t  var maps = [], mirrors = []\n\t  this.items.forEach(function (item, i) {\n\t    if (item.mirrorOffset != null) {\n\t      var mirrorPos = i - item.mirrorOffset\n\t      if (mirrorPos >= from) { mirrors.push(maps.length - item.mirrorOffset, maps.length) }\n\t    }\n\t    maps.push(item.map)\n\t  }, from, to)\n\t  return new Mapping(maps, mirrors)\n\t};\n\t\n\tBranch.prototype.addMaps = function addMaps (array) {\n\t  if (this.eventCount == 0) { return this }\n\t  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)\n\t};\n\t\n\t// : ([StepMap], Transform, [number])\n\t// When the collab module receives remote changes, the history has\n\t// to know about those, so that it can adjust the steps that were\n\t// rebased on top of the remote changes, and include the position\n\t// maps for the remote changes in its array of items.\n\tBranch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {\n\t  if (!this.eventCount) { return this }\n\t\n\t  var rebasedItems = [], start = this.items.length - rebasedCount, startPos = 0\n\t  if (start < 0) {\n\t    startPos = -start\n\t    start = 0\n\t  }\n\t\n\t  var mapping = rebasedTransform.mapping\n\t  var newUntil = rebasedTransform.steps.length\n\t\n\t  var iRebased = startPos\n\t  this.items.forEach(function (item) {\n\t    var pos = mapping.getMirror(iRebased++)\n\t    if (pos == null) { return }\n\t    newUntil = Math.min(newUntil, pos)\n\t    var map = mapping.maps[pos]\n\t    if (item.step) {\n\t      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n\t      var selection = item.selection && Selection.mapJSON(item.selection, mapping.slice(iRebased - 1, pos))\n\t      rebasedItems.push(new Item(map, step, selection))\n\t    } else {\n\t      rebasedItems.push(new Item(map))\n\t    }\n\t  }, start)\n\t\n\t  var newMaps = []\n\t  for (var i = rebasedCount; i < newUntil; i++)\n\t    { newMaps.push(new Item(mapping.maps[i])) }\n\t  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n\t  var branch = new Branch(items, this.eventCount) // FIXME might update event count\n\t  if (branch.emptyItemCount() > max_empty_items)\n\t    { branch = branch.compress(this.items.length - rebasedItems.length) }\n\t  return branch\n\t};\n\t\n\tBranch.prototype.emptyItemCount = function emptyItemCount () {\n\t  var count = 0\n\t  this.items.forEach(function (item) { if (!item.step) { count++ } })\n\t  return count\n\t};\n\t\n\t// Compressing a branch means rewriting it to push the air (map-only\n\t// items) out. During collaboration, these naturally accumulate\n\t// because each remote change adds one. The `upto` argument is used\n\t// to ensure that only the items below a given level are compressed,\n\t// because `rebased` relies on a clean, untouched set of items in\n\t// order to associate old items with rebased steps.\n\tBranch.prototype.compress = function compress (upto) {\n\t    if ( upto === void 0 ) upto = this.items.length;\n\t\n\t  var remap = this.remapping(0, upto), mapFrom = remap.maps.length\n\t  var items = [], events = 0\n\t  this.items.forEach(function (item, i) {\n\t    if (i >= upto) {\n\t      items.push(item)\n\t    } else if (item.step) {\n\t      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n\t      mapFrom--\n\t      if (map) { remap.appendMap(map, mapFrom) }\n\t      if (step) {\n\t        var selection = item.selection && Selection.mapJSON(item.selection, remap.slice(mapFrom))\n\t        if (selection) { events++ }\n\t        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n\t        if (merged = items.length && items[last].merge(newItem))\n\t          { items[last] = merged }\n\t        else\n\t          { items.push(newItem) }\n\t      }\n\t    } else if (item.map) {\n\t      mapFrom--\n\t    }\n\t  }, this.items.length, 0)\n\t  return new Branch(RopeSequence.from(items.reverse()), events)\n\t};\n\t\n\tBranch.empty = new Branch(RopeSequence.empty, 0)\n\t\n\tfunction cutOffEvents(items, n) {\n\t  var cutPoint\n\t  items.forEach(function (item, i) {\n\t    if (item.selection && (--n == 0)) {\n\t      cutPoint = i\n\t      return false\n\t    }\n\t  })\n\t  return items.slice(cutPoint)\n\t}\n\t\n\tvar Item = function Item(map, step, selection, mirrorOffset) {\n\t  this.map = map\n\t  this.step = step\n\t  this.selection = selection\n\t  this.mirrorOffset = mirrorOffset\n\t};\n\t\n\tItem.prototype.merge = function merge (other) {\n\t  if (this.step && other.step && !other.selection) {\n\t    var step = other.step.merge(this.step)\n\t    if (step) { return new Item(step.getMap().invert(), step, this.selection) }\n\t  }\n\t};\n\t\n\t// The value of the state field that tracks undo/redo history for that\n\t// state. Will be stored in the plugin state when the history plugin\n\t// is active.\n\tvar HistoryState = function HistoryState(done, undone, prevMap, prevTime) {\n\t  this.done = done\n\t  this.undone = undone\n\t  this.prevMap = prevMap\n\t  this.prevTime = prevTime\n\t};\n\texports.HistoryState = HistoryState\n\t\n\tvar DEPTH_OVERFLOW = 20\n\t\n\t// : (EditorState, Transform, Selection, Object)\n\t// Record a transformation in undo history.\n\tfunction applyTransaction(history, selection, tr, options) {\n\t  var newState = tr.getMeta(historyKey), rebased\n\t  if (newState) {\n\t    return newState\n\t  } else if (tr.steps.length == 0) {\n\t    if (tr.getMeta(closeHistoryKey)) { return new HistoryState(history.done, history.undone, null, 0) }\n\t    else { return history }\n\t  } else if (tr.getMeta(\"addToHistory\") !== false) {\n\t    // Group transforms that occur in quick succession into one event.\n\t    var newGroup = history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n\t        !isAdjacentToLastStep(tr, history.prevMap, history.done)\n\t    return new HistoryState(history.done.addTransform(tr, newGroup ? selection.toJSON() : null, options),\n\t                            Branch.empty, tr.mapping.maps[tr.steps.length - 1], tr.time)\n\t  } else if (rebased = tr.getMeta(\"rebased\")) {\n\t    // Used by the collab module to tell the history that some of its\n\t    // content has been rebased.\n\t    return new HistoryState(history.done.rebased(tr, rebased),\n\t                            history.undone.rebased(tr, rebased),\n\t                            history.prevMap && tr.mapping.maps[tr.steps.length - 1], history.prevTime)\n\t  } else {\n\t    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n\t                            history.undone.addMaps(tr.mapping.maps),\n\t                            history.prevMap, history.prevTime)\n\t  }\n\t}\n\t\n\tfunction isAdjacentToLastStep(transform, prevMap, done) {\n\t  if (!prevMap) { return false }\n\t  var firstMap = transform.mapping.maps[0], adjacent = false\n\t  if (!firstMap) { return true }\n\t  firstMap.forEach(function (start, end) {\n\t    done.items.forEach(function (item) {\n\t      if (item.step) {\n\t        prevMap.forEach(function (_start, _end, rStart, rEnd) {\n\t          if (start <= rEnd && end >= rStart) { adjacent = true }\n\t        })\n\t        return false\n\t      } else {\n\t        start = item.map.invert().map(start, -1)\n\t        end = item.map.invert().map(end, 1)\n\t      }\n\t    }, done.items.length, 0)\n\t  })\n\t  return adjacent\n\t}\n\t\n\t// : (HistoryState, EditorState, (tr: Transaction), bool)\n\t// Apply the latest event from one branch to the document and optionally\n\t// shift the event onto the other branch. Returns true when an event could\n\t// be shifted.\n\tfunction histTransaction(history, state, dispatch, redo) {\n\t  var histOptions = historyKey.get(state).options.config\n\t  var pop = (redo ? history.undone : history.done).popEvent(state, histOptions.preserveItems)\n\t  if (!pop) { return }\n\t\n\t  var selectionBefore = state.selection\n\t  var selection = Selection.fromJSON(pop.transform.doc, pop.selection)\n\t  var added = (redo ? history.done : history.undone).addTransform(pop.transform, selectionBefore.toJSON(), histOptions)\n\t\n\t  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n\t  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, newHist).scrollIntoView())\n\t}\n\t\n\tfunction closeHistory(state) {\n\t  return state.tr.setMeta(closeHistoryKey, true)\n\t}\n\texports.closeHistory = closeHistory\n\t\n\tvar historyKey = new PluginKey(\"history\")\n\tvar closeHistoryKey = new PluginKey(\"closeHistory\")\n\t\n\t// :: (?Object) → Plugin\n\t// Returns a plugin that enables the undo history for an editor. The\n\t// plugin will track undo and redo stacks, which the\n\t// [`undo`](##history.undo) and [`redo`](##history.redo) commands can\n\t// use to move the state back and forward.\n\t//\n\t// Note that this implementation doesn't implement history by simply\n\t// resetting back to some previous state. In order to support\n\t// collaborative editing (as well as some other use cases), it\n\t// selectively rolls back some transactions, but not other (for\n\t// example, not the changes made by other users). You can set an\n\t// `\"addToHistory\"` [metadata property](##state.Transaction.setMeta)\n\t// of `false` on a transaction to prevent it from being rolled back by\n\t// undo.\n\t//\n\t//   config::-\n\t//   Supports the following configuration options:\n\t//\n\t//     depth:: ?number\n\t//     The amount of history events that are collected before the\n\t//     oldest events are discarded. Defaults to 100.\n\t//\n\t//     newGroupDelay:: number\n\t//     The delay between changes after which a new group should be\n\t//     started. Defaults to 500 (milliseconds). Note that when changes\n\t//     aren't adjacent, a new group is always started.\n\t//\n\t//     preserveItems:: ?bool\n\t//     Whether to preserve the steps exactly as they came in. **Must**\n\t//     be true when using the history together with the collaborative\n\t//     editing plugin, to allow syncing the history when concurrent\n\t//     changes come in. Defaults to false.\n\tfunction history(config) {\n\t  config = {depth: config && config.depth || 100,\n\t            preserveItems: !!(config && config.preserveItems),\n\t            newGroupDelay: config && config.newGroupDelay || 500}\n\t  return new Plugin({\n\t    key: historyKey,\n\t\n\t    state: {\n\t      init: function init() {\n\t        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n\t      },\n\t      apply: function apply(tr, hist, state) {\n\t        return applyTransaction(hist, state.selection, tr, config)\n\t      }\n\t    },\n\t\n\t    config: config\n\t  })\n\t}\n\texports.history = history\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// A command function that undoes the last change, if any.\n\tfunction undo(state, dispatch) {\n\t  var hist = historyKey.getState(state)\n\t  if (!hist || hist.done.eventCount == 0) { return false }\n\t  if (dispatch) { histTransaction(hist, state, dispatch, false) }\n\t  return true\n\t}\n\texports.undo = undo\n\t\n\t// :: (EditorState, ?(tr: Transaction)) → bool\n\t// A command function that redoes the last undone change, if any.\n\tfunction redo(state, dispatch) {\n\t  var hist = historyKey.getState(state)\n\t  if (!hist || hist.undone.eventCount == 0) { return false }\n\t  if (dispatch) { histTransaction(hist, state, dispatch, true) }\n\t  return true\n\t}\n\texports.redo = redo\n\t\n\t// :: (EditorState) → number\n\t// The amount of undoable events available in a given state.\n\tfunction undoDepth(state) {\n\t  var hist = historyKey.getState(state)\n\t  return hist ? hist.done.eventCount : 0\n\t}\n\texports.undoDepth = undoDepth\n\t\n\t// :: (EditorState) → number\n\t// The amount of redoable events available in a given editor state.\n\tfunction redoDepth(state) {\n\t  var hist = historyKey.getState(state)\n\t  return hist ? hist.undone.eventCount : 0\n\t}\n\texports.redoDepth = redoDepth\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar Plugin = ref.Plugin;\n\tvar PluginKey = ref.PluginKey;\n\t\n\t// ::- Input rules are regular expressions describing a piece of text\n\t// that, when typed, causes something to happen. This might be\n\t// changing two dashes into an emdash, wrapping a paragraph starting\n\t// with `\"> \"` into a blockquote, or something entirely different.\n\tvar InputRule = function InputRule(match, handler) {\n\t  this.match = match\n\t  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n\t};\n\texports.InputRule = InputRule\n\t\n\tfunction stringHandler(string) {\n\t  return function(state, match, start, end) {\n\t    var insert = string\n\t    if (match[1]) {\n\t      var offset = match[0].lastIndexOf(match[1])\n\t      insert += match[0].slice(offset + match[1].length)\n\t      start += offset\n\t      var cutOff = start - end\n\t      if (cutOff > 0) {\n\t        insert = match[0].slice(offset - cutOff, offset) + insert\n\t        start = end\n\t      }\n\t    }\n\t    var marks = state.doc.resolve(start).marks()\n\t    return state.tr.replaceWith(start, end, state.schema.text(insert, marks))\n\t  }\n\t}\n\t\n\tvar MAX_MATCH = 100\n\t\n\tvar stateKey = new PluginKey(\"fromInputRule\")\n\t\n\t// :: (config: {rules: [InputRule]}) → Plugin\n\t// Create an input rules plugin. When enabled, it will cause text\n\t// input that matches any of the given rules to trigger the rule's\n\t// action, and binds the backspace key, when applied directly after an\n\t// input rule triggered, to undo the rule's effect.\n\tfunction inputRules(ref) {\n\t  var rules = ref.rules;\n\t\n\t  return new Plugin({\n\t    state: {\n\t      init: function init() { return null },\n\t      apply: function apply(tr, prev) {\n\t        var stored = tr.getMeta(stateKey)\n\t        if (stored) { return stored }\n\t        return tr.selectionSet || tr.docChanged ? null : prev\n\t      }\n\t    },\n\t\n\t    props: {\n\t      handleTextInput: function handleTextInput(view, from, to, text) {\n\t        var state = view.state, $from = state.doc.resolve(from)\n\t        var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n\t                                                  null, \"\\ufffc\") + text\n\t        for (var i = 0; i < rules.length; i++) {\n\t          var match = rules[i].match.exec(textBefore)\n\t          var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n\t          if (!tr) { continue }\n\t          view.dispatch(tr.setMeta(stateKey, {transform: tr, from: from, to: to, text: text}))\n\t          return true\n\t        }\n\t        return false\n\t      },\n\t\n\t      handleKeyDown: function handleKeyDown(view, event) {\n\t        if (event.keyCode == 8) { return maybeUndoInputRule(view.state, view.dispatch, this.getState(view.state)) }\n\t        return false\n\t      }\n\t    }\n\t  })\n\t}\n\texports.inputRules = inputRules\n\t\n\tfunction maybeUndoInputRule(state, dispatch, undoable) {\n\t  if (!undoable) { return false }\n\t  var tr = state.tr, toUndo = undoable.transform\n\t  for (var i = toUndo.steps.length - 1; i >= 0; i--)\n\t    { tr.step(toUndo.steps[i].invert(toUndo.docs[i])) }\n\t  var marks = tr.doc.resolve(undoable.from).marks()\n\t  dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)))\n\t  return true\n\t}\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(5);\n\tvar Fragment = ref.Fragment;\n\t\n\t// ::- Error type raised by [`Node.replace`](#model.Node.replace) when\n\t// given an invalid replacement.\n\tvar ReplaceError = (function (Error) {\n\t  function ReplaceError(message) {\n\t    Error.call(this, message)\n\t    this.message = message\n\t  }\n\t\n\t  if ( Error ) ReplaceError.__proto__ = Error;\n\t  ReplaceError.prototype = Object.create( Error && Error.prototype );\n\t  ReplaceError.prototype.constructor = ReplaceError;\n\t\n\t  return ReplaceError;\n\t}(Error));\n\texports.ReplaceError = ReplaceError\n\t\n\t// ::- A slice represents a piece cut out of a larger document. It\n\t// stores not only a fragment, but also the depth up to which nodes on\n\t// both side are 'open' / cut through.\n\tvar Slice = function(content, openLeft, openRight) {\n\t  // :: Fragment The slice's content nodes.\n\t  this.content = content\n\t  // :: number The open depth at the start.\n\t  this.openLeft = openLeft\n\t  // :: number The open depth at the end.\n\t  this.openRight = openRight\n\t};\n\t\n\tvar prototypeAccessors = { size: {} };\n\t\n\t// :: number\n\t// The size this slice would add when inserted into a document.\n\tprototypeAccessors.size.get = function () {\n\t  return this.content.size - this.openLeft - this.openRight\n\t};\n\t\n\tSlice.prototype.insertAt = function (pos, fragment) {\n\t  var content = insertInto(this.content, pos + this.openLeft, fragment, null)\n\t  return content && new Slice(content, this.openLeft, this.openRight)\n\t};\n\t\n\tSlice.prototype.removeBetween = function (from, to) {\n\t  return new Slice(removeRange(this.content, from + this.openLeft, to + this.openLeft), this.openLeft, this.openRight)\n\t};\n\t\n\tSlice.prototype.eq = function (other) {\n\t  return this.content.eq(other.content) && this.openLeft == other.openLeft && this.openRight == other.openRight\n\t};\n\t\n\tSlice.prototype.toString = function () {\n\t  return this.content + \"(\" + this.openLeft + \",\" + this.openRight + \")\"\n\t};\n\t\n\t// :: () → ?Object\n\t// Convert a slice to a JSON-serializable representation.\n\tSlice.prototype.toJSON = function () {\n\t  if (!this.content.size) { return null }\n\t  return {content: this.content.toJSON(),\n\t          openLeft: this.openLeft,\n\t          openRight: this.openRight}\n\t};\n\t\n\t// :: (Schema, ?Object) → Slice\n\t// Deserialize a slice from its JSON representation.\n\tSlice.fromJSON = function (schema, json) {\n\t  if (!json) { return Slice.empty }\n\t  return new Slice(Fragment.fromJSON(schema, json.content), json.openLeft, json.openRight)\n\t};\n\t\n\t// :: (Fragment) → Slice\n\t// Create a slice from a fragment by taking the maximum possible\n\t// open value on both side of the fragment.\n\tSlice.maxOpen = function (fragment) {\n\t  var openLeft = 0, openRight = 0\n\t  for (var n = fragment.firstChild; n && !n.isLeaf; n = n.firstChild) { openLeft++ }\n\t  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf; n$1 = n$1.lastChild) { openRight++ }\n\t  return new Slice(fragment, openLeft, openRight)\n\t};\n\t\n\tObject.defineProperties( Slice.prototype, prototypeAccessors );\n\texports.Slice = Slice\n\t\n\tfunction removeRange(content, from, to) {\n\t  var ref = content.findIndex(from);\n\t  var index = ref.index;\n\t  var offset = ref.offset;\n\t  var child = content.maybeChild(index)\n\t  var ref$1 = content.findIndex(to);\n\t  var indexTo = ref$1.index;\n\t  var offsetTo = ref$1.offset;\n\t  if (offset == from || child.isText) {\n\t    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n\t    return content.cut(0, from).append(content.cut(to))\n\t  }\n\t  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n\t  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n\t}\n\t\n\tfunction insertInto(content, dist, insert, parent) {\n\t  var ref = content.findIndex(dist);\n\t  var index = ref.index;\n\t  var offset = ref.offset;\n\t  var child = content.maybeChild(index)\n\t  if (offset == dist || child.isText) {\n\t    if (parent && !parent.canReplace(index, index, insert)) { return null }\n\t    return content.cut(0, dist).append(insert).append(content.cut(dist))\n\t  }\n\t  var inner = insertInto(child.content, dist - offset - 1, insert)\n\t  return inner && content.replaceChild(index, child.copy(inner))\n\t}\n\t\n\t// :: Slice\n\t// The empty slice.\n\tSlice.empty = new Slice(Fragment.empty, 0, 0)\n\t\n\tfunction replace($from, $to, slice) {\n\t  if (slice.openLeft > $from.depth)\n\t    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n\t  if ($from.depth - slice.openLeft != $to.depth - slice.openRight)\n\t    { throw new ReplaceError(\"Inconsistent open depths\") }\n\t  return replaceOuter($from, $to, slice, 0)\n\t}\n\texports.replace = replace\n\t\n\tfunction replaceOuter($from, $to, slice, depth) {\n\t  var index = $from.index(depth), node = $from.node(depth)\n\t  if (index == $to.index(depth) && depth < $from.depth - slice.openLeft) {\n\t    var inner = replaceOuter($from, $to, slice, depth + 1)\n\t    return node.copy(node.content.replaceChild(index, inner))\n\t  } else if (!slice.content.size) {\n\t    return close(node, replaceTwoWay($from, $to, depth))\n\t  } else if (!slice.openLeft && !slice.openRight && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n\t    var parent = $from.parent, content = parent.content\n\t    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n\t  } else {\n\t    var ref = prepareSliceForReplace(slice, $from);\n\t    var start = ref.start;\n\t    var end = ref.end;\n\t    return close(node, replaceThreeWay($from, start, end, $to, depth))\n\t  }\n\t}\n\t\n\tfunction checkJoin(main, sub) {\n\t  if (!sub.type.compatibleContent(main.type))\n\t    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n\t}\n\t\n\tfunction joinable($before, $after, depth) {\n\t  var node = $before.node(depth)\n\t  checkJoin(node, $after.node(depth))\n\t  return node\n\t}\n\t\n\tfunction addNode(child, target) {\n\t  var last = target.length - 1\n\t  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n\t    { target[last] = child.withText(target[last].text + child.text) }\n\t  else\n\t    { target.push(child) }\n\t}\n\t\n\tfunction addRange($start, $end, depth, target) {\n\t  var node = ($end || $start).node(depth)\n\t  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n\t  if ($start) {\n\t    startIndex = $start.index(depth)\n\t    if ($start.depth > depth) {\n\t      startIndex++\n\t    } else if ($start.textOffset) {\n\t      addNode($start.nodeAfter, target)\n\t      startIndex++\n\t    }\n\t  }\n\t  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target) }\n\t  if ($end && $end.depth == depth && $end.textOffset)\n\t    { addNode($end.nodeBefore, target) }\n\t}\n\t\n\tfunction close(node, content) {\n\t  if (!node.type.validContent(content, node.attrs))\n\t    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n\t  return node.copy(content)\n\t}\n\t\n\tfunction replaceThreeWay($from, $start, $end, $to, depth) {\n\t  var openLeft = $from.depth > depth && joinable($from, $start, depth + 1)\n\t  var openRight = $to.depth > depth && joinable($end, $to, depth + 1)\n\t\n\t  var content = []\n\t  addRange(null, $from, depth, content)\n\t  if (openLeft && openRight && $start.index(depth) == $end.index(depth)) {\n\t    checkJoin(openLeft, openRight)\n\t    addNode(close(openLeft, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n\t  } else {\n\t    if (openLeft)\n\t      { addNode(close(openLeft, replaceTwoWay($from, $start, depth + 1)), content) }\n\t    addRange($start, $end, depth, content)\n\t    if (openRight)\n\t      { addNode(close(openRight, replaceTwoWay($end, $to, depth + 1)), content) }\n\t  }\n\t  addRange($to, null, depth, content)\n\t  return new Fragment(content)\n\t}\n\t\n\tfunction replaceTwoWay($from, $to, depth) {\n\t  var content = []\n\t  addRange(null, $from, depth, content)\n\t  if ($from.depth > depth) {\n\t    var type = joinable($from, $to, depth + 1)\n\t    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n\t  }\n\t  addRange($to, null, depth, content)\n\t  return new Fragment(content)\n\t}\n\t\n\tfunction prepareSliceForReplace(slice, $along) {\n\t  var extra = $along.depth - slice.openLeft, parent = $along.node(extra)\n\t  var node = parent.copy(slice.content)\n\t  for (var i = extra - 1; i >= 0; i--)\n\t    { node = $along.node(i).copy(Fragment.from(node)) }\n\t  return {start: node.resolveNoCache(slice.openLeft + extra),\n\t          end: node.resolveNoCache(node.content.size - slice.openRight - extra)}\n\t}\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t// ::- Superclass for editor selections.\n\tvar Selection = function Selection($from, $to) {\n\t  // :: ResolvedPos\n\t  // The resolved lower bound of the selection\n\t  this.$from = $from\n\t  // :: ResolvedPos\n\t  // The resolved upper bound of the selection\n\t  this.$to = $to\n\t};\n\t\n\tvar prototypeAccessors = { from: {},to: {},empty: {} };\n\t\n\t// :: bool\n\t// True if the selection is an empty text selection (head an anchor\n\t// are the same).\n\tprototypeAccessors.from.get = function () { return this.$from.pos };\n\t\n\t// :: number\n\t// The upper bound of the selection.\n\tprototypeAccessors.to.get = function () { return this.$to.pos };\n\t\n\tprototypeAccessors.empty.get = function () {\n\t  return this.from == this.to\n\t};\n\t\n\t// eq:: (other: Selection) → bool\n\t// Test whether the selection is the same as another selection.\n\t\n\t// map:: (doc: Node, mapping: Mappable) → Selection\n\t// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n\t// should be the new document, to which we are mapping.\n\t\n\t// toJSON:: () → Object\n\t// Convert the selection to a JSON representation.\n\t\n\t// :: (ResolvedPos, number, ?bool) → ?Selection\n\t// Find a valid cursor or leaf node selection starting at the given\n\t// position and searching back if `dir` is negative, and forward if\n\t// negative. When `textOnly` is true, only consider cursor\n\t// selections.\n\tSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n\t  var inner = $pos.parent.isTextblock ? new TextSelection($pos)\n\t      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n\t  if (inner) { return inner }\n\t\n\t  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n\t    var found = dir < 0\n\t        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n\t        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n\t    if (found) { return found }\n\t  }\n\t};\n\t\n\t// :: (ResolvedPos, ?number, ?bool) → Selection\n\t// Find a valid cursor or leaf node selection near the given\n\t// position. Searches forward first by default, but if `bias` is\n\t// negative, it will search backwards first.\n\tSelection.near = function near ($pos, bias) {\n\t    if ( bias === void 0 ) bias = 1;\n\t\n\t  var result = this.findFrom($pos, bias) || this.findFrom($pos, -bias)\n\t  if (!result) { throw new RangeError(\"Searching for selection in invalid document \" + $pos.node(0)) }\n\t  return result\n\t};\n\t\n\t// :: (Node, ?bool) → ?Selection\n\t// Find the cursor or leaf node selection closest to the start of\n\t// the given document. When `textOnly` is true, only consider cursor\n\t// selections.\n\tSelection.atStart = function atStart (doc, textOnly) {\n\t  return findSelectionIn(doc, doc, 0, 0, 1, textOnly)\n\t};\n\t\n\t// :: (Node, ?bool) → ?Selection\n\t// Find the cursor or leaf node selection closest to the end of\n\t// the given document. When `textOnly` is true, only consider cursor\n\t// selections.\n\tSelection.atEnd = function atEnd (doc, textOnly) {\n\t  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1, textOnly)\n\t};\n\t\n\t// :: (ResolvedPos, ResolvedPos, ?number) → Selection\n\t// Find a selection that spans the given positions, if both are text\n\t// positions. If not, return some other selection nearby, where\n\t// `bias` determines whether the method searches forward (default)\n\t// or backwards (negative number) first.\n\tSelection.between = function between ($anchor, $head, bias) {\n\t  var found = Selection.near($head, bias)\n\t  if (found instanceof TextSelection) {\n\t    var nearAnchor = Selection.findFrom($anchor, $anchor.pos > found.to ? -1 : 1, true)\n\t    found = new TextSelection(nearAnchor.$anchor, found.$head)\n\t  } else if ($anchor.pos < found.from || $anchor.pos > found.to) {\n\t    // If head falls on a node, but anchor falls outside of it, create\n\t    // a text selection between them\n\t    var inv = $anchor.pos > found.to\n\t    var foundAnchor = Selection.findFrom($anchor, inv ? -1 : 1, true)\n\t    var foundHead = Selection.findFrom(inv ? found.$from : found.$to, inv ? 1 : -1, true)\n\t    if (foundAnchor && foundHead)\n\t      { found = new TextSelection(foundAnchor.$anchor, foundHead.$head) }\n\t  }\n\t  return found\n\t};\n\t\n\tSelection.mapJSON = function mapJSON (json, mapping) {\n\t  if (json.anchor != null)\n\t    { return {head: mapping.map(json.head), anchor: mapping.map(json.anchor)} }\n\t  else\n\t    { return {node: mapping.map(json.node), after: mapping.map(json.after, -1)} }\n\t};\n\t\n\t// :: (Node, Object) → Selection\n\t// Deserialize a JSON representation of a selection.\n\tSelection.fromJSON = function fromJSON (doc, json) {\n\t  // This is cautious, because the history will blindly map\n\t  // selections and then try to deserialize them, and the endpoints\n\t  // might not point at appropriate positions anymore (though they\n\t  // are guaranteed to be inside of the document's range).\n\t  if (json.head != null) {\n\t    var $anchor = doc.resolve(json.anchor), $head = doc.resolve(json.head)\n\t    if ($anchor.parent.isTextblock && $head.parent.isTextblock) { return new TextSelection($anchor, $head) }\n\t    else { return Selection.between($anchor, $head) }\n\t  } else {\n\t    var $pos = doc.resolve(json.node), after = $pos.nodeAfter\n\t    if (after && json.after == json.pos + after.nodeSize && NodeSelection.isSelectable(after)) { return new NodeSelection($pos) }\n\t    else { return Selection.near($pos) }\n\t  }\n\t};\n\t\n\tObject.defineProperties( Selection.prototype, prototypeAccessors );\n\texports.Selection = Selection\n\t\n\t// ::- A text selection represents a classical editor\n\t// selection, with a head (the moving side) and anchor (immobile\n\t// side), both of which point into textblock nodes. It can be empty (a\n\t// regular cursor position).\n\tvar TextSelection = (function (Selection) {\n\t  function TextSelection($anchor, $head) {\n\t    if ( $head === void 0 ) $head = $anchor;\n\t\n\t    var inv = $anchor.pos > $head.pos\n\t    Selection.call(this, inv ? $head : $anchor, inv ? $anchor : $head)\n\t    // :: ResolvedPos The resolved anchor of the selection.\n\t    this.$anchor = $anchor\n\t    // :: ResolvedPos The resolved head of the selection.\n\t    this.$head = $head\n\t  }\n\t\n\t  if ( Selection ) TextSelection.__proto__ = Selection;\n\t  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n\t  TextSelection.prototype.constructor = TextSelection;\n\t\n\t  var prototypeAccessors$1 = { anchor: {},head: {},inverted: {} };\n\t\n\t  prototypeAccessors$1.anchor.get = function () { return this.$anchor.pos };\n\t  // :: number\n\t  // The selection's mobile side (the side that moves when pressing\n\t  // shift-arrow).\n\t  prototypeAccessors$1.head.get = function () { return this.$head.pos };\n\t\n\t  prototypeAccessors$1.inverted.get = function () { return this.anchor > this.head };\n\t\n\t  TextSelection.prototype.eq = function eq (other) {\n\t    return other instanceof TextSelection && other.head == this.head && other.anchor == this.anchor\n\t  };\n\t\n\t  TextSelection.prototype.map = function map (doc, mapping) {\n\t    var $head = doc.resolve(mapping.map(this.head))\n\t    if (!$head.parent.isTextblock) { return Selection.near($head) }\n\t    var $anchor = doc.resolve(mapping.map(this.anchor))\n\t    return new TextSelection($anchor.parent.isTextblock ? $anchor : $head, $head)\n\t  };\n\t\n\t  TextSelection.prototype.toJSON = function toJSON () {\n\t    return {head: this.head, anchor: this.anchor}\n\t  };\n\t\n\t  // :: (Node, number, ?number) → TextSelection\n\t  // Create a text selection from non-resolved positions.\n\t  TextSelection.create = function create (doc, anchor, head) {\n\t    if ( head === void 0 ) head = anchor;\n\t\n\t    var $anchor = doc.resolve(anchor)\n\t    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n\t  };\n\t\n\t  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\t\n\t  return TextSelection;\n\t}(Selection));\n\texports.TextSelection = TextSelection\n\t\n\t// ::- A node selection is a selection that points at a\n\t// single node. All nodes marked [selectable](#model.NodeSpec.selectable)\n\t// can be the target of a node selection. In such an object, `from`\n\t// and `to` point directly before and after the selected node.\n\tvar NodeSelection = (function (Selection) {\n\t  function NodeSelection($from) {\n\t    var $to = $from.node(0).resolve($from.pos + $from.nodeAfter.nodeSize)\n\t    Selection.call(this, $from, $to)\n\t    // :: Node The selected node.\n\t    this.node = $from.nodeAfter\n\t  }\n\t\n\t  if ( Selection ) NodeSelection.__proto__ = Selection;\n\t  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n\t  NodeSelection.prototype.constructor = NodeSelection;\n\t\n\t  NodeSelection.prototype.eq = function eq (other) {\n\t    return other instanceof NodeSelection && this.from == other.from\n\t  };\n\t\n\t  NodeSelection.prototype.map = function map (doc, mapping) {\n\t    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n\t    var $from = doc.resolve(from.pos), node = $from.nodeAfter\n\t    if (!from.deleted && !to.deleted && node && to.pos == from.pos + node.nodeSize && NodeSelection.isSelectable(node))\n\t      { return new NodeSelection($from) }\n\t    return Selection.near($from)\n\t  };\n\t\n\t  NodeSelection.prototype.toJSON = function toJSON () {\n\t    return {node: this.from, after: this.to}\n\t  };\n\t\n\t  // :: (Node, number, ?number) → TextSelection\n\t  // Create a node selection from non-resolved positions.\n\t  NodeSelection.create = function create (doc, from) {\n\t    return new this(doc.resolve(from))\n\t  };\n\t\n\t  // :: (Node) → bool\n\t  // Determines whether the given node may be selected as a node\n\t  // selection.\n\t  NodeSelection.isSelectable = function isSelectable (node) {\n\t    return !node.isText && node.type.spec.selectable !== false\n\t  };\n\t\n\t  return NodeSelection;\n\t}(Selection));\n\texports.NodeSelection = NodeSelection\n\t\n\t// FIXME we'll need some awareness of text direction when scanning for selections\n\t\n\t// Try to find a selection inside the given node. `pos` points at the\n\t// position where the search starts. When `text` is true, only return\n\t// text selections.\n\tfunction findSelectionIn(doc, node, pos, index, dir, text) {\n\t  if (node.isTextblock) { return TextSelection.create(doc, pos) }\n\t  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n\t    var child = node.child(i)\n\t    if (!child.isLeaf) {\n\t      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n\t      if (inner) { return inner }\n\t    } else if (!text && NodeSelection.isSelectable(child)) {\n\t      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n\t    }\n\t    pos += child.nodeSize * dir\n\t  }\n\t}\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar ReplaceError = ref.ReplaceError;\n\t\n\tvar ref$1 = __webpack_require__(15);\n\tvar StepMap = ref$1.StepMap;\n\t\n\tfunction mustOverride() { throw new Error(\"Override me\") }\n\t\n\tvar stepsByID = Object.create(null)\n\t\n\t// ::- A step object wraps an atomic operation. It generally applies\n\t// only to the document it was created for, since the positions\n\t// associated with it will only make sense for that document.\n\t//\n\t// New steps are defined by creating classes that extend `Step`,\n\t// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n\t// methods, and registering your class with a unique\n\t// JSON-serialization identifier using\n\t// [`Step.jsonID`](#transform.Step^jsonID).\n\tvar Step = function Step () {};\n\t\n\tStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\t\n\t// :: () → StepMap\n\t// Get the step map that represents the changes made by this\n\t// step.\n\tStep.prototype.getMap = function getMap () { return StepMap.empty };\n\t\n\t// :: (doc: Node) → Step\n\t// Create an inverted version of this step. Needs the document as it\n\t// was before the step as argument.\n\tStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\t\n\t// :: (mapping: Mappable) → ?Step\n\t// Map this step through a mappable thing, returning either a\n\t// version of that step with its positions adjusted, or `null` if\n\t// the step was entirely deleted by the mapping.\n\tStep.prototype.map = function map (_mapping) { return mustOverride() };\n\t\n\t// :: (other: Step) → ?Step\n\t// Try to merge this step with another one, to be applied directly\n\t// after it. Returns the merged step when possible, null if the\n\t// steps can't be merged.\n\tStep.prototype.merge = function merge (_other) { return null };\n\t\n\t// :: () → Object\n\t// Create a JSON-serializeable representation of this step. By\n\t// default, it'll create an object with the step's [JSON\n\t// id](#transform.Step^jsonID), and each of the steps's own properties,\n\t// automatically calling `toJSON` on the property values that have\n\t// such a method.\n\tStep.prototype.toJSON = function toJSON () {\n\t    var this$1 = this;\n\t\n\t  var obj = {stepType: this.jsonID}\n\t  for (var prop in this$1) { if (this$1.hasOwnProperty(prop)) {\n\t    var val = this$1[prop]\n\t    obj[prop] = val && val.toJSON ? val.toJSON() : val\n\t  } }\n\t  return obj\n\t};\n\t\n\t// :: (Schema, Object) → Step\n\t// Deserialize a step from its JSON representation. Will call\n\t// through to the step class' own implementation of this method.\n\tStep.fromJSON = function fromJSON (schema, json) {\n\t  return stepsByID[json.stepType].fromJSON(schema, json)\n\t};\n\t\n\t// :: (string, constructor<Step>)\n\t// To be able to serialize steps to JSON, each step needs a string\n\t// ID to attach to its JSON representation. Use this method to\n\t// register an ID for your step classes. Try to pick something\n\t// that's unlikely to clash with steps from other modules.\n\tStep.jsonID = function jsonID (id, stepClass) {\n\t  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n\t  stepsByID[id] = stepClass\n\t  stepClass.prototype.jsonID = id\n\t  return stepClass\n\t};\n\texports.Step = Step\n\t\n\t// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n\t// new document or a failure value.\n\tvar StepResult = function StepResult(doc, failed) {\n\t  // :: ?Node The transformed document.\n\t  this.doc = doc\n\t  // :: ?string Text providing information about a failed step.\n\t  this.failed = failed\n\t};\n\t\n\t// :: (Node) → StepResult\n\t// Create a successful step result.\n\tStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\t\n\t// :: (string) → StepResult\n\t// Create a failed step result.\n\tStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\t\n\t// :: (Node, number, number, Slice) → StepResult\n\t// Call [`Node.replace`](#model.Node.replace) with the given\n\t// arguments. Create a successful result if it succeeds, and a\n\t// failed one if it throws a `ReplaceError`.\n\tStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n\t  try {\n\t    return StepResult.ok(doc.replace(from, to, slice))\n\t  } catch (e) {\n\t    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n\t    throw e\n\t  }\n\t};\n\texports.StepResult = StepResult\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(158);\n\tvar scrollRectIntoView = ref.scrollRectIntoView;\n\tvar posAtCoords = ref.posAtCoords;\n\tvar coordsAtPos = ref.coordsAtPos;\n\tvar endOfTextblock = ref.endOfTextblock;\n\tvar ref$1 = __webpack_require__(161);\n\tvar docViewDesc = ref$1.docViewDesc;\n\tvar ref$2 = __webpack_require__(159);\n\tvar initInput = ref$2.initInput;\n\tvar destroyInput = ref$2.destroyInput;\n\tvar dispatchEvent = ref$2.dispatchEvent;\n\tvar startObserving = ref$2.startObserving;\n\tvar stopObserving = ref$2.stopObserving;\n\tvar ensureListeners = ref$2.ensureListeners;\n\tvar ref$3 = __webpack_require__(160);\n\tvar SelectionReader = ref$3.SelectionReader;\n\tvar selectionToDOM = ref$3.selectionToDOM;\n\tvar ref$4 = __webpack_require__(59);\n\tvar viewDecorations = ref$4.viewDecorations;\n\tvar Decoration = ref$4.Decoration;var assign;\n\t((assign = __webpack_require__(59), exports.Decoration = assign.Decoration, exports.DecorationSet = assign.DecorationSet))\n\t\n\t// ::- An editor view manages the DOM structure that represents an\n\t// editor. Its state and behavior are determined by its\n\t// [props](#view.EditorProps).\n\tvar EditorView = function(place, props) {\n\t  // :: EditorProps\n\t  // The view's current [props](#view.EditorProps).\n\t  this.props = props\n\t  // :: EditorState\n\t  // The view's current [state](#state.EditorState).\n\t  this.state = props.state\n\t\n\t  this.dispatch = this.dispatch.bind(this)\n\t\n\t  this._root = null\n\t  this.focused = false\n\t\n\t  // :: dom.Element\n\t  // The editable DOM node containing the document. (You probably\n\t  // should not be directly interfering with its child nodes.)\n\t  this.content = document.createElement(\"div\")\n\t\n\t  if (place && place.appendChild) { place.appendChild(this.content) }\n\t  else if (place) { place(this.content) }\n\t\n\t  this.editable = getEditable(this)\n\t  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.content, this)\n\t\n\t  this.lastSelectedViewDesc = null\n\t  this.selectionReader = new SelectionReader(this)\n\t  initInput(this)\n\t\n\t  this.pluginViews = []\n\t  this.updatePluginViews()\n\t};\n\t\n\tvar prototypeAccessors = { root: {} };\n\t\n\t// :: (EditorProps)\n\t// Update the view's props. Will immediately cause an update to\n\t// the view's DOM.\n\tEditorView.prototype.update = function (props) {\n\t  if (props.handleDOMEvents != this.props.handleDOMEvents) { ensureListeners(this) }\n\t  this.props = props\n\t  this.updateState(props.state)\n\t};\n\t\n\t// :: (EditorState)\n\t// Update the editor's `state` prop, without touching any of the\n\t// other props.\n\tEditorView.prototype.updateState = function (state) {\n\t  var prev = this.state\n\t  this.state = state\n\t  if (prev.plugins != state.plugins) { ensureListeners(this) }\n\t\n\t  if (this.inDOMChange) { return }\n\t\n\t  var prevEditable = this.editable\n\t  this.editable = getEditable(this)\n\t  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this)\n\t\n\t  if (!this.docView.matchesNode(state.doc, outerDeco, innerDeco)) {\n\t    stopObserving(this)\n\t    this.docView.update(state.doc, outerDeco, innerDeco, this)\n\t    selectionToDOM(this, state.selection)\n\t    startObserving(this)\n\t  } else if (!state.selection.eq(prev.selection) || this.selectionReader.domChanged()) {\n\t    stopObserving(this)\n\t    selectionToDOM(this, state.selection)\n\t    startObserving(this)\n\t  }\n\t\n\t  if (prevEditable != this.editable) { this.selectionReader.editableChanged() }\n\t  this.updatePluginViews(prev)\n\t\n\t  if (state.scrollToSelection > prev.scrollToSelection || prev.config != state.config) {\n\t    if (state.selection.node)\n\t      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect()) }\n\t    else\n\t      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head)) }\n\t  }\n\t};\n\t\n\tEditorView.prototype.destroyPluginViews = function () {\n\t  var view\n\t  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy() } }\n\t};\n\t\n\tEditorView.prototype.updatePluginViews = function (prevState) {\n\t    var this$1 = this;\n\t\n\t  var plugins = this.state.plugins\n\t  if (!prevState || prevState.plugins != plugins) {\n\t    this.destroyPluginViews()\n\t    for (var i = 0; i < plugins.length; i++) {\n\t      var plugin = plugins[i]\n\t      if (plugin.options.view) { this$1.pluginViews.push(plugin.options.view(this$1)) }\n\t    }\n\t  } else {\n\t    for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {\n\t      var pluginView = this$1.pluginViews[i$1]\n\t      if (pluginView.update) { pluginView.update(this$1) }\n\t    }\n\t  }\n\t};\n\t\n\t// :: () → bool\n\t// Query whether the view has focus.\n\tEditorView.prototype.hasFocus = function () {\n\t  if (this.editable && this.content.ownerDocument.activeElement != this.content) { return false }\n\t  var sel = this.root.getSelection()\n\t  return sel.rangeCount && this.content.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode)\n\t};\n\t\n\t// :: (string, (prop: *) → *) → *\n\t// Goes over the values of a prop, first those provided directly,\n\t// then those from plugins (in order), and calls `f` every time a\n\t// non-undefined value is found. When `f` returns a truthy value,\n\t// that is immediately returned. When `f` isn't provided, it is\n\t// treated as the identity function (the prop value is returned\n\t// directly).\n\tEditorView.prototype.someProp = function (propName, f) {\n\t  var prop = this.props && this.props[propName], value\n\t  if (prop != null && (value = f ? f(prop) : prop)) { return value }\n\t  var plugins = this.state.plugins\n\t  if (plugins) { for (var i = 0; i < plugins.length; i++) {\n\t    var prop$1 = plugins[i].props[propName]\n\t    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }\n\t  } }\n\t};\n\t\n\t// :: ()\n\t// Focus the editor.\n\tEditorView.prototype.focus = function () {\n\t  stopObserving(this)\n\t  selectionToDOM(this, this.state.selection, true)\n\t  startObserving(this)\n\t  if (this.editable) { this.content.focus() }\n\t};\n\t\n\t// :: union<dom.Document, dom.DocumentFragment>\n\t// Get the document root in which the editor exists. This will\n\t// usually be the top-level `document`, but might be a shadow DOM\n\t// root if the editor is inside a shadow DOM.\n\tprototypeAccessors.root.get = function () {\n\t    var this$1 = this;\n\t\n\t  var cached = this._root\n\t  if (cached == null) { for (var search = this.content.parentNode; search; search = search.parentNode) {\n\t    if (search.nodeType == 9 || (search.nodeType == 11 && search.host))\n\t      { return this$1._root = search }\n\t  } }\n\t  return cached || document\n\t};\n\t\n\t// :: ({left: number, top: number}) → ?{pos: number, inside: number}\n\t// Given a pair of coordinates, return the document position that\n\t// corresponds to them. May return null if the given coordinates\n\t// aren't inside of the visible editor. When an object is returned,\n\t// its `pos` property is the position nearest to the coordinates,\n\t// and its `inside` property holds the position before the inner\n\t// node that the click happened inside of, or -1 if the click was at\n\t// the top level.\n\tEditorView.prototype.posAtCoords = function (coords) { return posAtCoords(this, coords) };\n\t\n\t// :: (number) → {left: number, right: number, top: number, bottom: number}\n\t// Returns the screen rectangle at a given document position. `left`\n\t// and `right` will be the same number, as this returns a flat\n\t// cursor-ish rectangle.\n\tEditorView.prototype.coordsAtPos = function (pos) { return coordsAtPos(this, pos) };\n\t\n\t// :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n\t// Find out whether the selection is at the end of a textblock when\n\t// moving in a given direction. When, for example, given `\"left\"`,\n\t// it will return true if moving left from the current cursor\n\t// position would leave that position's parent textblock. For\n\t// horizontal motion, it will always return false if the selection\n\t// isn't a cursor selection.\n\tEditorView.prototype.endOfTextblock = function (dir, state) {\n\t  return endOfTextblock(this, state || this.state, dir)\n\t};\n\t\n\t// :: ()\n\t// Removes the editor from the DOM and destroys all [node\n\t// views](#view.NodeView).\n\tEditorView.prototype.destroy = function () {\n\t  destroyInput(this)\n\t  this.destroyPluginViews()\n\t  this.docView.destroy()\n\t  this.selectionReader.destroy()\n\t  if (this.content.parentNode) { this.content.parentNode.removeChild(this.content) }\n\t};\n\t\n\t// Used for testing.\n\tEditorView.prototype.dispatchEvent = function (event) {\n\t  return dispatchEvent(this, event)\n\t};\n\t\n\t// :: (Transaction)\n\t// Dispatch a transaction. Will call the\n\t// [`dispatchTransaction`](#view.EditorProps.dispatchTransaction) when given,\n\t// and defaults to applying the transaction to the current state and\n\t// calling [`updateState`](#view.EditorView.updateState) otherwise.\n\t// This method is bound to the view instance, so that it can be\n\t// easily passed around.\n\tEditorView.prototype.dispatch = function (tr) {\n\t  var dispatchTransaction = this.props.dispatchTransaction\n\t  if (dispatchTransaction) { dispatchTransaction(tr) }\n\t  else { this.updateState(this.state.apply(tr)) }\n\t};\n\t\n\tObject.defineProperties( EditorView.prototype, prototypeAccessors );\n\texports.EditorView = EditorView\n\t\n\tfunction computeDocDeco(view) {\n\t  var attrs = Object.create(null)\n\t  attrs.class = \"ProseMirror\" + (view.focused ? \" ProseMirror-focused\" : \"\") +\n\t    (view.state.selection.node ? \" ProseMirror-nodeselection\" : \"\")\n\t  attrs.contenteditable = String(view.editable)\n\t\n\t  view.someProp(\"attributes\", function (value) {\n\t    if (typeof value == \"function\") { value = value(view.state) }\n\t    if (value) { for (var attr in value) {\n\t      if (attr == \"class\")\n\t        { attrs.class += \" \" + value[attr] }\n\t      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n\t        { attrs[attr] = String(value[attr]) }\n\t    } }\n\t  })\n\t\n\t  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n\t}\n\t\n\tfunction getEditable(view) {\n\t  return !view.someProp(\"editable\", function (value) { return value(view.state) === false; })\n\t}\n\t\n\t// EditorProps:: interface\n\t//\n\t// The configuration object that can be passed to an editor view. It\n\t// supports the following properties (only `state` is required).\n\t//\n\t// The various event-handling functions may all return `true` to\n\t// indicate that they handled the given event. The view will then take\n\t// care to call `preventDefault` on the event, except with\n\t// `handleDOMEvents`, where the handler itself is responsible for that.\n\t//\n\t// Except for `state` and `dispatchTransaction`, these may also be\n\t// present on the `props` property of plugins. How a prop is resolved\n\t// depends on the prop. Handler functions are called one at a time,\n\t// starting with the plugins (in order of appearance), and finally\n\t// looking at the base props, until one of them returns true. For some\n\t// props, the first plugin that yields a value gets precedence. For\n\t// `class`, all the classes returned are combined.\n\t//\n\t//   state:: EditorState\n\t//   The state of the editor.\n\t//\n\t//   dispatchTransaction:: ?(tr: Transaction)\n\t//   The callback over which to send transactions (state updates)\n\t//   produced by the view. You'll usually want to make sure this ends\n\t//   up calling the view's\n\t//   [`updateState`](#view.EditorView.updateState) method with a new\n\t//   state that has the transaction\n\t//   [applied](#state.EditorState.apply).\n\t//\n\t//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n\t//   Can be an object mapping DOM event type names to functions that\n\t//   handle them. Such functions will be called before any handling\n\t//   ProseMirror does of events fired on the editable DOM element.\n\t//   Contrary to the other event handling props, when returning true\n\t//   from such a function, you are responsible for calling\n\t//   `preventDefault` yourself (or not, if you want to allow the\n\t//   default behavior).\n\t//\n\t//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n\t//   Called when the editor receives a `keydown` event.\n\t//\n\t//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n\t//   Handler for `keypress` events.\n\t//\n\t//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n\t//   Whenever the user directly input text, this handler is called\n\t//   before the input is applied. If it returns `true`, the default\n\t//   effect of actually inserting the text is suppressed.\n\t//\n\t//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n\t//   Called for each node around a click, from the inside out. The\n\t//   `direct` flag will be true for the inner node.\n\t//\n\t//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n\t//   Called when the editor is clicked, after `handleClickOn` handlers\n\t//   have been called.\n\t//\n\t//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n\t//   Called for each node around a double click.\n\t//\n\t//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n\t//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n\t//\n\t//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n\t//   Called for each node around a triple click.\n\t//\n\t//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n\t//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n\t//\n\t//   handleContextMenu:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n\t//   Called when a context menu event is fired in the editor.\n\t//\n\t//   onFocus:: ?(view: EditorView, event: dom.Event)\n\t//   Called when the editor is focused.\n\t//\n\t//   onBlur:: ?(view: EditorView, event: dom.Event)\n\t//   Called when the editor loses focus.\n\t//\n\t//   domParser:: ?DOMParser\n\t//   The [parser](#model.DOMParser) to use when reading editor changes\n\t//   from the DOM. Defaults to calling\n\t//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n\t//   editor's schema.\n\t//\n\t//   clipboardParser:: ?DOMParser\n\t//   The [parser](#model.DOMParser) to use when reading content from\n\t//   the clipboard. When not given, the value of the\n\t//   [`domParser`](#view.EditorProps.domParser) prop is used.\n\t//\n\t//   transformPasted:: ?(Slice) → Slice\n\t//   Can be used to transform pasted content before it is applied to\n\t//   the document.\n\t//\n\t//   transformPastedHTML:: ?(string) → string\n\t//   Can be used to transform pasted HTML text, _before_ it is parsed,\n\t//   for example to clean it up.\n\t//\n\t//   transformPastedText:: ?(string) → string\n\t//   Transform pasted plain text.\n\t//\n\t//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration]) → NodeView>\n\t//   Allows you to pass custom rendering and behavior logic for nodes\n\t//   and marks. Should map node and mark names to constructor function\n\t//   that produce a [`NodeView`](#view.NodeView) object implementing\n\t//   the node's display behavior. `getPos` is a function that can be\n\t//   called to get the node's current position, which can be useful\n\t//   when creating transactions that update it.\n\t//\n\t//   `decorations` is an array of node or inline decorations that are\n\t//   active around the node. They are automatically drawn in the\n\t//   normal way, and you will usually just want to ignore this, but\n\t//   they can also be used as a way to provide context information to\n\t//   the node view without adding it to the document itself.\n\t//\n\t//   clipboardSerializer:: ?DOMSerializer\n\t//   The DOM serializer to use when putting content onto the\n\t//   clipboard. If not given, the result of\n\t//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n\t//   will be used.\n\t//\n\t//   decorations:: (EditorState) → ?DecorationSet\n\t//   A set of [document decorations](#view.Decoration) to add to the\n\t//   view.\n\t//\n\t//   editable:: ?(EditorState) → bool\n\t//   When this returns false, the content of the view is not directly\n\t//   editable.\n\t//\n\t//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n\t//   Control the DOM attributes of the editable element. May be either\n\t//   an object or a function going from an editor state to an object.\n\t//   By default, the element will get a class `\"ProseMirror\"`, and\n\t//   will have its `contentEditable` attribute determined by the\n\t//   [`editable` prop](#view.EditorProps.editable). Additional classes\n\t//   provided here will be added to the class. For other attributes,\n\t//   the value provided first (as in\n\t//   [`someProp`](#view.EditorView.someProp)) will be used.\n\t//\n\t//   scrollThreshold:: ?number\n\t//   Determines the distance (in pixels) between the cursor and the\n\t//   end of the visible viewport at which point, when scrolling the\n\t//   cursor into view, scrolling takes place. Defaults to 0.\n\t//\n\t//   scrollMargin:: ?number\n\t//   Determines the extra space (in pixels) that is left above or\n\t//   below the cursor when it is scrolled into view. Defaults to 5.\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(85), __esModule: true };\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(87);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(23)\n\t  , document = __webpack_require__(8).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(36);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(104)\n\t  , enumBugKeys = __webpack_require__(39);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(13).f\n\t  , has = __webpack_require__(11)\n\t  , TAG = __webpack_require__(3)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(8)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(40)\n\t  , defined = __webpack_require__(20);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(27)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Copyright (C) 2012 Kory Nunn\r\n\t\r\n\t//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\t\r\n\t//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\t\r\n\t//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\t\r\n\t/*\r\n\t\r\n\t    This code is not formatted for readability, but rather run-speed and to assist compilers.\r\n\t\r\n\t    However, the code's intention should be transparent.\r\n\t\r\n\t    *** IE SUPPORT ***\r\n\t\r\n\t    If you require this library to work in IE7, add the following after declaring crel.\r\n\t\r\n\t    var testDiv = document.createElement('div'),\r\n\t        testLabel = document.createElement('label');\r\n\t\r\n\t    testDiv.setAttribute('class', 'a');\r\n\t    testDiv['className'] !== 'a' ? crel.attrMap['class'] = 'className':undefined;\r\n\t    testDiv.setAttribute('name','a');\r\n\t    testDiv['name'] !== 'a' ? crel.attrMap['name'] = function(element, value){\r\n\t        element.id = value;\r\n\t    }:undefined;\r\n\t\r\n\t\r\n\t    testLabel.setAttribute('for', 'a');\r\n\t    testLabel['htmlFor'] !== 'a' ? crel.attrMap['for'] = 'htmlFor':undefined;\r\n\t\r\n\t\r\n\t\r\n\t*/\r\n\t\r\n\t(function (root, factory) {\r\n\t    if (true) {\r\n\t        module.exports = factory();\r\n\t    } else if (typeof define === 'function' && define.amd) {\r\n\t        define(factory);\r\n\t    } else {\r\n\t        root.crel = factory();\r\n\t    }\r\n\t}(this, function () {\r\n\t    var fn = 'function',\r\n\t        obj = 'object',\r\n\t        nodeType = 'nodeType',\r\n\t        textContent = 'textContent',\r\n\t        setAttribute = 'setAttribute',\r\n\t        attrMapString = 'attrMap',\r\n\t        isNodeString = 'isNode',\r\n\t        isElementString = 'isElement',\r\n\t        d = typeof document === obj ? document : {},\r\n\t        isType = function(a, type){\r\n\t            return typeof a === type;\r\n\t        },\r\n\t        isNode = typeof Node === fn ? function (object) {\r\n\t            return object instanceof Node;\r\n\t        } :\r\n\t        // in IE <= 8 Node is an object, obviously..\r\n\t        function(object){\r\n\t            return object &&\r\n\t                isType(object, obj) &&\r\n\t                (nodeType in object) &&\r\n\t                isType(object.ownerDocument,obj);\r\n\t        },\r\n\t        isElement = function (object) {\r\n\t            return crel[isNodeString](object) && object[nodeType] === 1;\r\n\t        },\r\n\t        isArray = function(a){\r\n\t            return a instanceof Array;\r\n\t        },\r\n\t        appendChild = function(element, child) {\r\n\t          if(!crel[isNodeString](child)){\r\n\t              child = d.createTextNode(child);\r\n\t          }\r\n\t          element.appendChild(child);\r\n\t        };\r\n\t\r\n\t\r\n\t    function crel(){\r\n\t        var args = arguments, //Note: assigned to a variable to assist compilers. Saves about 40 bytes in closure compiler. Has negligable effect on performance.\r\n\t            element = args[0],\r\n\t            child,\r\n\t            settings = args[1],\r\n\t            childIndex = 2,\r\n\t            argumentsLength = args.length,\r\n\t            attributeMap = crel[attrMapString];\r\n\t\r\n\t        element = crel[isElementString](element) ? element : d.createElement(element);\r\n\t        // shortcut\r\n\t        if(argumentsLength === 1){\r\n\t            return element;\r\n\t        }\r\n\t\r\n\t        if(!isType(settings,obj) || crel[isNodeString](settings) || isArray(settings)) {\r\n\t            --childIndex;\r\n\t            settings = null;\r\n\t        }\r\n\t\r\n\t        // shortcut if there is only one child that is a string\r\n\t        if((argumentsLength - childIndex) === 1 && isType(args[childIndex], 'string') && element[textContent] !== undefined){\r\n\t            element[textContent] = args[childIndex];\r\n\t        }else{\r\n\t            for(; childIndex < argumentsLength; ++childIndex){\r\n\t                child = args[childIndex];\r\n\t\r\n\t                if(child == null){\r\n\t                    continue;\r\n\t                }\r\n\t\r\n\t                if (isArray(child)) {\r\n\t                  for (var i=0; i < child.length; ++i) {\r\n\t                    appendChild(element, child[i]);\r\n\t                  }\r\n\t                } else {\r\n\t                  appendChild(element, child);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        for(var key in settings){\r\n\t            if(!attributeMap[key]){\r\n\t                element[setAttribute](key, settings[key]);\r\n\t            }else{\r\n\t                var attr = attributeMap[key];\r\n\t                if(typeof attr === fn){\r\n\t                    attr(element, settings[key]);\r\n\t                }else{\r\n\t                    element[setAttribute](attr, settings[key]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return element;\r\n\t    }\r\n\t\r\n\t    // Used for mapping one kind of attribute to the supported version of that in bad browsers.\r\n\t    crel[attrMapString] = {};\r\n\t\r\n\t    crel[isElementString] = isElement;\r\n\t\r\n\t    crel[isNodeString] = isNode;\r\n\t\r\n\t    if(typeof Proxy !== 'undefined'){\r\n\t        crel.proxy = new Proxy(crel, {\r\n\t            get: function(target, key){\r\n\t                !(key in crel) && (crel[key] = crel.bind(null, key));\r\n\t                return crel[key];\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t\r\n\t    return crel;\r\n\t}));\r\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;var assign;\n\t((assign = __webpack_require__(30), exports.InputRule = assign.InputRule, exports.inputRules = assign.inputRules))\n\t;var assign$1;\n\t((assign$1 = __webpack_require__(140), exports.emDash = assign$1.emDash, exports.ellipsis = assign$1.ellipsis, exports.openDoubleQuote = assign$1.openDoubleQuote, exports.closeDoubleQuote = assign$1.closeDoubleQuote, exports.openSingleQuote = assign$1.openSingleQuote, exports.closeSingleQuote = assign$1.closeSingleQuote, exports.smartQuotes = assign$1.smartQuotes, exports.allInputRules = assign$1.allInputRules))\n\t;var assign$2;\n\t((assign$2 = __webpack_require__(141), exports.wrappingInputRule = assign$2.wrappingInputRule, exports.textblockTypeInputRule = assign$2.textblockTypeInputRule, exports.blockQuoteRule = assign$2.blockQuoteRule, exports.orderedListRule = assign$2.orderedListRule, exports.bulletListRule = assign$2.bulletListRule, exports.codeBlockRule = assign$2.codeBlockRule, exports.headingRule = assign$2.headingRule))\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar crel = __webpack_require__(47)\n\tvar ref = __webpack_require__(14);\n\tvar lift = ref.lift;\n\tvar joinUp = ref.joinUp;\n\tvar selectParentNode = ref.selectParentNode;\n\tvar wrapIn = ref.wrapIn;\n\tvar setBlockType = ref.setBlockType;\n\tvar ref$1 = __webpack_require__(29);\n\tvar undo = ref$1.undo;\n\tvar redo = ref$1.redo;\n\t\n\tvar ref$2 = __webpack_require__(143);\n\tvar getIcon = ref$2.getIcon;\n\t\n\tvar prefix = \"ProseMirror-menu\"\n\t\n\t// ::- An icon or label that, when clicked, executes a command.\n\tvar MenuItem = function MenuItem(spec) {\n\t  // :: MenuItemSpec\n\t  // The spec used to create the menu item.\n\t  this.spec = spec\n\t};\n\t\n\t// :: (EditorView) → dom.Node\n\t// Renders the icon according to its [display\n\t// spec](#menu.MenuItemSpec.display), and adds an event handler which\n\t// executes the command when the representation is clicked.\n\tMenuItem.prototype.render = function render (view) {\n\t  var disabled = false, spec = this.spec\n\t  if (spec.select && !spec.select(view.state)) {\n\t    if (spec.onDeselected == \"disable\") { disabled = true }\n\t    else { return null }\n\t  }\n\t  var active = spec.active && !disabled && spec.active(view.state)\n\t\n\t  var dom\n\t  if (spec.render) {\n\t    dom = spec.render(view)\n\t  } else if (spec.icon) {\n\t    dom = getIcon(spec.icon)\n\t    if (active) { dom.classList.add(prefix + \"-active\") }\n\t  } else if (spec.label) {\n\t    dom = crel(\"div\", null, translate(view, spec.label))\n\t  } else {\n\t    throw new RangeError(\"MenuItem without render, icon, or label property\")\n\t  }\n\t\n\t  if (spec.title) { dom.setAttribute(\"title\", translate(view, spec.title)) }\n\t  if (spec.class) { dom.classList.add(spec.class) }\n\t  if (disabled) { dom.classList.add(prefix + \"-disabled\") }\n\t  if (spec.css) { dom.style.cssText += spec.css }\n\t  if (!disabled) { dom.addEventListener(spec.execEvent || \"mousedown\", function (e) {\n\t    e.preventDefault()\n\t    spec.run(view.state, view.dispatch, view)\n\t  }) }\n\t  return dom\n\t};\n\texports.MenuItem = MenuItem\n\t\n\tfunction translate(view, text) {\n\t  return view.props.translate ? view.props.translate(text) : text\n\t}\n\t\n\t// MenuItemSpec:: interface\n\t// The configuration object passed to the `MenuItem` constructor.\n\t//\n\t//   run:: (EditorState, (Transaction), EditorView)\n\t//   The function to execute when the menu item is activated.\n\t//\n\t//   select:: ?(EditorState) → bool\n\t//   Optional function that is used to determine whether the item is\n\t//   appropriate at the moment.\n\t//\n\t//   onDeselect:: ?string\n\t//   Determines what happens when [`select`](#menu.MenuItemSpec.select)\n\t//   returns false. The default is to hide the item, you can set this to\n\t//   `\"disable\"` to instead render the item with a disabled style.\n\t//\n\t//   active:: ?(EditorState) → bool\n\t//   A predicate function to determine whether the item is 'active' (for\n\t//   example, the item for toggling the strong mark might be active then\n\t//   the cursor is in strong text).\n\t//\n\t//   render:: ?(EditorView) → dom.Node\n\t//   A function that renders the item. You must provide either this,\n\t//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).\n\t//\n\t//   icon:: ?Object\n\t//   Describes an icon to show for this item. The object may specify\n\t//   an SVG icon, in which case its `path` property should be an [SVG\n\t//   path\n\t//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),\n\t//   and `width` and `height` should provide the viewbox in which that\n\t//   path exists. Alternatively, it may have a `text` property\n\t//   specifying a string of text that makes up the icon, with an\n\t//   optional `css` property giving additional CSS styling for the\n\t//   text. _Or_ it may contain `dom` property containing a DOM node.\n\t//\n\t//   label:: ?string\n\t//   Makes the item show up as a text label. Mostly useful for items\n\t//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object\n\t//   should have a `label` property providing the text to display.\n\t//\n\t//   title:: ?string\n\t//   Defines DOM title (mouseover) text for the item.\n\t//\n\t//   class:: string\n\t//   Optionally adds a CSS class to the item's DOM representation.\n\t//\n\t//   css:: string\n\t//   Optionally adds a string of inline CSS to the item's DOM\n\t//   representation.\n\t//\n\t//   execEvent:: string\n\t//   Defines which event on the command's DOM representation should\n\t//   trigger the execution of the command. Defaults to mousedown.\n\t\n\tvar lastMenuEvent = {time: 0, node: null}\n\tfunction markMenuEvent(e) {\n\t  lastMenuEvent.time = Date.now()\n\t  lastMenuEvent.node = e.target\n\t}\n\tfunction isMenuEvent(wrapper) {\n\t  return Date.now() - 100 < lastMenuEvent.time &&\n\t    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)\n\t}\n\t\n\t// ::- A drop-down menu, displayed as a label with a downwards-pointing\n\t// triangle to the right of it.\n\tvar Dropdown = function Dropdown(content, options) {\n\t  this.options = options || {}\n\t  this.content = Array.isArray(content) ? content : [content]\n\t};\n\t\n\t// :: (EditorView) → dom.Node\n\t// Returns a node showing the collapsed menu, which expands when clicked.\n\tDropdown.prototype.render = function render (view) {\n\t    var this$1 = this;\n\t\n\t  var items = renderDropdownItems(this.content, view)\n\t  if (!items.length) { return null }\n\t\n\t  var label = crel(\"div\", {class: prefix + \"-dropdown \" + (this.options.class || \"\"),\n\t                           style: this.options.css,\n\t                           title: this.options.title && translate(view, this.options.title)},\n\t                  translate(view, this.options.label))\n\t  var wrap = crel(\"div\", {class: prefix + \"-dropdown-wrap\"}, label)\n\t  var open = null, listeningOnClose = null\n\t  var close = function () {\n\t    if (open && open.close()) {\n\t      open = null\n\t      window.removeEventListener(\"mousedown\", listeningOnClose)\n\t    }\n\t  }\n\t  label.addEventListener(\"mousedown\", function (e) {\n\t    e.preventDefault()\n\t    markMenuEvent(e)\n\t    if (open) {\n\t      close()\n\t    } else {\n\t      open = this$1.expand(wrap, items)\n\t      window.addEventListener(\"mousedown\", listeningOnClose = function () {\n\t        if (!isMenuEvent(wrap)) { close() }\n\t      })\n\t    }\n\t  })\n\t  return wrap\n\t};\n\t\n\tDropdown.prototype.expand = function expand (dom, items) {\n\t  var menuDOM = crel(\"div\", {class: prefix + \"-dropdown-menu \" + (this.options.class || \"\")}, items)\n\t\n\t  var done = false\n\t  function close() {\n\t    if (done) { return }\n\t    done = true\n\t    dom.removeChild(menuDOM)\n\t    return true\n\t  }\n\t  dom.appendChild(menuDOM)\n\t  return {close: close, node: menuDOM}\n\t};\n\texports.Dropdown = Dropdown\n\t\n\tfunction renderDropdownItems(items, view) {\n\t  var rendered = []\n\t  for (var i = 0; i < items.length; i++) {\n\t    var inner = items[i].render(view)\n\t    if (inner) { rendered.push(crel(\"div\", {class: prefix + \"-dropdown-item\"}, inner)) }\n\t  }\n\t  return rendered\n\t}\n\t\n\t// ::- Represents a submenu wrapping a group of elements that start\n\t// hidden and expand to the right when hovered over or tapped.\n\tvar DropdownSubmenu = function DropdownSubmenu(content, options) {\n\t  this.options = options || {}\n\t  this.content = Array.isArray(content) ? content : [content]\n\t};\n\t\n\t// :: (EditorView) → dom.Node\n\t// Renders the submenu.\n\tDropdownSubmenu.prototype.render = function render (view) {\n\t  var items = renderDropdownItems(this.content, view)\n\t  if (!items.length) { return null }\n\t\n\t  var label = crel(\"div\", {class: prefix + \"-submenu-label\"}, translate(view, this.options.label))\n\t  var wrap = crel(\"div\", {class: prefix + \"-submenu-wrap\"}, label,\n\t                 crel(\"div\", {class: prefix + \"-submenu\"}, items))\n\t  var listeningOnClose = null\n\t  label.addEventListener(\"mousedown\", function (e) {\n\t    e.preventDefault()\n\t    markMenuEvent(e)\n\t    wrap.classList.toggle(prefix + \"-submenu-wrap-active\")\n\t    if (!listeningOnClose)\n\t      { window.addEventListener(\"mousedown\", listeningOnClose = function () {\n\t        if (!isMenuEvent(wrap)) {\n\t          wrap.classList.remove(prefix + \"-submenu-wrap-active\")\n\t          window.removeEventListener(\"mousedown\", listeningOnClose)\n\t          listeningOnClose = null\n\t        }\n\t      }) }\n\t  })\n\t  return wrap\n\t};\n\texports.DropdownSubmenu = DropdownSubmenu\n\t\n\t// :: (EditorView, [union<MenuElement, [MenuElement]>]) → ?dom.DocumentFragment\n\t// Render the given, possibly nested, array of menu elements into a\n\t// document fragment, placing separators between them (and ensuring no\n\t// superfluous separators appear when some of the groups turn out to\n\t// be empty).\n\tfunction renderGrouped(view, content) {\n\t  var result = document.createDocumentFragment(), needSep = false\n\t  for (var i = 0; i < content.length; i++) {\n\t    var items = content[i], added = false\n\t    for (var j = 0; j < items.length; j++) {\n\t      var rendered = items[j].render(view)\n\t      if (rendered) {\n\t        if (!added && needSep) { result.appendChild(separator()) }\n\t        result.appendChild(crel(\"span\", {class: prefix + \"item\"}, rendered))\n\t        added = true\n\t      }\n\t    }\n\t    if (added) { needSep = true }\n\t  }\n\t  return result\n\t}\n\texports.renderGrouped = renderGrouped\n\t\n\tfunction separator() {\n\t  return crel(\"span\", {class: prefix + \"separator\"})\n\t}\n\t\n\t// :: Object\n\t// A set of basic editor-related icons. Contains the properties\n\t// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,\n\t// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each\n\t// holding an object that can be used as the `icon` option to\n\t// `MenuItem`.\n\tvar icons = {\n\t  join: {\n\t    width: 800, height: 900,\n\t    path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n\t  },\n\t  lift: {\n\t    width: 1024, height: 1024,\n\t    path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n\t  },\n\t  selectParentNode: {text: \"\\u2b1a\", css: \"font-weight: bold\"},\n\t  undo: {\n\t    width: 1024, height: 1024,\n\t    path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n\t  },\n\t  redo: {\n\t    width: 1024, height: 1024,\n\t    path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n\t  },\n\t  strong: {\n\t    width: 805, height: 1024,\n\t    path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n\t  },\n\t  em: {\n\t    width: 585, height: 1024,\n\t    path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n\t  },\n\t  code: {\n\t    width: 896, height: 1024,\n\t    path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n\t  },\n\t  link: {\n\t    width: 951, height: 1024,\n\t    path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n\t  },\n\t  bulletList: {\n\t    width: 768, height: 896,\n\t    path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n\t  },\n\t  orderedList: {\n\t    width: 768, height: 896,\n\t    path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n\t  },\n\t  blockquote: {\n\t    width: 640, height: 896,\n\t    path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n\t  }\n\t}\n\texports.icons = icons\n\t\n\t// :: MenuItem\n\t// Menu item for the `joinUp` command.\n\tvar joinUpItem = new MenuItem({\n\t  title: \"Join with above block\",\n\t  run: joinUp,\n\t  select: function (state) { return joinUp(state); },\n\t  icon: icons.join\n\t})\n\texports.joinUpItem = joinUpItem\n\t\n\t// :: MenuItem\n\t// Menu item for the `lift` command.\n\tvar liftItem = new MenuItem({\n\t  title: \"Lift out of enclosing block\",\n\t  run: lift,\n\t  select: function (state) { return lift(state); },\n\t  icon: icons.lift\n\t})\n\texports.liftItem = liftItem\n\t\n\t// :: MenuItem\n\t// Menu item for the `selectParentNode` command.\n\tvar selectParentNodeItem = new MenuItem({\n\t  title: \"Select parent node\",\n\t  run: selectParentNode,\n\t  select: function (state) { return selectParentNode(state); },\n\t  icon: icons.selectParentNode\n\t})\n\texports.selectParentNodeItem = selectParentNodeItem\n\t\n\t// :: (Object) → MenuItem\n\t// Menu item for the `undo` command.\n\tvar undoItem = new MenuItem({\n\t  title: \"Undo last change\",\n\t  run: undo,\n\t  select: function (state) { return undo(state); },\n\t  icon: icons.undo\n\t})\n\texports.undoItem = undoItem\n\t\n\t// :: (Object) → MenuItem\n\t// Menu item for the `redo` command.\n\tvar redoItem = new MenuItem({\n\t  title: \"Redo last undone change\",\n\t  run: redo,\n\t  select: function (state) { return redo(state); },\n\t  icon: icons.redo\n\t})\n\texports.redoItem = redoItem\n\t\n\t// :: (NodeType, Object) → MenuItem\n\t// Build a menu item for wrapping the selection in a given node type.\n\t// Adds `run` and `select` properties to the ones present in\n\t// `options`. `options.attrs` may be an object or a function, as in\n\t// `toggleMarkItem`.\n\tfunction wrapItem(nodeType, options) {\n\t  var passedOptions = {\n\t    run: function run(state, dispatch) {\n\t      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))\n\t      return wrapIn(nodeType, options.attrs)(state, dispatch)\n\t    },\n\t    select: function select(state) {\n\t      return wrapIn(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)\n\t    }\n\t  }\n\t  for (var prop in options) { passedOptions[prop] = options[prop] }\n\t  return new MenuItem(passedOptions)\n\t}\n\texports.wrapItem = wrapItem\n\t\n\t// :: (NodeType, Object) → MenuItem\n\t// Build a menu item for changing the type of the textblock around the\n\t// selection to the given type. Provides `run`, `active`, and `select`\n\t// properties. Others must be given in `options`. `options.attrs` may\n\t// be an object to provide the attributes for the textblock node.\n\tfunction blockTypeItem(nodeType, options) {\n\t  var command = setBlockType(nodeType, options.attrs)\n\t  var passedOptions = {\n\t    run: command,\n\t    select: function select(state) { return command(state) },\n\t    active: function active(state) {\n\t      var ref = state.selection;\n\t      var $from = ref.$from;\n\t      var to = ref.to;\n\t      var node = ref.node;\n\t      if (node) { return node.hasMarkup(nodeType, options.attrs) }\n\t      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)\n\t    }\n\t  }\n\t  for (var prop in options) { passedOptions[prop] = options[prop] }\n\t  return new MenuItem(passedOptions)\n\t}\n\texports.blockTypeItem = blockTypeItem\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\tfunction compareDeep(a, b) {\n\t  if (a === b) { return true }\n\t  if (!(a && typeof a == \"object\") ||\n\t      !(b && typeof b == \"object\")) { return false }\n\t  var array = Array.isArray(a)\n\t  if (Array.isArray(b) != array) { return false }\n\t  if (array) {\n\t    if (a.length != b.length) { return false }\n\t    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n\t  } else {\n\t    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n\t    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n\t  }\n\t  return true\n\t}\n\texports.compareDeep = compareDeep\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(5);\n\tvar Fragment = ref.Fragment;\n\tvar ref$1 = __webpack_require__(6);\n\tvar Mark = ref$1.Mark;\n\t\n\tvar ContentExpr = function(nodeType, elements, inlineContent) {\n\t  this.nodeType = nodeType\n\t  this.elements = elements\n\t  this.inlineContent = inlineContent\n\t};\n\t\n\tvar prototypeAccessors = { isLeaf: {} };\n\t\n\tprototypeAccessors.isLeaf.get = function () {\n\t  return this.elements.length == 0\n\t};\n\t\n\t// : (?Object) → ContentMatch\n\t// The content match at the start of this expression.\n\tContentExpr.prototype.start = function (attrs) {\n\t  return new ContentMatch(this, attrs, 0, 0)\n\t};\n\t\n\t// : (NodeType, ?Object, ?Object) → ?ContentMatch\n\t// Try to find a match that matches the given node, anywhere in the\n\t// expression. (Useful when synthesizing a match for a node that's\n\t// open to the left.)\n\tContentExpr.prototype.atType = function (parentAttrs, type, attrs, marks) {\n\t    var this$1 = this;\n\t    if ( marks === void 0 ) marks = Mark.none;\n\t\n\t  for (var i = 0; i < this.elements.length; i++)\n\t    { if (this$1.elements[i].matchesType(type, attrs, marks, parentAttrs, this$1))\n\t      { return new ContentMatch(this$1, parentAttrs, i, 0) } }\n\t};\n\t\n\tContentExpr.prototype.matches = function (attrs, fragment, from, to) {\n\t  return this.start(attrs).matchToEnd(fragment, from, to)\n\t};\n\t\n\t// Get a position in a known-valid fragment. If this is a simple\n\t// (single-element) expression, we don't have to do any matching,\n\t// and can simply skip to the position with count `index`.\n\tContentExpr.prototype.getMatchAt = function (attrs, fragment, index) {\n\t    if ( index === void 0 ) index = fragment.childCount;\n\t\n\t  if (this.elements.length == 1)\n\t    { return new ContentMatch(this, attrs, 0, index) }\n\t  else\n\t    { return this.start(attrs).matchFragment(fragment, 0, index) }\n\t};\n\t\n\tContentExpr.prototype.checkReplace = function (attrs, content, from, to, replacement, start, end) {\n\t    var this$1 = this;\n\t    if ( replacement === void 0 ) replacement = Fragment.empty;\n\t    if ( start === void 0 ) start = 0;\n\t    if ( end === void 0 ) end = replacement.childCount;\n\t\n\t  // Check for simple case, where the expression only has a single element\n\t  // (Optimization to avoid matching more than we need)\n\t  if (this.elements.length == 1) {\n\t    var elt = this.elements[0]\n\t    if (!checkCount(elt, content.childCount - (to - from) + (end - start), attrs, this)) { return false }\n\t    for (var i = start; i < end; i++) { if (!elt.matches(replacement.child(i), attrs, this$1)) { return false } }\n\t    return true\n\t  }\n\t\n\t  var match = this.getMatchAt(attrs, content, from).matchFragment(replacement, start, end)\n\t  return match ? match.matchToEnd(content, to) : false\n\t};\n\t\n\tContentExpr.prototype.checkReplaceWith = function (attrs, content, from, to, type, typeAttrs, marks) {\n\t  if (this.elements.length == 1) {\n\t    var elt = this.elements[0]\n\t    if (!checkCount(elt, content.childCount - (to - from) + 1, attrs, this)) { return false }\n\t    return elt.matchesType(type, typeAttrs, marks, attrs, this)\n\t  }\n\t\n\t  var match = this.getMatchAt(attrs, content, from).matchType(type, typeAttrs, marks)\n\t  return match ? match.matchToEnd(content, to) : false\n\t};\n\t\n\tContentExpr.prototype.compatible = function (other) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < this.elements.length; i++) {\n\t    var elt = this$1.elements[i]\n\t    for (var j = 0; j < other.elements.length; j++)\n\t      { if (other.elements[j].compatible(elt)) { return true } }\n\t  }\n\t  return false\n\t};\n\t\n\tContentExpr.prototype.generateContent = function (attrs) {\n\t  return this.start(attrs).fillBefore(Fragment.empty, true)\n\t};\n\t\n\tContentExpr.parse = function (nodeType, expr, specs) {\n\t  var elements = [], pos = 0, inline = null\n\t  for (;;) {\n\t    pos += /^\\s*/.exec(expr.slice(pos))[0].length\n\t    if (pos == expr.length) { break }\n\t\n\t    var types = /^(?:(\\w+)|\\(\\s*(\\w+(?:\\s*\\|\\s*\\w+)*)\\s*\\))/.exec(expr.slice(pos))\n\t    if (!types) { throw new SyntaxError(\"Invalid content expression '\" + expr + \"' at \" + pos) }\n\t    pos += types[0].length\n\t    var attrs = /^\\[([^\\]]+)\\]/.exec(expr.slice(pos))\n\t    if (attrs) { pos += attrs[0].length }\n\t    var marks = /^<(?:(_)|\\s*(\\w+(?:\\s+\\w+)*)\\s*)>/.exec(expr.slice(pos))\n\t    if (marks) { pos += marks[0].length }\n\t    var repeat = /^(?:([+*?])|\\{\\s*(\\d+|\\.\\w+)\\s*(,\\s*(\\d+|\\.\\w+)?)?\\s*\\})/.exec(expr.slice(pos))\n\t    if (repeat) { pos += repeat[0].length }\n\t\n\t    var nodeTypes = expandTypes(nodeType.schema, specs, types[1] ? [types[1]] : types[2].split(/\\s*\\|\\s*/))\n\t    for (var i = 0; i < nodeTypes.length; i++) {\n\t      if (inline == null) { inline = nodeTypes[i].isInline }\n\t      else if (inline != nodeTypes[i].isInline) { throw new SyntaxError(\"Mixing inline and block content in a single node\") }\n\t    }\n\t    var attrSet = !attrs ? null : parseAttrs(nodeType, attrs[1])\n\t    var markSet = !marks ? false : marks[1] ? true : checkMarks(nodeType.schema, marks[2].split(/\\s+/))\n\t    var ref = parseRepeat(nodeType, repeat);\n\t      var min = ref.min;\n\t      var max = ref.max;\n\t    if (min != 0 && (nodeTypes[0].hasRequiredAttrs(attrSet) || nodeTypes[0].isText))\n\t      { throw new SyntaxError(\"Node type \" + types[0] + \" in type \" + nodeType.name +\n\t                            \" is required, but has non-optional attributes\") }\n\t    var newElt = new ContentElement(nodeTypes, attrSet, markSet, min, max)\n\t    for (var i$1 = elements.length - 1; i$1 >= 0; i$1--) {\n\t      var prev = elements[i$1]\n\t      if (prev.min != prev.max && prev.overlaps(newElt))\n\t        { throw new SyntaxError(\"Possibly ambiguous overlapping adjacent content expressions in '\" + expr + \"'\") }\n\t      if (prev.min != 0) { break }\n\t    }\n\t    elements.push(newElt)\n\t  }\n\t\n\t  return new ContentExpr(nodeType, elements, !!inline)\n\t};\n\t\n\tObject.defineProperties( ContentExpr.prototype, prototypeAccessors );\n\texports.ContentExpr = ContentExpr\n\t\n\tvar ContentElement = function(nodeTypes, attrs, marks, min, max) {\n\t  this.nodeTypes = nodeTypes\n\t  this.attrs = attrs\n\t  this.marks = marks\n\t  this.min = min\n\t  this.max = max\n\t};\n\t\n\tContentElement.prototype.matchesType = function (type, attrs, marks, parentAttrs, parentExpr) {\n\t    var this$1 = this;\n\t\n\t  if (this.nodeTypes.indexOf(type) == -1) { return false }\n\t  if (this.attrs) {\n\t    if (!attrs) { return false }\n\t    for (var prop in this$1.attrs)\n\t      { if (attrs[prop] != resolveValue(this$1.attrs[prop], parentAttrs, parentExpr)) { return false } }\n\t  }\n\t  if (this.marks === true) { return true }\n\t  if (this.marks === false) { return marks.length == 0 }\n\t  for (var i = 0; i < marks.length; i++)\n\t    { if (this$1.marks.indexOf(marks[i].type) == -1) { return false } }\n\t  return true\n\t};\n\t\n\tContentElement.prototype.matches = function (node, parentAttrs, parentExpr) {\n\t  return this.matchesType(node.type, node.attrs, node.marks, parentAttrs, parentExpr)\n\t};\n\t\n\tContentElement.prototype.compatible = function (other) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < this.nodeTypes.length; i++)\n\t    { if (other.nodeTypes.indexOf(this$1.nodeTypes[i]) != -1) { return true } }\n\t  return false\n\t};\n\t\n\tContentElement.prototype.constrainedAttrs = function (parentAttrs, expr) {\n\t    var this$1 = this;\n\t\n\t  if (!this.attrs) { return null }\n\t  var attrs = Object.create(null)\n\t  for (var prop in this$1.attrs)\n\t    { attrs[prop] = resolveValue(this$1.attrs[prop], parentAttrs, expr) }\n\t  return attrs\n\t};\n\t\n\tContentElement.prototype.createFiller = function (parentAttrs, expr) {\n\t  var type = this.nodeTypes[0], attrs = type.computeAttrs(this.constrainedAttrs(parentAttrs, expr))\n\t  return type.create(attrs, type.contentExpr.generateContent(attrs))\n\t};\n\t\n\tContentElement.prototype.defaultType = function () {\n\t  var first = this.nodeTypes[0]\n\t  if (!(first.hasRequiredAttrs() || first.isText)) { return first }\n\t};\n\t\n\tContentElement.prototype.overlaps = function (other) {\n\t  return this.nodeTypes.some(function (t) { return other.nodeTypes.indexOf(t) > -1; })\n\t};\n\t\n\tContentElement.prototype.allowsMark = function (markType) {\n\t  return this.marks === true || this.marks && this.marks.indexOf(markType) > -1\n\t};\n\t\n\t// ::- Represents a partial match of a node type's [content\n\t// expression](#model.NodeSpec), and can be used to find out whether further\n\t// content matches here, and whether a given position is a valid end\n\t// of the parent node.\n\tvar ContentMatch = function(expr, attrs, index, count) {\n\t  this.expr = expr\n\t  this.attrs = attrs\n\t  this.index = index\n\t  this.count = count\n\t};\n\t\n\tvar prototypeAccessors$1 = { element: {},nextElement: {} };\n\t\n\tprototypeAccessors$1.element.get = function () { return this.expr.elements[this.index] };\n\t\n\tprototypeAccessors$1.nextElement.get = function () {\n\t    var this$1 = this;\n\t\n\t  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++) {\n\t    var element = this$1.expr.elements[i]\n\t    if (this$1.resolveValue(element.max) > count) { return element }\n\t    count = 0\n\t  }\n\t};\n\t\n\tContentMatch.prototype.move = function (index, count) {\n\t  return new ContentMatch(this.expr, this.attrs, index, count)\n\t};\n\t\n\tContentMatch.prototype.resolveValue = function (value) {\n\t  return value instanceof AttrValue ? resolveValue(value, this.attrs, this.expr) : value\n\t};\n\t\n\t// :: (Node) → ?ContentMatch\n\t// Match a node, returning a new match after the node if successful.\n\tContentMatch.prototype.matchNode = function (node) {\n\t  return this.matchType(node.type, node.attrs, node.marks)\n\t};\n\t\n\t// :: (NodeType, ?Object, [Mark]) → ?ContentMatch\n\t// Match a node type and marks, returning an match after that node\n\t// if successful.\n\tContentMatch.prototype.matchType = function (type, attrs, marks) {\n\t    var this$1 = this;\n\t    if ( marks === void 0 ) marks = Mark.none;\n\t\n\t  for (var ref = this, index = ref.index, count = ref.count; index < this.expr.elements.length; index++, count = 0) {\n\t    var elt = this$1.expr.elements[index], max = this$1.resolveValue(elt.max)\n\t    if (count < max && elt.matchesType(type, attrs, marks, this$1.attrs, this$1.expr)) {\n\t      count++\n\t      return this$1.move(index, count)\n\t    }\n\t    if (count < this$1.resolveValue(elt.min)) { return null }\n\t  }\n\t};\n\t\n\t// :: (Fragment, ?number, ?number) → ?union<ContentMatch, bool>\n\t// Try to match a fragment. Returns a new match when successful,\n\t// `null` when it ran into a required element it couldn't fit, and\n\t// `false` if it reached the end of the expression without\n\t// matching all nodes.\n\tContentMatch.prototype.matchFragment = function (fragment, from, to) {\n\t    var this$1 = this;\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = fragment.childCount;\n\t\n\t  if (from == to) { return this }\n\t  var fragPos = from, end = this.expr.elements.length\n\t  for (var ref = this, index = ref.index, count = ref.count; index < end; index++, count = 0) {\n\t    var elt = this$1.expr.elements[index], max = this$1.resolveValue(elt.max)\n\t\n\t    while (count < max && fragPos < to) {\n\t      if (elt.matches(fragment.child(fragPos), this$1.attrs, this$1.expr)) {\n\t        count++\n\t        if (++fragPos == to) { return this$1.move(index, count) }\n\t      } else {\n\t        break\n\t      }\n\t    }\n\t    if (count < this$1.resolveValue(elt.min)) { return null }\n\t  }\n\t  return false\n\t};\n\t\n\t// :: (Fragment, ?number, ?number) → bool\n\t// Returns true only if the fragment matches here, and reaches all\n\t// the way to the end of the content expression.\n\tContentMatch.prototype.matchToEnd = function (fragment, start, end) {\n\t  var matched = this.matchFragment(fragment, start, end)\n\t  return matched && matched.validEnd() || false\n\t};\n\t\n\t// :: () → bool\n\t// Returns true if this position represents a valid end of the\n\t// expression (no required content follows after it).\n\tContentMatch.prototype.validEnd = function () {\n\t    var this$1 = this;\n\t\n\t  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0)\n\t    { if (count < this$1.resolveValue(this$1.expr.elements[i].min)) { return false } }\n\t  return true\n\t};\n\t\n\t// :: (Fragment, bool, ?number) → ?Fragment\n\t// Try to match the given fragment, and if that fails, see if it can\n\t// be made to match by inserting nodes in front of it. When\n\t// successful, return a fragment of inserted nodes (which may be\n\t// empty if nothing had to be inserted). When `toEnd` is true, only\n\t// return a fragment if the resulting match goes to the end of the\n\t// content expression.\n\tContentMatch.prototype.fillBefore = function (after, toEnd, startIndex) {\n\t    var this$1 = this;\n\t\n\t  var added = [], match = this, index = startIndex || 0, end = this.expr.elements.length\n\t  for (;;) {\n\t    var fits = match.matchFragment(after, index)\n\t    if (fits && (!toEnd || fits.validEnd())) { return Fragment.from(added) }\n\t    if (fits === false) { return null } // Matched to end with content remaining\n\t\n\t    var elt = match.element\n\t    if (match.count < this$1.resolveValue(elt.min)) {\n\t      added.push(elt.createFiller(this$1.attrs, this$1.expr))\n\t      match = match.move(match.index, match.count + 1)\n\t    } else if (match.index < end) {\n\t      match = match.move(match.index + 1, 0)\n\t    } else if (after.childCount > index) {\n\t      return null\n\t    } else {\n\t      return Fragment.from(added)\n\t    }\n\t  }\n\t};\n\t\n\tContentMatch.prototype.possibleContent = function () {\n\t    var this$1 = this;\n\t\n\t  var found = []\n\t  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0) {\n\t    var elt = this$1.expr.elements[i], attrs = elt.constrainedAttrs(this$1.attrs, this$1.expr)\n\t    if (count < this$1.resolveValue(elt.max)) { for (var j = 0; j < elt.nodeTypes.length; j++) {\n\t      var type = elt.nodeTypes[j]\n\t      if (!type.hasRequiredAttrs(attrs) && !type.isText) { found.push({type: type, attrs: attrs}) }\n\t    } }\n\t    if (this$1.resolveValue(elt.min) > count) { break }\n\t  }\n\t  return found\n\t};\n\t\n\t// :: (MarkType) → bool\n\t// Check whether a node with the given mark type is allowed after\n\t// this position.\n\tContentMatch.prototype.allowsMark = function (markType) {\n\t  return this.element.allowsMark(markType)\n\t};\n\t\n\t// :: (NodeType, ?Object, ?[Mark]) → ?[{type: NodeType, attrs: Object}]\n\t// Find a set of wrapping node types that would allow a node of type\n\t// `target` with attributes `targetAttrs` to appear at this\n\t// position. The result may be empty (when it fits directly) and\n\t// will be null when no such wrapping exists.\n\tContentMatch.prototype.findWrapping = function (target, targetAttrs, targetMarks) {\n\t  var seen = Object.create(null), first = {match: this, via: null}, active = [first]\n\t  while (active.length) {\n\t    var current = active.shift(), match = current.match\n\t    if (match.matchType(target, targetAttrs, targetMarks)) {\n\t      var result = []\n\t      for (var obj = current; obj != first; obj = obj.via)\n\t        { result.push({type: obj.match.expr.nodeType, attrs: obj.match.attrs}) }\n\t      return result.reverse()\n\t    }\n\t    var possible = match.possibleContent()\n\t    for (var i = 0; i < possible.length; i++) {\n\t      var ref = possible[i];\n\t        var type = ref.type;\n\t        var attrs = ref.attrs;\n\t        var fullAttrs = type.computeAttrs(attrs)\n\t      if (!type.isLeaf && !(type.name in seen) &&\n\t          (current == first || match.matchType(type, fullAttrs).validEnd())) {\n\t        active.push({match: type.contentExpr.start(fullAttrs), via: current})\n\t        seen[type.name] = true\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t// :: (Node) → ?[{type: NodeType, attrs: Object}]\n\t// Call [`findWrapping`](#model.ContentMatch.findWrapping) with the\n\t// properties of the given node.\n\tContentMatch.prototype.findWrappingFor = function (node) {\n\t  return this.findWrapping(node.type, node.attrs, node.marks)\n\t};\n\t\n\tObject.defineProperties( ContentMatch.prototype, prototypeAccessors$1 );\n\texports.ContentMatch = ContentMatch\n\t\n\tvar AttrValue = function(attr) { this.attr = attr };\n\t\n\tfunction parseValue(nodeType, value) {\n\t  if (value.charAt(0) == \".\") {\n\t    var attr = value.slice(1)\n\t    if (!nodeType.attrs[attr]) { throw new SyntaxError(\"Node type \" + nodeType.name + \" has no attribute \" + attr) }\n\t    return new AttrValue(attr)\n\t  } else {\n\t    return JSON.parse(value)\n\t  }\n\t}\n\t\n\tfunction checkMarks(schema, marks) {\n\t  var found = []\n\t  for (var i = 0; i < marks.length; i++) {\n\t    var mark = schema.marks[marks[i]]\n\t    if (mark) { found.push(mark) }\n\t    else { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n\t  }\n\t  return found\n\t}\n\t\n\tfunction resolveValue(value, attrs, expr) {\n\t  if (!(value instanceof AttrValue)) { return value }\n\t  var attrVal = attrs && attrs[value.attr]\n\t  return attrVal !== undefined ? attrVal : expr.nodeType.defaultAttrs[value.attr]\n\t}\n\t\n\tfunction checkCount(elt, count, attrs, expr) {\n\t  return count >= resolveValue(elt.min, attrs, expr) &&\n\t    count <= resolveValue(elt.max, attrs, expr)\n\t}\n\t\n\tfunction expandTypes(schema, specs, types) {\n\t  var result = []\n\t  types.forEach(function (type) {\n\t    var found = schema.nodes[type]\n\t    if (found) {\n\t      if (result.indexOf(found) == -1) { result.push(found) }\n\t    } else {\n\t      specs.forEach(function (name, spec) {\n\t        if (spec.group && spec.group.split(\" \").indexOf(type) > -1) {\n\t          found = schema.nodes[name]\n\t          if (result.indexOf(found) == -1) { result.push(found) }\n\t        }\n\t      })\n\t    }\n\t    if (!found)\n\t      { throw new SyntaxError(\"Node type or group '\" + type + \"' does not exist\") }\n\t  })\n\t  return result\n\t}\n\t\n\tvar many = 2e9 // Big number representable as a 32-bit int\n\t\n\tfunction parseRepeat(nodeType, match) {\n\t  var min = 1, max = 1\n\t  if (match) {\n\t    if (match[1] == \"+\") {\n\t      max = many\n\t    } else if (match[1] == \"*\") {\n\t      min = 0\n\t      max = many\n\t    } else if (match[1] == \"?\") {\n\t      min = 0\n\t    } else if (match[2]) {\n\t      min = parseValue(nodeType, match[2])\n\t      if (match[3])\n\t        { max = match[4] ? parseValue(nodeType, match[4]) : many }\n\t      else\n\t        { max = min }\n\t    }\n\t    if (max == 0 || min > max)\n\t      { throw new SyntaxError(\"Invalid repeat count in '\" + match[0] + \"'\") }\n\t  }\n\t  return {min: min, max: max}\n\t}\n\t\n\tfunction parseAttrs(nodeType, expr) {\n\t  var parts = expr.split(/\\s*,\\s*/)\n\t  var attrs = Object.create(null)\n\t  for (var i = 0; i < parts.length; i++) {\n\t    var match = /^(\\w+)=(\\w+|\\\"(?:\\\\.|[^\\\\])*\\\"|\\.\\w+)$/.exec(parts[i])\n\t    if (!match) { throw new SyntaxError(\"Invalid attribute syntax: \" + parts[i]) }\n\t    attrs[match[1]] = parseValue(nodeType, match[2])\n\t  }\n\t  return attrs\n\t}\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(5);\n\tvar Fragment = ref.Fragment;\n\tvar ref$1 = __webpack_require__(6);\n\tvar Mark = ref$1.Mark;\n\tvar ref$2 = __webpack_require__(31);\n\tvar Slice = ref$2.Slice;\n\tvar replace = ref$2.replace;\n\tvar ref$3 = __webpack_require__(53);\n\tvar ResolvedPos = ref$3.ResolvedPos;\n\tvar ref$4 = __webpack_require__(50);\n\tvar compareDeep = ref$4.compareDeep;\n\t\n\tvar emptyAttrs = Object.create(null)\n\t\n\tvar warnedAboutMarksAt = false\n\t\n\t// ::- This class represents a node in the tree that makes up a\n\t// ProseMirror document. So a document is an instance of `Node`, with\n\t// children that are also instances of `Node`.\n\t//\n\t// Nodes are persistent data structures. Instead of changing them, you\n\t// create new ones with the content you want. Old ones keep pointing\n\t// at the old document shape. This is made cheaper by sharing\n\t// structure between the old and new data as much as possible, which a\n\t// tree shape like this (without back pointers) makes easy.\n\t//\n\t// **Never** directly mutate the properties of a `Node` object. See\n\t// [this guide](guide/doc.html) for more information.\n\tvar Node = function(type, attrs, content, marks) {\n\t  // :: NodeType\n\t  // The type of node that this is.\n\t  this.type = type\n\t\n\t  // :: Object\n\t  // An object mapping attribute names to values. The kind of\n\t  // attributes allowed and required are determined by the node\n\t  // type.\n\t  this.attrs = attrs\n\t\n\t  // :: Fragment\n\t  // A container holding the node's children.\n\t  this.content = content || Fragment.empty\n\t\n\t  // :: [Mark]\n\t  // The marks (things like whether it is emphasized or part of a\n\t  // link) associated with this node.\n\t  this.marks = marks || Mark.none\n\t};\n\t\n\tvar prototypeAccessors = { nodeSize: {},childCount: {},textContent: {},firstChild: {},lastChild: {},isBlock: {},isTextblock: {},isInline: {},isText: {},isLeaf: {} };\n\t\n\t// text:: ?string\n\t// For text nodes, this contains the node's text content.\n\t\n\t// :: number\n\t// The size of this node, as defined by the integer-based [indexing\n\t// scheme](guide/doc.html#indexing). For text nodes, this is the\n\t// amount of characters. For other leaf nodes, it is one. And for\n\t// non-leaf nodes, it is the size of the content plus two (the start\n\t// and end token).\n\tprototypeAccessors.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\t\n\t// :: number\n\t// The number of children that the node has.\n\tprototypeAccessors.childCount.get = function () { return this.content.childCount };\n\t\n\t// :: (number) → Node\n\t// Get the child node at the given index. Raises an error when the\n\t// index is out of range.\n\tNode.prototype.child = function (index) { return this.content.child(index) };\n\t\n\t// :: (number) → ?Node\n\t// Get the child node at the given index, if it exists.\n\tNode.prototype.maybeChild = function (index) { return this.content.maybeChild(index) };\n\t\n\t// :: ((node: Node, offset: number, index: number))\n\t// Call `f` for every child node, passing the node, its offset\n\t// into this parent node, and its index.\n\tNode.prototype.forEach = function (f) { this.content.forEach(f) };\n\t\n\t// :: (?number, ?number, (node: Node, pos: number, parent: Node, index: number))\n\t// Invoke a callback for all descendant nodes recursively between\n\t// the given two positions that are relative to start of this node's content.\n\t// The callback is invoked with the node, its parent-relative position,\n\t// its parent node, and its child index. If the callback returns false,\n\t// the current node's children will not be recursed over.\n\tNode.prototype.nodesBetween = function (from, to, f, pos) {\n\t    if ( pos === void 0 ) pos = 0;\n\t\n\t  this.content.nodesBetween(from, to, f, pos, this)\n\t};\n\t\n\t// :: ((node: Node, pos: number, parent: Node))\n\t// Call the given callback for every descendant node.\n\tNode.prototype.descendants = function (f) {\n\t  this.nodesBetween(0, this.content.size, f)\n\t};\n\t\n\t// :: string\n\t// Concatenates all the text nodes found in this fragment and its\n\t// children.\n\tprototypeAccessors.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\t\n\t// :: (number, number, ?string, ?string) → string\n\t// Get all text between positions `from` and `to`. When\n\t// `blockSeparator` is given, it will be inserted whenever a new\n\t// block node is started. When `leafText` is given, it'll be\n\t// inserted for every non-text leaf node encountered.\n\tNode.prototype.textBetween = function (from, to, blockSeparator, leafText) {\n\t  return this.content.textBetween(from, to, blockSeparator, leafText)\n\t};\n\t\n\t// :: ?Node\n\t// Returns this node's first child, or `null` if there are no\n\t// children.\n\tprototypeAccessors.firstChild.get = function () { return this.content.firstChild };\n\t\n\t// :: ?Node\n\t// Returns this node's last child, or `null` if there are no\n\t// children.\n\tprototypeAccessors.lastChild.get = function () { return this.content.lastChild };\n\t\n\t// :: (Node) → bool\n\t// Test whether two nodes represent the same content.\n\tNode.prototype.eq = function (other) {\n\t  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n\t};\n\t\n\t// :: (Node) → bool\n\t// Compare the markup (type, attributes, and marks) of this node to\n\t// those of another. Returns `true` if both have the same markup.\n\tNode.prototype.sameMarkup = function (other) {\n\t  return this.hasMarkup(other.type, other.attrs, other.marks)\n\t};\n\t\n\t// :: (NodeType, ?Object, ?[Mark]) → bool\n\t// Check whether this node's markup correspond to the given type,\n\t// attributes, and marks.\n\tNode.prototype.hasMarkup = function (type, attrs, marks) {\n\t  return this.type == type &&\n\t    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n\t    Mark.sameSet(this.marks, marks || Mark.none)\n\t};\n\t\n\t// :: (?Fragment) → Node\n\t// Create a new node with the same markup as this node, containing\n\t// the given content (or empty, if no content is given).\n\tNode.prototype.copy = function (content) {\n\t    if ( content === void 0 ) content = null;\n\t\n\t  if (content == this.content) { return this }\n\t  return new this.constructor(this.type, this.attrs, content, this.marks)\n\t};\n\t\n\t// :: ([Mark]) → Node\n\t// Create a copy of this node, with the given set of marks instead\n\t// of the node's own marks.\n\tNode.prototype.mark = function (marks) {\n\t  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n\t};\n\t\n\t// :: (number, ?number) → Node\n\t// Create a copy of this node with only the content between the\n\t// given offsets. If `to` is not given, it defaults to the end of\n\t// the node.\n\tNode.prototype.cut = function (from, to) {\n\t  if (from == 0 && to == this.content.size) { return this }\n\t  return this.copy(this.content.cut(from, to))\n\t};\n\t\n\t// :: (number, ?number) → Slice\n\t// Cut out the part of the document between the given positions, and\n\t// return it as a `Slice` object.\n\tNode.prototype.slice = function (from, to, includeParents) {\n\t    if ( to === void 0 ) to = this.content.size;\n\t    if ( includeParents === void 0 ) includeParents = false;\n\t\n\t  if (from == to) { return Slice.empty }\n\t\n\t  var $from = this.resolve(from), $to = this.resolve(to)\n\t  var depth = includeParents ? 0 : $from.sharedDepth(to)\n\t  var start = $from.start(depth), node = $from.node(depth)\n\t  var content = node.content.cut($from.pos - start, $to.pos - start)\n\t  return new Slice(content, $from.depth - depth, $to.depth - depth)\n\t};\n\t\n\t// :: (number, number, Slice) → Node\n\t// Replace the part of the document between the given positions with\n\t// the given slice. The slice must 'fit', meaning its open sides\n\t// must be able to connect to the surrounding content, and its\n\t// content nodes must be valid children for the node they are placed\n\t// into. If any of this is violated, an error of type\n\t// [`ReplaceError`](#model.ReplaceError) is thrown.\n\tNode.prototype.replace = function (from, to, slice) {\n\t  return replace(this.resolve(from), this.resolve(to), slice)\n\t};\n\t\n\t// :: (number) → ?Node\n\t// Find the node after the given position.\n\tNode.prototype.nodeAt = function (pos) {\n\t  for (var node = this;;) {\n\t    var ref = node.content.findIndex(pos);\n\t      var index = ref.index;\n\t      var offset = ref.offset;\n\t    node = node.maybeChild(index)\n\t    if (!node) { return null }\n\t    if (offset == pos || node.isText) { return node }\n\t    pos -= offset + 1\n\t  }\n\t};\n\t\n\t// :: (number) → {node: ?Node, index: number, offset: number}\n\t// Find the (direct) child node after the given offset, if any,\n\t// and return it along with its index and offset relative to this\n\t// node.\n\tNode.prototype.childAfter = function (pos) {\n\t  var ref = this.content.findIndex(pos);\n\t    var index = ref.index;\n\t    var offset = ref.offset;\n\t  return {node: this.content.maybeChild(index), index: index, offset: offset}\n\t};\n\t\n\t// :: (number) → {node: ?Node, index: number, offset: number}\n\t// Find the (direct) child node before the given offset, if any,\n\t// and return it along with its index and offset relative to this\n\t// node.\n\tNode.prototype.childBefore = function (pos) {\n\t  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n\t  var ref = this.content.findIndex(pos);\n\t    var index = ref.index;\n\t    var offset = ref.offset;\n\t  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n\t  var node = this.content.child(index - 1)\n\t  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n\t};\n\t\n\t// :: (number) → ResolvedPos\n\t// Resolve the given position in the document, returning an object\n\t// describing its path through the document.\n\tNode.prototype.resolve = function (pos) { return ResolvedPos.resolveCached(this, pos) };\n\t\n\tNode.prototype.resolveNoCache = function (pos) { return ResolvedPos.resolve(this, pos) };\n\t\n\tNode.prototype.marksAt = function (pos, useAfter) {\n\t  if (!warnedAboutMarksAt && typeof console != \"undefined\" && console.warn) {\n\t    warnedAboutMarksAt = true\n\t    console.warn(\"Node.marksAt is deprecated. Use ResolvedPos.marks instead.\")\n\t  }\n\t  return this.resolve(pos).marks(useAfter)\n\t};\n\t\n\t// :: (?number, ?number, MarkType) → bool\n\t// Test whether a mark of the given type occurs in this document\n\t// between the two given positions.\n\tNode.prototype.rangeHasMark = function (from, to, type) {\n\t  var found = false\n\t  this.nodesBetween(from, to, function (node) {\n\t    if (type.isInSet(node.marks)) { found = true }\n\t    return !found\n\t  })\n\t  return found\n\t};\n\t\n\t// :: bool\n\t// True when this is a block (non-inline node)\n\tprototypeAccessors.isBlock.get = function () { return this.type.isBlock };\n\t\n\t// :: bool\n\t// True when this is a textblock node, a block node with inline\n\t// content.\n\tprototypeAccessors.isTextblock.get = function () { return this.type.isTextblock };\n\t\n\t// :: bool\n\t// True when this is an inline node (a text node or a node that can\n\t// appear among text).\n\tprototypeAccessors.isInline.get = function () { return this.type.isInline };\n\t\n\t// :: bool\n\t// True when this is a text node.\n\tprototypeAccessors.isText.get = function () { return this.type.isText };\n\t\n\t// :: bool\n\t// True when this is a leaf node.\n\tprototypeAccessors.isLeaf.get = function () { return this.type.isLeaf };\n\t\n\t// :: () → string\n\t// Return a string representation of this node for debugging\n\t// purposes.\n\tNode.prototype.toString = function () {\n\t  var name = this.type.name\n\t  if (this.content.size)\n\t    { name += \"(\" + this.content.toStringInner() + \")\" }\n\t  return wrapMarks(this.marks, name)\n\t};\n\t\n\t// :: (number) → ContentMatch\n\t// Get the content match in this node at the given index.\n\tNode.prototype.contentMatchAt = function (index) {\n\t  return this.type.contentExpr.getMatchAt(this.attrs, this.content, index)\n\t};\n\t\n\t// :: (number, number, ?Fragment, ?number, ?number) → bool\n\t// Test whether replacing the range `from` to `to` (by index) with\n\t// the given replacement fragment (which defaults to the empty\n\t// fragment) would leave the node's content valid. You can\n\t// optionally pass `start` and `end` indices into the replacement\n\t// fragment.\n\tNode.prototype.canReplace = function (from, to, replacement, start, end) {\n\t  return this.type.contentExpr.checkReplace(this.attrs, this.content, from, to, replacement, start, end)\n\t};\n\t\n\t// :: (number, number, NodeType, ?[Mark]) → bool\n\t// Test whether replacing the range `from` to `to` (by index) with a\n\t// node of the given type with the given attributes and marks would\n\t// be valid.\n\tNode.prototype.canReplaceWith = function (from, to, type, attrs, marks) {\n\t  return this.type.contentExpr.checkReplaceWith(this.attrs, this.content, from, to, type, attrs, marks || Mark.none)\n\t};\n\t\n\t// :: (Node) → bool\n\t// Test whether the given node's content could be appended to this\n\t// node. If that node is empty, this will only return true if there\n\t// is at least one node type that can appear in both nodes (to avoid\n\t// merging completely incompatible nodes).\n\tNode.prototype.canAppend = function (other) {\n\t  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n\t  else { return this.type.compatibleContent(other.type) }\n\t};\n\t\n\tNode.prototype.defaultContentType = function (at) {\n\t  var elt = this.contentMatchAt(at).nextElement\n\t  return elt && elt.defaultType()\n\t};\n\t\n\t// :: () → Object\n\t// Return a JSON-serializeable representation of this node.\n\tNode.prototype.toJSON = function () {\n\t    var this$1 = this;\n\t\n\t  var obj = {type: this.type.name}\n\t  for (var _ in this$1.attrs) {\n\t    obj.attrs = this$1.attrs\n\t    break\n\t  }\n\t  if (this.content.size)\n\t    { obj.content = this.content.toJSON() }\n\t  if (this.marks.length)\n\t    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }) }\n\t  return obj\n\t};\n\t\n\t// :: (Schema, Object) → Node\n\t// Deserialize a node from its JSON representation.\n\tNode.fromJSON = function (schema, json) {\n\t  var marks = json.marks && json.marks.map(schema.markFromJSON)\n\t  if (json.type == \"text\") { return schema.text(json.text, marks) }\n\t  return schema.nodeType(json.type).create(json.attrs, Fragment.fromJSON(schema, json.content), marks)\n\t};\n\t\n\tObject.defineProperties( Node.prototype, prototypeAccessors );\n\texports.Node = Node\n\t\n\tvar TextNode = (function (Node) {\n\t  function TextNode(type, attrs, content, marks) {\n\t    Node.call(this, type, attrs, null, marks)\n\t\n\t    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\t\n\t    this.text = content\n\t  }\n\t\n\t  if ( Node ) TextNode.__proto__ = Node;\n\t  TextNode.prototype = Object.create( Node && Node.prototype );\n\t  TextNode.prototype.constructor = TextNode;\n\t\n\t  var prototypeAccessors$1 = { textContent: {},nodeSize: {} };\n\t\n\t  TextNode.prototype.toString = function () { return wrapMarks(this.marks, JSON.stringify(this.text)) };\n\t\n\t  prototypeAccessors$1.textContent.get = function () { return this.text };\n\t\n\t  TextNode.prototype.textBetween = function (from, to) { return this.text.slice(from, to) };\n\t\n\t  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\t\n\t  TextNode.prototype.mark = function (marks) {\n\t    return new TextNode(this.type, this.attrs, this.text, marks)\n\t  };\n\t\n\t  TextNode.prototype.withText = function (text) {\n\t    if (text == this.text) { return this }\n\t    return new TextNode(this.type, this.attrs, text, this.marks)\n\t  };\n\t\n\t  TextNode.prototype.cut = function (from, to) {\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = this.text.length;\n\t\n\t    if (from == 0 && to == this.text.length) { return this }\n\t    return this.withText(this.text.slice(from, to))\n\t  };\n\t\n\t  TextNode.prototype.eq = function (other) {\n\t    return this.sameMarkup(other) && this.text == other.text\n\t  };\n\t\n\t  TextNode.prototype.toJSON = function () {\n\t    var base = Node.prototype.toJSON.call(this)\n\t    base.text = this.text\n\t    return base\n\t  };\n\t\n\t  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\t\n\t  return TextNode;\n\t}(Node));\n\texports.TextNode = TextNode\n\t\n\tfunction wrapMarks(marks, str) {\n\t  for (var i = marks.length - 1; i >= 0; i--)\n\t    { str = marks[i].type.name + \"(\" + str + \")\" }\n\t  return str\n\t}\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(6);\n\tvar Mark = ref.Mark;\n\t\n\t// ::- You'll often have to '[resolve](#model.Node.resolve)' a\n\t// position to get the context you need. Objects of this class\n\t// represent such a resolved position, providing various pieces of\n\t// context information and helper methods.\n\t//\n\t// Throughout this interface, methods that take an optional `depth`\n\t// parameter will interpret undefined as `this.depth` and negative\n\t// numbers as `this.depth + value`.\n\tvar ResolvedPos = function(pos, path, parentOffset) {\n\t  // :: number The position that was resolved.\n\t  this.pos = pos\n\t  this.path = path\n\t  // :: number\n\t  // The number of levels the parent node is from the root. If this\n\t  // position points directly into the root, it is 0. If it points\n\t  // into a top-level paragraph, 1, and so on.\n\t  this.depth = path.length / 3 - 1\n\t  // :: number The offset this position has into its parent node.\n\t  this.parentOffset = parentOffset\n\t};\n\t\n\tvar prototypeAccessors = { parent: {},textOffset: {},nodeAfter: {},nodeBefore: {} };\n\t\n\tResolvedPos.prototype.resolveDepth = function (val) {\n\t  if (val == null) { return this.depth }\n\t  if (val < 0) { return this.depth + val }\n\t  return val\n\t};\n\t\n\t// :: Node\n\t// The parent node that the position points into. Note that even if\n\t// a position points into a text node, that node is not considered\n\t// the parent—text nodes are 'flat' in this model.\n\tprototypeAccessors.parent.get = function () { return this.node(this.depth) };\n\t\n\t// :: (?number) → Node\n\t// The ancestor node at the given level. `p.node(p.depth)` is the\n\t// same as `p.parent`.\n\tResolvedPos.prototype.node = function (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\t\n\t// :: (?number) → number\n\t// The index into the ancestor at the given level. If this points at\n\t// the 3rd node in the 2nd paragraph on the top level, for example,\n\t// `p.index(0)` is 2 and `p.index(1)` is 3.\n\tResolvedPos.prototype.index = function (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\t\n\t// :: (?number) → number\n\t// The index pointing after this position into the ancestor at the\n\t// given level.\n\tResolvedPos.prototype.indexAfter = function (depth) {\n\t  depth = this.resolveDepth(depth)\n\t  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n\t};\n\t\n\t// :: (?number) → number\n\t// The (absolute) position at the start of the node at the given\n\t// level.\n\tResolvedPos.prototype.start = function (depth) {\n\t  depth = this.resolveDepth(depth)\n\t  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n\t};\n\t\n\t// :: (?number) → number\n\t// The (absolute) position at the end of the node at the given\n\t// level.\n\tResolvedPos.prototype.end = function (depth) {\n\t  depth = this.resolveDepth(depth)\n\t  return this.start(depth) + this.node(depth).content.size\n\t};\n\t\n\t// :: (?number) → number\n\t// The (absolute) position directly before the node at the given\n\t// level, or, when `level` is `this.level + 1`, the original\n\t// position.\n\tResolvedPos.prototype.before = function (depth) {\n\t  depth = this.resolveDepth(depth)\n\t  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n\t  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n\t};\n\t\n\t// :: (?number) → number\n\t// The (absolute) position directly after the node at the given\n\t// level, or, when `level` is `this.level + 1`, the original\n\t// position.\n\tResolvedPos.prototype.after = function (depth) {\n\t  depth = this.resolveDepth(depth)\n\t  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n\t  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n\t};\n\t\n\t// :: number\n\t// When this position points into a text node, this returns the\n\t// distance between the position and the start of the text node.\n\t// Will be zero for positions that point between nodes.\n\tprototypeAccessors.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\t\n\t// :: ?Node\n\t// Get the node directly after the position, if any. If the position\n\t// points into a text node, only the part of that node after the\n\t// position is returned.\n\tprototypeAccessors.nodeAfter.get = function () {\n\t  var parent = this.parent, index = this.index(this.depth)\n\t  if (index == parent.childCount) { return null }\n\t  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n\t  return dOff ? parent.child(index).cut(dOff) : child\n\t};\n\t\n\t// :: ?Node\n\t// Get the node directly before the position, if any. If the\n\t// position points into a text node, only the part of that node\n\t// before the position is returned.\n\tprototypeAccessors.nodeBefore.get = function () {\n\t  var index = this.index(this.depth)\n\t  var dOff = this.pos - this.path[this.path.length - 1]\n\t  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n\t  return index == 0 ? null : this.parent.child(index - 1)\n\t};\n\t\n\t// :: (?bool) → [Mark]\n\t// Get the marks at this position, factoring in the surrounding\n\t// marks' inclusiveRight property. If the position is at the start\n\t// of a non-empty node, or `after` is true, the marks of the node\n\t// after it (if any) are returned.\n\tResolvedPos.prototype.marks = function (after) {\n\t  var parent = this.parent, index = this.index()\n\t\n\t  // In an empty parent, return the empty array\n\t  if (parent.content.size == 0) { return Mark.none }\n\t  // When inside a text node or at the start of the parent node, return the node's marks\n\t  if ((after && index < parent.childCount) || index == 0 || this.textOffset)\n\t    { return parent.child(index).marks }\n\t\n\t  var marks = parent.child(index - 1).marks\n\t  for (var i = 0; i < marks.length; i++) { if (marks[i].type.spec.inclusiveRight === false)\n\t    { marks = marks[i--].removeFromSet(marks) } }\n\t  return marks\n\t};\n\t\n\t// :: (number) → number\n\t// The depth up to which this position and the given (non-resolved)\n\t// position share the same parent nodes.\n\tResolvedPos.prototype.sharedDepth = function (pos) {\n\t    var this$1 = this;\n\t\n\t  for (var depth = this.depth; depth > 0; depth--)\n\t    { if (this$1.start(depth) <= pos && this$1.end(depth) >= pos) { return depth } }\n\t  return 0\n\t};\n\t\n\t// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n\t// Returns a range based on the place where this position and the\n\t// given position diverge around block content. If both point into\n\t// the same textblock, for example, a range around that textblock\n\t// will be returned. If they point into different blocks, the range\n\t// around those blocks or their ancestors in their common ancestor\n\t// is returned. You can pass in an optional predicate that will be\n\t// called with a parent node to see if a range into that parent is\n\t// acceptable.\n\tResolvedPos.prototype.blockRange = function (other, pred) {\n\t    var this$1 = this;\n\t    if ( other === void 0 ) other = this;\n\t\n\t  if (other.pos < this.pos) { return other.blockRange(this) }\n\t  for (var d = this.depth - (this.parent.isTextblock || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n\t    { if (other.pos <= this$1.end(d) && (!pred || pred(this$1.node(d))))\n\t      { return new NodeRange(this$1, other, d) } }\n\t};\n\t\n\t// :: (ResolvedPos) → bool\n\t// Query whether the given position shares the same parent node.\n\tResolvedPos.prototype.sameParent = function (other) {\n\t  return this.pos - this.parentOffset == other.pos - other.parentOffset\n\t};\n\t\n\tResolvedPos.prototype.toString = function () {\n\t    var this$1 = this;\n\t\n\t  var str = \"\"\n\t  for (var i = 1; i <= this.depth; i++)\n\t    { str += (str ? \"/\" : \"\") + this$1.node(i).type.name + \"_\" + this$1.index(i - 1) }\n\t  return str + \":\" + this.parentOffset\n\t};\n\t\n\tResolvedPos.resolve = function (doc, pos) {\n\t  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n\t  var path = []\n\t  var start = 0, parentOffset = pos\n\t  for (var node = doc;;) {\n\t    var ref = node.content.findIndex(parentOffset);\n\t      var index = ref.index;\n\t      var offset = ref.offset;\n\t    var rem = parentOffset - offset\n\t    path.push(node, index, start + offset)\n\t    if (!rem) { break }\n\t    node = node.child(index)\n\t    if (node.isText) { break }\n\t    parentOffset = rem - 1\n\t    start += offset + 1\n\t  }\n\t  return new ResolvedPos(pos, path, parentOffset)\n\t};\n\t\n\tResolvedPos.resolveCached = function (doc, pos) {\n\t  for (var i = 0; i < resolveCache.length; i++) {\n\t    var cached = resolveCache[i]\n\t    if (cached.pos == pos && cached.node(0) == doc) { return cached }\n\t  }\n\t  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n\t  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n\t  return result\n\t};\n\t\n\tObject.defineProperties( ResolvedPos.prototype, prototypeAccessors );\n\texports.ResolvedPos = ResolvedPos\n\t\n\tvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 6\n\t\n\t// ::- Represents a flat range of content.\n\tvar NodeRange = function($from, $to, depth) {\n\t  // :: ResolvedPos A resolved position along the start of the\n\t  // content. May have a `depth` greater than this object's `depth`\n\t  // property, since these are the positions that were used to\n\t  // compute the range, not re-resolved positions directly at its\n\t  // boundaries.\n\t  this.$from = $from\n\t  // :: ResolvedPos A position along the end of the content. See\n\t  // caveat for [`$from`](#model.NodeRange.$from).\n\t  this.$to = $to\n\t  // :: number The depth of the node that this range points into.\n\t  this.depth = depth\n\t};\n\t\n\tvar prototypeAccessors$1 = { start: {},end: {},parent: {},startIndex: {},endIndex: {} };\n\t\n\t// :: number The position at the start of the range.\n\tprototypeAccessors$1.start.get = function () { return this.$from.before(this.depth + 1) };\n\t// :: number The position at the end of the range.\n\tprototypeAccessors$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\t\n\t// :: Node The parent node that the range points into.\n\tprototypeAccessors$1.parent.get = function () { return this.$from.node(this.depth) };\n\t// :: number The start index of the range in the parent node.\n\tprototypeAccessors$1.startIndex.get = function () { return this.$from.index(this.depth) };\n\t// :: number The end index of the range in the parent node.\n\tprototypeAccessors$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\t\n\tObject.defineProperties( NodeRange.prototype, prototypeAccessors$1 );\n\texports.NodeRange = NodeRange\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(4);\n\tvar findWrapping = ref.findWrapping;\n\tvar liftTarget = ref.liftTarget;\n\tvar canSplit = ref.canSplit;\n\tvar ReplaceAroundStep = ref.ReplaceAroundStep;\n\tvar ref$1 = __webpack_require__(1);\n\tvar Slice = ref$1.Slice;\n\tvar Fragment = ref$1.Fragment;\n\tvar NodeRange = ref$1.NodeRange;\n\t\n\t// :: NodeSpec\n\t// An ordered list node type spec. Has a single attribute, `order`,\n\t// which determines the number at which the list starts counting, and\n\t// defaults to 1.\n\tvar orderedList = {\n\t  attrs: {order: {default: 1}},\n\t  parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n\t    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n\t  }}],\n\t  toDOM: function toDOM(node) {\n\t    return [\"ol\", {start: node.attrs.order == 1 ? null : node.attrs.order}, 0]\n\t  }\n\t}\n\texports.orderedList = orderedList\n\t\n\t// :: NodeSpec\n\t// A bullet list node spec.\n\tvar bulletList = {\n\t  parseDOM: [{tag: \"ul\"}],\n\t  toDOM: function toDOM() { return [\"ul\", 0] }\n\t}\n\texports.bulletList = bulletList\n\t\n\t// :: NodeSpec\n\t// A list item node spec.\n\tvar listItem = {\n\t  parseDOM: [{tag: \"li\"}],\n\t  toDOM: function toDOM() { return [\"li\", 0] },\n\t  defining: true\n\t}\n\texports.listItem = listItem\n\t\n\tfunction add(obj, props) {\n\t  var copy = {}\n\t  for (var prop in obj) { copy[prop] = obj[prop] }\n\t  for (var prop$1 in props) { copy[prop$1] = props[prop$1] }\n\t  return copy\n\t}\n\t\n\t// :: (OrderedMap, string, ?string) → OrderedMap\n\t// Convenience function for adding list-related node types to a map\n\t// describing the nodes in a schema. Adds `OrderedList` as\n\t// `\"ordered_list\"`, `BulletList` as `\"bullet_list\"`, and `ListItem`\n\t// as `\"list_item\"`. `itemContent` determines the content expression\n\t// for the list items. If you want the commands defined in this module\n\t// to apply to your list structure, it should have a shape like\n\t// `\"paragraph block*\"`, a plain textblock type followed by zero or\n\t// more arbitrary nodes. `listGroup` can be given to assign a group\n\t// name to the list node types, for example `\"block\"`.\n\tfunction addListNodes(nodes, itemContent, listGroup) {\n\t  return nodes.append({\n\t    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n\t    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n\t    list_item: add(listItem, {content: itemContent})\n\t  })\n\t}\n\texports.addListNodes = addListNodes\n\t\n\t// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Returns a command function that wraps the selection in a list with\n\t// the given type an attributes. If `apply` is `false`, only return a\n\t// value to indicate whether this is possible, but don't actually\n\t// perform the change.\n\tfunction wrapInList(nodeType, attrs) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var range = $from.blockRange($to), doJoin = false, outerRange = range\n\t    // This is at the top of an existing list item\n\t    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(nodeType) && range.startIndex == 0) {\n\t      // Don't do anything if this is the top of the list\n\t      if ($from.index(range.depth - 1) == 0) { return false }\n\t      var $insert = state.doc.resolve(range.start - 2)\n\t      outerRange = new NodeRange($insert, $insert, range.depth)\n\t      if (range.endIndex < range.parent.childCount)\n\t        { range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth) }\n\t      doJoin = true\n\t    }\n\t    var wrap = findWrapping(outerRange, nodeType, attrs, range)\n\t    if (!wrap) { return false }\n\t    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, nodeType).scrollIntoView()) }\n\t    return true\n\t  }\n\t}\n\texports.wrapInList = wrapInList\n\t\n\tfunction doWrapInList(tr, range, wrappers, joinBefore, nodeType) {\n\t  var content = Fragment.empty\n\t  for (var i = wrappers.length - 1; i >= 0; i--)\n\t    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)) }\n\t\n\t  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n\t                                new Slice(content, 0, 0), wrappers.length, true))\n\t\n\t  var found = 0\n\t  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == nodeType) { found = i$1 + 1 } }\n\t  var splitDepth = wrappers.length - found\n\t\n\t  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent\n\t  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n\t    if (!first && canSplit(tr.doc, splitPos, splitDepth)) { tr.split(splitPos, splitDepth) }\n\t    splitPos += parent.child(i$2).nodeSize + (first ? 0 : 2 * splitDepth)\n\t  }\n\t  return tr\n\t}\n\t\n\t// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Build a command that splits a non-empty textblock at the top level\n\t// of a list item by also splitting that list item.\n\tfunction splitListItem(nodeType) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var node = ref.node;\n\t    if ((node && node.isBlock) || !$from.parent.content.size ||\n\t        $from.depth < 2 || !$from.sameParent($to)) { return false }\n\t    var grandParent = $from.node(-1)\n\t    if (grandParent.type != nodeType) { return false }\n\t    var nextType = $to.pos == $from.end() ? grandParent.defaultContentType($from.indexAfter(-1)) : null\n\t    var tr = state.tr.delete($from.pos, $to.pos)\n\t    var types = nextType && [null, {type: nextType}]\n\t    if (!canSplit(tr.doc, $from.pos, 2, types)) { return false }\n\t    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()) }\n\t    return true\n\t  }\n\t}\n\texports.splitListItem = splitListItem\n\t\n\t// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Create a command to lift the list item around the selection up into\n\t// a wrapping list.\n\tfunction liftListItem(nodeType) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == nodeType; })\n\t    if (!range || range.depth < 2 || $from.node(range.depth - 1).type != nodeType) { return false }\n\t    if (dispatch) {\n\t      var tr = state.tr, end = range.end, endOfList = $to.end(range.depth)\n\t      if (end < endOfList) {\n\t        // There are siblings after the lifted items, which must become\n\t        // children of the last item\n\t        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n\t                                      new Slice(Fragment.from(nodeType.create(null, range.parent.copy())), 1, 0), 1, true))\n\t        range = new NodeRange(tr.doc.resolveNoCache($from.pos), tr.doc.resolveNoCache(endOfList), range.depth)\n\t      }\n\t      dispatch(tr.lift(range, liftTarget(range)).scrollIntoView())\n\t    }\n\t    return true\n\t  }\n\t}\n\texports.liftListItem = liftListItem\n\t\n\t// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Create a command to sink the list item around the selection down\n\t// into an inner list.\n\tfunction sinkListItem(nodeType) {\n\t  return function(state, dispatch) {\n\t    var ref = state.selection;\n\t    var $from = ref.$from;\n\t    var $to = ref.$to;\n\t    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == nodeType; })\n\t    if (!range) { return false }\n\t    var startIndex = range.startIndex\n\t    if (startIndex == 0) { return false }\n\t    var parent = range.parent, nodeBefore = parent.child(startIndex - 1)\n\t    if (nodeBefore.type != nodeType) { return false }\n\t\n\t    if (dispatch) {\n\t      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type\n\t      var inner = Fragment.from(nestedBefore ? nodeType.create() : null)\n\t      var slice = new Slice(Fragment.from(nodeType.create(null, Fragment.from(parent.copy(inner)))),\n\t                            nestedBefore ? 3 : 1, 0)\n\t      var before = range.start, after = range.end\n\t      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n\t                                                   before, after, slice, 1, true))\n\t               .scrollIntoView())\n\t    }\n\t    return true\n\t  }\n\t}\n\texports.sinkListItem = sinkListItem\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Fragment = ref.Fragment;\n\tvar Slice = ref.Slice;\n\tvar ref$1 = __webpack_require__(4);\n\tvar Step = ref$1.Step;\n\tvar StepResult = ref$1.StepResult;\n\tvar StepMap = ref$1.StepMap;\n\tvar ReplaceStep = ref$1.ReplaceStep;\n\tvar ref$2 = __webpack_require__(2);\n\tvar Selection = ref$2.Selection;\n\t\n\t// :: NodeSpec\n\t// A table node spec. Has one attribute, **`columns`**, which holds\n\t// a number indicating the amount of columns in the table.\n\tvar table = {\n\t  attrs: {columns: {default: 1}},\n\t  parseDOM: [{tag: \"table\", getAttrs: function getAttrs(dom) {\n\t    var row = dom.querySelector(\"tr\")\n\t    if (!row || !row.children.length) { return false }\n\t    // FIXME using the child count as column width is problematic\n\t    // when parsing document fragments\n\t    return {columns: row.children.length}\n\t  }}],\n\t  toDOM: function toDOM() { return [\"table\", [\"tbody\", 0]] }\n\t}\n\texports.table = table\n\t\n\t// :: NodeSpec\n\t// A table row node spec. Has one attribute, **`columns`**, which\n\t// holds a number indicating the amount of columns in the table.\n\tvar tableRow = {\n\t  attrs: {columns: {default: 1}},\n\t  parseDOM: [{tag: \"tr\", getAttrs: function (dom) { return dom.children.length ? {columns: dom.children.length} : false; }}],\n\t  toDOM: function toDOM() { return [\"tr\", 0] },\n\t  tableRow: true\n\t}\n\texports.tableRow = tableRow\n\t\n\t// :: NodeSpec\n\t// A table cell node spec.\n\tvar tableCell = {\n\t  parseDOM: [{tag: \"td\"}],\n\t  toDOM: function toDOM() { return [\"td\", 0] }\n\t}\n\texports.tableCell = tableCell\n\t\n\tfunction add(obj, props) {\n\t  var copy = {}\n\t  for (var prop in obj) { copy[prop] = obj[prop] }\n\t  for (var prop$1 in props) { copy[prop$1] = props[prop$1] }\n\t  return copy\n\t}\n\t\n\t// :: (OrderedMap, string, ?string) → OrderedMap\n\t// Convenience function for adding table-related node types to a map\n\t// describing the nodes in a schema. Adds `Table` as `\"table\"`,\n\t// `TableRow` as `\"table_row\"`, and `TableCell` as `\"table_cell\"`.\n\t// `cellContent` should be a content expression describing what may\n\t// occur inside cells.\n\tfunction addTableNodes(nodes, cellContent, tableGroup) {\n\t  return nodes.append({\n\t    table: add(table, {content: \"table_row[columns=.columns]+\", group: tableGroup}),\n\t    table_row: add(tableRow, {content: \"table_cell{.columns}\"}),\n\t    table_cell: add(tableCell, {content: cellContent})\n\t  })\n\t}\n\texports.addTableNodes = addTableNodes\n\t\n\t// :: (NodeType, number, number, ?Object) → Node\n\t// Create a table node with the given number of rows and columns.\n\tfunction createTable(nodeType, rows, columns, attrs) {\n\t  attrs = setColumns(attrs, columns)\n\t  var rowType = nodeType.contentExpr.elements[0].nodeTypes[0]\n\t  var cellType = rowType.contentExpr.elements[0].nodeTypes[0]\n\t  var cell = cellType.createAndFill(), cells = []\n\t  for (var i = 0; i < columns; i++) { cells.push(cell) }\n\t  var row = rowType.create({columns: columns}, Fragment.from(cells)), rowNodes = []\n\t  for (var i$1 = 0; i$1 < rows; i$1++) { rowNodes.push(row) }\n\t  return nodeType.create(attrs, Fragment.from(rowNodes))\n\t}\n\texports.createTable = createTable\n\t\n\t// Steps to add and remove a column\n\t\n\tfunction setColumns(attrs, columns) {\n\t  var result = Object.create(null)\n\t  if (attrs) { for (var prop in attrs) { result[prop] = attrs[prop] } }\n\t  result.columns = columns\n\t  return result\n\t}\n\t\n\tfunction adjustColumns(attrs, diff) {\n\t  return setColumns(attrs, attrs.columns + diff)\n\t}\n\t\n\t// ::- A `Step` subclass for adding a column to a table in a single\n\t// atomic step.\n\tvar AddColumnStep = (function (Step) {\n\t  function AddColumnStep(positions, cells) {\n\t    Step.call(this)\n\t    this.positions = positions\n\t    this.cells = cells\n\t  }\n\t\n\t  if ( Step ) AddColumnStep.__proto__ = Step;\n\t  AddColumnStep.prototype = Object.create( Step && Step.prototype );\n\t  AddColumnStep.prototype.constructor = AddColumnStep;\n\t\n\t  // :: (Node, number, number, NodeType, ?Object) → AddColumnStep\n\t  // Create a step that inserts a column into the table after\n\t  // `tablePos`, at the index given by `columnIndex`, using cells with\n\t  // the given type and attributes.\n\t  AddColumnStep.create = function create (doc, tablePos, columnIndex, cellType, cellAttrs) {\n\t    var cell = cellType.createAndFill(cellAttrs)\n\t    var positions = [], cells = []\n\t    var table = doc.nodeAt(tablePos)\n\t    table.forEach(function (row, rowOff) {\n\t      var cellPos = tablePos + 2 + rowOff\n\t      for (var i = 0; i < columnIndex; i++) { cellPos += row.child(i).nodeSize }\n\t      positions.push(cellPos)\n\t      cells.push(cell)\n\t    })\n\t    return new AddColumnStep(positions, cells)\n\t  };\n\t\n\t  AddColumnStep.prototype.apply = function apply (doc) {\n\t    var this$1 = this;\n\t\n\t    var index = null, table = null, tablePos = null\n\t    for (var i = 0; i < this.positions.length; i++) {\n\t      var $pos = doc.resolve(this$1.positions[i])\n\t      if ($pos.depth < 2 || $pos.index(-1) != i)\n\t        { return StepResult.fail(\"Invalid cell insert position\") }\n\t      if (table == null) {\n\t        table = $pos.node(-1)\n\t        if (table.childCount != this$1.positions.length)\n\t          { return StepResult.fail(\"Mismatch in number of rows\") }\n\t        tablePos = $pos.before(-1)\n\t        index = $pos.index()\n\t      } else if ($pos.before(-1) != tablePos || $pos.index() != index) {\n\t        return StepResult.fail(\"Column insert positions not consistent\")\n\t      }\n\t    }\n\t\n\t    var updatedRows = []\n\t    for (var i$1 = 0; i$1 < table.childCount; i$1++) {\n\t      var row = table.child(i$1), rowCells = index ? [] : [this$1.cells[i$1]]\n\t      for (var j = 0; j < row.childCount; j++) {\n\t        rowCells.push(row.child(j))\n\t        if (j + 1 == index) { rowCells.push(this$1.cells[i$1]) }\n\t      }\n\t      updatedRows.push(row.type.create(adjustColumns(row.attrs, 1), Fragment.from(rowCells)))\n\t    }\n\t    var updatedTable = table.type.create(adjustColumns(table.attrs, 1),  Fragment.from(updatedRows))\n\t    return StepResult.fromReplace(doc, tablePos, tablePos + table.nodeSize,\n\t                                  new Slice(Fragment.from(updatedTable), 0, 0))\n\t  };\n\t\n\t  AddColumnStep.prototype.getMap = function getMap () {\n\t    var this$1 = this;\n\t\n\t    var ranges = []\n\t    for (var i = 0; i < this.positions.length; i++)\n\t      { ranges.push(this$1.positions[i], 0, this$1.cells[i].nodeSize) }\n\t    return new StepMap(ranges)\n\t  };\n\t\n\t  AddColumnStep.prototype.invert = function invert (doc) {\n\t    var this$1 = this;\n\t\n\t    var $first = doc.resolve(this.positions[0])\n\t    var table = $first.node(-1)\n\t    var from = [], to = [], dPos = 0\n\t    for (var i = 0; i < table.childCount; i++) {\n\t      var pos = this$1.positions[i] + dPos, size = this$1.cells[i].nodeSize\n\t      from.push(pos)\n\t      to.push(pos + size)\n\t      dPos += size\n\t    }\n\t    return new RemoveColumnStep(from, to)\n\t  };\n\t\n\t  AddColumnStep.prototype.map = function map (mapping) {\n\t    return new AddColumnStep(this.positions.map(function (p) { return mapping.map(p); }), this.cells)\n\t  };\n\t\n\t  AddColumnStep.prototype.toJSON = function toJSON () {\n\t    return {stepType: this.jsonID,\n\t            positions: this.positions,\n\t            cells: this.cells.map(function (c) { return c.toJSON(); })}\n\t  };\n\t\n\t  AddColumnStep.fromJSON = function fromJSON (schema, json) {\n\t    return new AddColumnStep(json.positions, json.cells.map(schema.nodeFromJSON))\n\t  };\n\t\n\t  return AddColumnStep;\n\t}(Step));\n\texports.AddColumnStep = AddColumnStep\n\t\n\tStep.jsonID(\"addTableColumn\", AddColumnStep)\n\t\n\t// ::- A subclass of `Step` that removes a column from a table.\n\tvar RemoveColumnStep = (function (Step) {\n\t  function RemoveColumnStep(from, to) {\n\t    Step.call(this)\n\t    this.from = from\n\t    this.to = to\n\t  }\n\t\n\t  if ( Step ) RemoveColumnStep.__proto__ = Step;\n\t  RemoveColumnStep.prototype = Object.create( Step && Step.prototype );\n\t  RemoveColumnStep.prototype.constructor = RemoveColumnStep;\n\t\n\t  // :: (Node, number, number) → RemoveColumnStep\n\t  // Create a step that deletes the column at `columnIndex` in the\n\t  // table after `tablePos`.\n\t  RemoveColumnStep.create = function create (doc, tablePos, columnIndex) {\n\t    var from = [], to = []\n\t    var table = doc.nodeAt(tablePos)\n\t    table.forEach(function (row, rowOff) {\n\t      var cellPos = tablePos + 2 + rowOff\n\t      for (var i = 0; i < columnIndex; i++) { cellPos += row.child(i).nodeSize }\n\t      from.push(cellPos)\n\t      to.push(cellPos + row.child(columnIndex).nodeSize)\n\t    })\n\t    return new RemoveColumnStep(from, to)\n\t  };\n\t\n\t  RemoveColumnStep.prototype.apply = function apply (doc) {\n\t    var this$1 = this;\n\t\n\t    var index = null, table = null, tablePos = null\n\t    for (var i = 0; i < this.from.length; i++) {\n\t      var $from = doc.resolve(this$1.from[i]), after = $from.nodeAfter\n\t      if ($from.depth < 2 || $from.index(-1) != i || !after || this$1.from[i] + after.nodeSize != this$1.to[i])\n\t        { return StepResult.fail(\"Invalid cell delete positions\") }\n\t      if (table == null) {\n\t        table = $from.node(-1)\n\t        if (table.childCount != this$1.from.length)\n\t          { return StepResult.fail(\"Mismatch in number of rows\") }\n\t        tablePos = $from.before(-1)\n\t        index = $from.index()\n\t      } else if ($from.before(-1) != tablePos || $from.index() != index) {\n\t        return StepResult.fail(\"Column delete positions not consistent\")\n\t      }\n\t    }\n\t\n\t    var updatedRows = []\n\t    for (var i$1 = 0; i$1 < table.childCount; i$1++) {\n\t      var row = table.child(i$1), rowCells = []\n\t      for (var j = 0; j < row.childCount; j++)\n\t        { if (j != index) { rowCells.push(row.child(j)) } }\n\t      updatedRows.push(row.type.create(adjustColumns(row.attrs, -1), Fragment.from(rowCells)))\n\t    }\n\t    var updatedTable = table.type.create(adjustColumns(table.attrs, -1),  Fragment.from(updatedRows))\n\t    return StepResult.fromReplace(doc, tablePos, tablePos + table.nodeSize,\n\t                                  new Slice(Fragment.from(updatedTable), 0, 0))\n\t  };\n\t\n\t  RemoveColumnStep.prototype.getMap = function getMap () {\n\t    var this$1 = this;\n\t\n\t    var ranges = []\n\t    for (var i = 0; i < this.from.length; i++)\n\t      { ranges.push(this$1.from[i], this$1.to[i] - this$1.from[i], 0) }\n\t    return new StepMap(ranges)\n\t  };\n\t\n\t  RemoveColumnStep.prototype.invert = function invert (doc) {\n\t    var this$1 = this;\n\t\n\t    var $first = doc.resolve(this.from[0])\n\t    var table = $first.node(-1), index = $first.index()\n\t    var positions = [], cells = [], dPos = 0\n\t    for (var i = 0; i < table.childCount; i++) {\n\t      positions.push(this$1.from[i] - dPos)\n\t      var cell = table.child(i).child(index)\n\t      dPos += cell.nodeSize\n\t      cells.push(cell)\n\t    }\n\t    return new AddColumnStep(positions, cells)\n\t  };\n\t\n\t  RemoveColumnStep.prototype.map = function map (mapping) {\n\t    var this$1 = this;\n\t\n\t    var from = [], to = []\n\t    for (var i = 0; i < this.from.length; i++) {\n\t      var start = mapping.map(this$1.from[i], 1), end = mapping.map(this$1.to[i], -1)\n\t      if (end <= start) { return null }\n\t      from.push(start)\n\t      to.push(end)\n\t    }\n\t    return new RemoveColumnStep(from, to)\n\t  };\n\t\n\t  RemoveColumnStep.fromJSON = function fromJSON (_schema, json) {\n\t    return new RemoveColumnStep(json.from, json.to)\n\t  };\n\t\n\t  return RemoveColumnStep;\n\t}(Step));\n\texports.RemoveColumnStep = RemoveColumnStep\n\t\n\tStep.jsonID(\"removeTableColumn\", RemoveColumnStep)\n\t\n\t// Table-related command functions\n\t\n\tfunction findRow($pos, pred) {\n\t  for (var d = $pos.depth; d > 0; d--)\n\t    { if ($pos.node(d).type.spec.tableRow && (!pred || pred(d))) { return d } }\n\t  return -1\n\t}\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that adds a column before the column with the\n\t// selection.\n\tfunction addColumnBefore(state, dispatch) {\n\t  var $from = state.selection.$from, cellFrom\n\t  var rowDepth = findRow($from, function (d) { return cellFrom = d == $from.depth ? $from.nodeBefore : $from.node(d + 1); })\n\t  if (rowDepth == -1) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr.step(AddColumnStep.create(state.doc, $from.before(rowDepth - 1), $from.index(rowDepth),\n\t                                                cellFrom.type, cellFrom.attrs))) }\n\t  return true\n\t}\n\texports.addColumnBefore = addColumnBefore\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that adds a column after the column with the\n\t// selection.\n\tfunction addColumnAfter(state, dispatch) {\n\t  var $from = state.selection.$from, cellFrom\n\t  var rowDepth = findRow($from, function (d) { return cellFrom = d == $from.depth ? $from.nodeAfter : $from.node(d + 1); })\n\t  if (rowDepth == -1) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr.step(AddColumnStep.create(state.doc, $from.before(rowDepth - 1),\n\t                                                $from.indexAfter(rowDepth) + (rowDepth == $from.depth ? 1 : 0),\n\t                                                cellFrom.type, cellFrom.attrs))) }\n\t  return true\n\t}\n\texports.addColumnAfter = addColumnAfter\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that removes the column with the selection.\n\tfunction removeColumn(state, dispatch) {\n\t  var $from = state.selection.$from\n\t  var rowDepth = findRow($from, function (d) { return $from.node(d).childCount > 1; })\n\t  if (rowDepth == -1) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr.step(RemoveColumnStep.create(state.doc, $from.before(rowDepth - 1), $from.index(rowDepth)))) }\n\t  return true\n\t}\n\texports.removeColumn = removeColumn\n\t\n\tfunction addRow(state, dispatch, side) {\n\t  var $from = state.selection.$from\n\t  var rowDepth = findRow($from)\n\t  if (rowDepth == -1) { return false }\n\t  if (dispatch) {\n\t    var exampleRow = $from.node(rowDepth)\n\t    var cells = [], pos = side < 0 ? $from.before(rowDepth) : $from.after(rowDepth)\n\t    exampleRow.forEach(function (cell) { return cells.push(cell.type.createAndFill(cell.attrs)); })\n\t    var row = exampleRow.copy(Fragment.from(cells))\n\t    dispatch(state.tr.step(new ReplaceStep(pos, pos, new Slice(Fragment.from(row), 0, 0))))\n\t  }\n\t  return true\n\t}\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that adds a row after the row with the\n\t// selection.\n\tfunction addRowBefore(state, dispatch) {\n\t  return addRow(state, dispatch, -1)\n\t}\n\texports.addRowBefore = addRowBefore\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that adds a row before the row with the\n\t// selection.\n\tfunction addRowAfter(state, dispatch) {\n\t  return addRow(state, dispatch, 1)\n\t}\n\texports.addRowAfter = addRowAfter\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Command function that removes the row with the selection.\n\tfunction removeRow(state, dispatch) {\n\t  var $from = state.selection.$from\n\t  var rowDepth = findRow($from, function (d) { return $from.node(d - 1).childCount > 1; })\n\t  if (rowDepth == -1) { return false }\n\t  if (dispatch)\n\t    { dispatch(state.tr.step(new ReplaceStep($from.before(rowDepth), $from.after(rowDepth), Slice.empty))) }\n\t  return true\n\t}\n\texports.removeRow = removeRow\n\t\n\tfunction moveCell(state, dir, dispatch) {\n\t  var ref = state.selection;\n\t  var $from = ref.$from;\n\t  var rowDepth = findRow($from)\n\t  if (rowDepth == -1) { return false }\n\t  var row = $from.node(rowDepth), newIndex = $from.index(rowDepth) + dir\n\t  if (newIndex >= 0 && newIndex < row.childCount) {\n\t    var $cellStart = state.doc.resolve(row.content.offsetAt(newIndex) + $from.start(rowDepth))\n\t    var sel = Selection.findFrom($cellStart, 1)\n\t    if (!sel || sel.from >= $cellStart.end()) { return false }\n\t    if (dispatch) { dispatch(state.tr.setSelection(sel).scrollIntoView()) }\n\t    return true\n\t  } else {\n\t    var rowIndex = $from.index(rowDepth - 1) + dir, table = $from.node(rowDepth - 1)\n\t    if (rowIndex < 0 || rowIndex >= table.childCount) { return false }\n\t    var cellStart = dir > 0 ? $from.after(rowDepth) + 2 : $from.before(rowDepth) - 2 - table.child(rowIndex).lastChild.content.size\n\t    var $cellStart$1 = state.doc.resolve(cellStart), sel$1 = Selection.findFrom($cellStart$1, 1)\n\t    if (!sel$1 || sel$1.from >= $cellStart$1.end()) { return false }\n\t    if (dispatch) { dispatch(state.tr.setSelection(sel$1).scrollIntoView()) }\n\t    return true\n\t  }\n\t}\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Move to the next cell in the current table, if there is one.\n\tfunction selectNextCell(state, dispatch) { return moveCell(state, 1, dispatch) }\n\texports.selectNextCell = selectNextCell\n\t\n\t// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n\t// Move to the previous cell in the current table, if there is one.\n\tfunction selectPreviousCell(state, dispatch) { return moveCell(state, -1, dispatch) }\n\texports.selectPreviousCell = selectPreviousCell\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(4);\n\tvar Transform = ref.Transform;\n\tvar ref$1 = __webpack_require__(1);\n\tvar Mark = ref$1.Mark;\n\tvar ref$2 = __webpack_require__(32);\n\tvar Selection = ref$2.Selection;\n\t\n\tvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\t\n\t// ::- An editor state transaction, which can be applied to a state to\n\t// create an updated state. Use\n\t// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n\t//\n\t// Transactions track changes to the document (they are a subclass of\n\t// [`Transform`](#transform.Transform)), but also other state changes,\n\t// like selection updates and adjustments of the set of [stored\n\t// marks](##state.EditorState.storedMarks). In addition, you can store\n\t// metadata properties in a transaction, which are extra pieces of\n\t// informations that client code or plugins can use to describe what a\n\t// transacion represents, so that they can update their [own\n\t// state](##state.StateField) accordingly.\n\t//\n\t// The [editor view](##view.EditorView) uses a single metadata\n\t// property: it will attach a property `\"pointer\"` with the value\n\t// `true` to selection transactions directly caused by mouse or touch\n\t// input.\n\tvar Transaction = (function (Transform) {\n\t  function Transaction(state) {\n\t    Transform.call(this, state.doc)\n\t    // :: number\n\t    // The timestamp associated with this transaction.\n\t    this.time = Date.now()\n\t    this.curSelection = state.selection\n\t    // The step count for which the current selection is valid.\n\t    this.curSelectionFor = 0\n\t    // :: ?[Mark]\n\t    // The stored marks in this transaction.\n\t    this.storedMarks = state.storedMarks\n\t    // Bitfield to track which aspects of the state were updated by\n\t    // this transaction.\n\t    this.updated = 0\n\t    // Object used to store metadata properties for the transaction.\n\t    this.meta = Object.create(null)\n\t  }\n\t\n\t  if ( Transform ) Transaction.__proto__ = Transform;\n\t  Transaction.prototype = Object.create( Transform && Transform.prototype );\n\t  Transaction.prototype.constructor = Transaction;\n\t\n\t  var prototypeAccessors = { docChanged: {},selection: {},selectionSet: {},storedMarksSet: {},isGeneric: {},scrolledIntoView: {} };\n\t\n\t  // :: bool\n\t  // True when this transaction changes the document.\n\t  prototypeAccessors.docChanged.get = function () {\n\t    return this.steps.length > 0\n\t  };\n\t\n\t  // :: Selection\n\t  // The transform's current selection. This defaults to the\n\t  // editor selection [mapped](#state.Selection.map) through the steps in\n\t  // this transform, but can be overwritten with\n\t  // [`setSelection`](#state.Transaction.setSelection).\n\t  prototypeAccessors.selection.get = function () {\n\t    if (this.curSelectionFor < this.steps.length) {\n\t      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n\t      this.curSelectionFor = this.steps.length\n\t    }\n\t    return this.curSelection\n\t  };\n\t\n\t  // :: (Selection) → Transaction\n\t  // Update the transaction's current selection. This will determine\n\t  // the selection that the editor gets when the transaction is\n\t  // applied.\n\t  Transaction.prototype.setSelection = function setSelection (selection) {\n\t    this.curSelection = selection\n\t    this.curSelectionFor = this.steps.length\n\t    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n\t    this.storedMarks = null\n\t    return this\n\t  };\n\t\n\t  // :: bool\n\t  // Whether the selection was explicitly updated by this transaction.\n\t  prototypeAccessors.selectionSet.get = function () {\n\t    return this.updated & UPDATED_SEL > 0\n\t  };\n\t\n\t  // :: (?[Mark]) → Transaction\n\t  // Replace the set of stored marks.\n\t  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n\t    this.storedMarks = marks\n\t    this.updated |= UPDATED_MARKS\n\t    return this\n\t  };\n\t\n\t  // :: bool\n\t  // Whether the stored marks were explicitly set for this transaction.\n\t  prototypeAccessors.storedMarksSet.get = function () {\n\t    return this.updated & UPDATED_MARKS > 0\n\t  };\n\t\n\t  Transaction.prototype.addStep = function addStep (step, doc) {\n\t    Transform.prototype.addStep.call(this, step, doc)\n\t    this.updated = this.updated & ~UPDATED_MARKS\n\t    this.storedMarks = null\n\t  };\n\t\n\t  // :: (number) → Transaction\n\t  // Update the timestamp for the transaction.\n\t  Transaction.prototype.setTime = function setTime (time) {\n\t    this.time = time\n\t    return this\n\t  };\n\t\n\t  // :: (Slice) → Transaction\n\t  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n\t    var ref = this.selection;\n\t    var from = ref.from;\n\t    var to = ref.to;\n\t    var startLen = this.steps.length\n\t    this.replaceRange(from, to, slice)\n\t    // Move the selection to the position after the inserted content.\n\t    // When that ended in an inline node, search backwards, to get the\n\t    // position after that node. If not, search forward.\n\t    var lastNode = slice.content.lastChild, lastParent = null\n\t    for (var i = 0; i < slice.openRight; i++) {\n\t      lastParent = lastNode\n\t      lastNode = lastNode.lastChild\n\t    }\n\t    selectionToInsertionEnd(this, startLen, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n\t    return this\n\t  };\n\t\n\t  // :: (Node, ?bool) → Transaction\n\t  // Replace the selection with the given node or slice, or delete it\n\t  // if `content` is null. When `inheritMarks` is true and the content\n\t  // is inline, it inherits the marks from the place where it is\n\t  // inserted.\n\t  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n\t    var ref = this.selection;\n\t    var $from = ref.$from;\n\t    var from = ref.from;\n\t    var to = ref.to;\n\t    var startLen = this.steps.length\n\t    if (inheritMarks !== false)\n\t      { node = node.mark(this.storedMarks || $from.marks(to > from)) }\n\t    this.replaceRangeWith(from, to, node)\n\t    selectionToInsertionEnd(this, startLen, node.isInline ? -1 : 1)\n\t    return this\n\t  };\n\t\n\t  // :: () → Transaction\n\t  // Delete the selection.\n\t  Transaction.prototype.deleteSelection = function deleteSelection () {\n\t    var ref = this.selection;\n\t    var from = ref.from;\n\t    var to = ref.to;\n\t    return this.deleteRange(from, to)\n\t  };\n\t\n\t  // :: (string, from: ?number, to: ?number) → Transaction\n\t  // Replace the given range, or the selection if no range is given,\n\t  // with a text node containing the given string.\n\t  Transaction.prototype.insertText = function insertText (text, from, to) {\n\t    if ( to === void 0 ) to = from;\n\t\n\t    var schema = this.doc.type.schema\n\t    if (from == null) {\n\t      if (!text) { return this.deleteSelection() }\n\t      return this.replaceSelectionWith(schema.text(text), true)\n\t    } else {\n\t      if (!text) { return this.deleteRange(from, to) }\n\t      var node = schema.text(text, this.storedMarks || this.doc.resolve(from).marks(to > from))\n\t      return this.replaceRangeWith(from, to, node)\n\t    }\n\t  };\n\t\n\t  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n\t  // Store a metadata property in this transaction, keyed either by\n\t  // name or by plugin.\n\t  Transaction.prototype.setMeta = function setMeta (key, value) {\n\t    this.meta[typeof key == \"string\" ? key : key.key] = value\n\t    return this\n\t  };\n\t\n\t  // :: (union<string, Plugin, PluginKey>) → any\n\t  // Retrieve a metadata property for a given name or plugin.\n\t  Transaction.prototype.getMeta = function getMeta (key) {\n\t    return this.meta[typeof key == \"string\" ? key : key.key]\n\t  };\n\t\n\t  // :: bool\n\t  // Returns true if this transaction doesn't contain any metadata,\n\t  // and can thus be safely extended.\n\t  prototypeAccessors.isGeneric.get = function () {\n\t    var this$1 = this;\n\t\n\t    for (var _ in this$1.meta) { return false }\n\t    return true\n\t  };\n\t\n\t  // :: () → Transaction\n\t  // Indicate that the editor should scroll the selection into view\n\t  // when updated to the state produced by this transaction.\n\t  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n\t    this.updated |= UPDATED_SCROLL\n\t    return this\n\t  };\n\t\n\t  prototypeAccessors.scrolledIntoView.get = function () {\n\t    return this.updated | UPDATED_SCROLL > 0\n\t  };\n\t\n\t  // :: (Mark) → Transaction\n\t  // Add a mark to the set of stored marks.\n\t  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n\t    this.storedMarks = mark.addToSet(this.storedMarks || currentMarks(this.selection))\n\t    return this\n\t  };\n\t\n\t  // :: (union<Mark, MarkType>) → Transaction\n\t  // Remove a mark or mark type from the set of stored marks.\n\t  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n\t    this.storedMarks = mark.removeFromSet(this.storedMarks || currentMarks(this.selection))\n\t    return this\n\t  };\n\t\n\t  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\t\n\t  return Transaction;\n\t}(Transform));\n\texports.Transaction = Transaction\n\t\n\tfunction selectionToInsertionEnd(tr, startLen, bias) {\n\t  if (tr.steps.length == startLen) { return }\n\t  var map = tr.mapping.maps[tr.mapping.maps.length - 1], end\n\t  map.forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; })\n\t  if (end != null) { tr.setSelection(Selection.near(tr.doc.resolve(end), bias)) }\n\t}\n\t\n\tfunction currentMarks(selection) {\n\t  return selection.head == null ? Mark.none : selection.$head.marks()\n\t}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Fragment = ref.Fragment;\n\tvar Slice = ref.Slice;\n\tvar ref$1 = __webpack_require__(33);\n\tvar Step = ref$1.Step;\n\tvar StepResult = ref$1.StepResult;\n\t\n\tfunction mapFragment(fragment, f, parent) {\n\t  var mapped = []\n\t  for (var i = 0; i < fragment.childCount; i++) {\n\t    var child = fragment.child(i)\n\t    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)) }\n\t    if (child.isInline) { child = f(child, parent, i) }\n\t    mapped.push(child)\n\t  }\n\t  return Fragment.fromArray(mapped)\n\t}\n\t\n\t// ::- Add a mark to all inline content between two positions.\n\tvar AddMarkStep = (function (Step) {\n\t  function AddMarkStep(from, to, mark) {\n\t    Step.call(this)\n\t    this.from = from\n\t    this.to = to\n\t    this.mark = mark\n\t  }\n\t\n\t  if ( Step ) AddMarkStep.__proto__ = Step;\n\t  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n\t  AddMarkStep.prototype.constructor = AddMarkStep;\n\t\n\t  AddMarkStep.prototype.apply = function apply (doc) {\n\t    var this$1 = this;\n\t\n\t    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n\t    var parent = $from.node($from.sharedDepth(this.to))\n\t    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent, index) {\n\t      if (!parent.contentMatchAt(index + 1).allowsMark(this$1.mark.type)) { return node }\n\t      return node.mark(this$1.mark.addToSet(node.marks))\n\t    }, parent), oldSlice.openLeft, oldSlice.openRight)\n\t    return StepResult.fromReplace(doc, this.from, this.to, slice)\n\t  };\n\t\n\t  AddMarkStep.prototype.invert = function invert () {\n\t    return new RemoveMarkStep(this.from, this.to, this.mark)\n\t  };\n\t\n\t  AddMarkStep.prototype.map = function map (mapping) {\n\t    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n\t    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n\t    return new AddMarkStep(from.pos, to.pos, this.mark)\n\t  };\n\t\n\t  AddMarkStep.prototype.merge = function merge (other) {\n\t    if (other instanceof AddMarkStep &&\n\t        other.mark.eq(this.mark) &&\n\t        this.from <= other.to && this.to >= other.from)\n\t      { return new AddMarkStep(Math.min(this.from, other.from),\n\t                             Math.max(this.to, other.to), this.mark) }\n\t  };\n\t\n\t  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n\t    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n\t  };\n\t\n\t  return AddMarkStep;\n\t}(Step));\n\texports.AddMarkStep = AddMarkStep\n\t\n\tStep.jsonID(\"addMark\", AddMarkStep)\n\t\n\t// ::- Remove a mark from all inline content between two positions.\n\tvar RemoveMarkStep = (function (Step) {\n\t  function RemoveMarkStep(from, to, mark) {\n\t    Step.call(this)\n\t    this.from = from\n\t    this.to = to\n\t    this.mark = mark\n\t  }\n\t\n\t  if ( Step ) RemoveMarkStep.__proto__ = Step;\n\t  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n\t  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\t\n\t  RemoveMarkStep.prototype.apply = function apply (doc) {\n\t    var this$1 = this;\n\t\n\t    var oldSlice = doc.slice(this.from, this.to)\n\t    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n\t      return node.mark(this$1.mark.removeFromSet(node.marks))\n\t    }), oldSlice.openLeft, oldSlice.openRight)\n\t    return StepResult.fromReplace(doc, this.from, this.to, slice)\n\t  };\n\t\n\t  RemoveMarkStep.prototype.invert = function invert () {\n\t    return new AddMarkStep(this.from, this.to, this.mark)\n\t  };\n\t\n\t  RemoveMarkStep.prototype.map = function map (mapping) {\n\t    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n\t    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n\t    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n\t  };\n\t\n\t  RemoveMarkStep.prototype.merge = function merge (other) {\n\t    if (other instanceof RemoveMarkStep &&\n\t        other.mark.eq(this.mark) &&\n\t        this.from <= other.to && this.to >= other.from)\n\t      { return new RemoveMarkStep(Math.min(this.from, other.from),\n\t                                Math.max(this.to, other.to), this.mark) }\n\t  };\n\t\n\t  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n\t    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n\t  };\n\t\n\t  return RemoveMarkStep;\n\t}(Step));\n\texports.RemoveMarkStep = RemoveMarkStep\n\t\n\tStep.jsonID(\"removeMark\", RemoveMarkStep)\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Slice = ref.Slice;\n\tvar Fragment = ref.Fragment;\n\t\n\tvar ref$1 = __webpack_require__(17);\n\tvar Transform = ref$1.Transform;\n\tvar ref$2 = __webpack_require__(16);\n\tvar ReplaceStep = ref$2.ReplaceStep;\n\tvar ReplaceAroundStep = ref$2.ReplaceAroundStep;\n\t\n\tfunction canCut(node, start, end) {\n\t  return (start == 0 || node.canReplace(start, node.childCount)) &&\n\t    (end == node.childCount || node.canReplace(0, end))\n\t}\n\t\n\t// :: (NodeRange) → ?number\n\t// Try to find a target depth to which the content in the given range\n\t// can be lifted.\n\tfunction liftTarget(range) {\n\t  var parent = range.parent\n\t  var content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n\t  for (var depth = range.depth;; --depth) {\n\t    var node = range.$from.node(depth), index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n\t    if (depth < range.depth && node.canReplace(index, endIndex, content))\n\t      { return depth }\n\t    if (depth == 0 || !canCut(node, index, endIndex)) { break }\n\t  }\n\t}\n\texports.liftTarget = liftTarget\n\t\n\t// :: (NodeRange, number) → Transform\n\t// Split the content in the given range off from its parent, if there\n\t// is sibling content before or after it, and move it up the tree to\n\t// the depth specified by `target`. You'll probably want to use\n\t// `liftTarget` to compute `target`, in order to be sure the lift is\n\t// valid.\n\tTransform.prototype.lift = function(range, target) {\n\t  var $from = range.$from;\n\t  var $to = range.$to;\n\t  var depth = range.depth;\n\t\n\t  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n\t  var start = gapStart, end = gapEnd\n\t\n\t  var before = Fragment.empty, openLeft = 0\n\t  for (var d = depth, splitting = false; d > target; d--)\n\t    { if (splitting || $from.index(d) > 0) {\n\t      splitting = true\n\t      before = Fragment.from($from.node(d).copy(before))\n\t      openLeft++\n\t    } else {\n\t      start--\n\t    } }\n\t  var after = Fragment.empty, openRight = 0\n\t  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n\t    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n\t      splitting$1 = true\n\t      after = Fragment.from($to.node(d$1).copy(after))\n\t      openRight++\n\t    } else {\n\t      end++\n\t    } }\n\t\n\t  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n\t                                         new Slice(before.append(after), openLeft, openRight),\n\t                                         before.size - openLeft, true))\n\t}\n\t\n\t// :: (NodeRange, NodeType, ?Object) → ?[{type: NodeType, attrs: ?Object}]\n\t// Try to find a valid way to wrap the content in the given range in a\n\t// node of the given type. May introduce extra nodes around and inside\n\t// the wrapper node, if necessary. Returns null if no valid wrapping\n\t// could be found.\n\tfunction findWrapping(range, nodeType, attrs, innerRange) {\n\t  if ( innerRange === void 0 ) innerRange = range;\n\t\n\t  var wrap = {type: nodeType, attrs: attrs}\n\t  var around = findWrappingOutside(range, wrap)\n\t  var inner = around && findWrappingInside(innerRange, wrap)\n\t  if (!inner) { return null }\n\t  return around.concat(wrap).concat(inner)\n\t}\n\texports.findWrapping = findWrapping\n\t\n\tfunction findWrappingOutside(range, wrap) {\n\t  var parent = range.parent;\n\t  var startIndex = range.startIndex;\n\t  var endIndex = range.endIndex;\n\t  var around = parent.contentMatchAt(startIndex).findWrapping(wrap.type, wrap.attrs)\n\t  if (!around) { return null }\n\t  var outer = around.length ? around[0] : wrap\n\t  if (!parent.canReplaceWith(startIndex, endIndex, outer.type, outer.attrs))\n\t    { return null }\n\t  return around\n\t}\n\t\n\tfunction findWrappingInside(range, wrap) {\n\t  var parent = range.parent;\n\t  var startIndex = range.startIndex;\n\t  var endIndex = range.endIndex;\n\t  var inner = parent.child(startIndex)\n\t  var inside = wrap.type.contentExpr.start(wrap.attrs).findWrappingFor(inner)\n\t  if (!inside) { return null }\n\t  var last = inside.length ? inside[inside.length - 1] : wrap\n\t  var innerMatch = last.type.contentExpr.start(last.attrs)\n\t  for (var i = startIndex; i < endIndex; i++)\n\t    { innerMatch = innerMatch && innerMatch.matchNode(parent.child(i)) }\n\t  if (!innerMatch || !innerMatch.validEnd()) { return null }\n\t  return inside\n\t}\n\t\n\t// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → Transform\n\t// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n\t// The wrappers are assumed to be valid in this position, and should\n\t// probably be computed with `findWrapping`.\n\tTransform.prototype.wrap = function(range, wrappers) {\n\t  var content = Fragment.empty\n\t  for (var i = wrappers.length - 1; i >= 0; i--)\n\t    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)) }\n\t\n\t  var start = range.start, end = range.end\n\t  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n\t}\n\t\n\t// :: (number, ?number, NodeType, ?Object) → Transform\n\t// Set the type of all textblocks (partly) between `from` and `to` to\n\t// the given node type with the given attributes.\n\tTransform.prototype.setBlockType = function(from, to, type, attrs) {\n\t  var this$1 = this;\n\t  if ( to === void 0 ) to = from;\n\t\n\t  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n\t  var mapFrom = this.steps.length\n\t  this.doc.nodesBetween(from, to, function (node, pos) {\n\t    if (node.isTextblock && !node.hasMarkup(type, attrs)) {\n\t      // Ensure all markup that isn't allowed in the new node type is cleared\n\t      this$1.clearNonMatching(this$1.mapping.slice(mapFrom).map(pos, 1), type.contentExpr.start(attrs))\n\t      var mapping = this$1.mapping.slice(mapFrom)\n\t      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n\t      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n\t                                      new Slice(Fragment.from(type.create(attrs)), 0, 0), 1, true))\n\t      return false\n\t    }\n\t  })\n\t  return this\n\t}\n\t\n\t// :: (number, ?NodeType, ?Object) → Transform\n\t// Change the type and attributes of the node after `pos`.\n\tTransform.prototype.setNodeType = function(pos, type, attrs) {\n\t  var node = this.doc.nodeAt(pos)\n\t  if (!node) { throw new RangeError(\"No node at given position\") }\n\t  if (!type) { type = node.type }\n\t  if (node.isLeaf)\n\t    { return this.replaceWith(pos, pos + node.nodeSize, type.create(attrs, null, node.marks)) }\n\t\n\t  if (!type.validContent(node.content, attrs))\n\t    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\t\n\t  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n\t                                         new Slice(Fragment.from(type.create(attrs)), 0, 0), 1, true))\n\t}\n\t\n\t// :: (Node, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n\t// Check whether splitting at the given position is allowed.\n\tfunction canSplit(doc, pos, depth, typesAfter) {\n\t  if ( depth === void 0 ) depth = 1;\n\t\n\t  var $pos = doc.resolve(pos), base = $pos.depth - depth\n\t  if (base < 0 ||\n\t      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n\t      !$pos.parent.canReplace(0, $pos.indexAfter()))\n\t    { return false }\n\t  for (var d = $pos.depth - 1, i = depth - 1; d > base; d--, i--) {\n\t    var node = $pos.node(d), index$1 = $pos.index(d)\n\t    var typeAfter = typesAfter && typesAfter[i]\n\t    if (!node.canReplace(0, index$1) ||\n\t        !node.canReplaceWith(index$1, node.childCount, typeAfter ? typeAfter.type : $pos.node(d + 1).type,\n\t                             typeAfter ? typeAfter.attrs : $pos.node(d + 1).attrs))\n\t      { return false }\n\t  }\n\t  var index = $pos.indexAfter(base)\n\t  var baseType = typesAfter && typesAfter[0]\n\t  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type,\n\t                                        baseType ? baseType.attrs : $pos.node(base + 1).attrs)\n\t}\n\texports.canSplit = canSplit\n\t\n\t// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → Transform\n\t// Split the node at the given position, and optionally, if `depth` is\n\t// greater than one, any number of nodes above that. By default, the\n\t// parts split off will inherit the node type of the original node.\n\t// This can be changed by passing an array of types and attributes to\n\t// use after the split.\n\tTransform.prototype.split = function(pos, depth, typesAfter) {\n\t  if ( depth === void 0 ) depth = 1;\n\t\n\t  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n\t  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n\t    before = Fragment.from($pos.node(d).copy(before))\n\t    var typeAfter = typesAfter && typesAfter[i]\n\t    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n\t  }\n\t  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth, true)))\n\t}\n\t\n\t// :: (Node, number) → bool\n\t// Test whether the blocks before and after a given position can be\n\t// joined.\n\tfunction canJoin(doc, pos) {\n\t  var $pos = doc.resolve(pos), index = $pos.index()\n\t  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n\t    $pos.parent.canReplace(index, index + 1)\n\t}\n\texports.canJoin = canJoin\n\t\n\tfunction joinable(a, b) {\n\t  return a && b && !a.isLeaf && a.canAppend(b)\n\t}\n\t\n\t// :: (Node, number, ?number) → ?number\n\t// Find an ancestor of the given position that can be joined to the\n\t// block before (or after if `dir` is positive). Returns the joinable\n\t// point, if any.\n\tfunction joinPoint(doc, pos, dir) {\n\t  if ( dir === void 0 ) dir = -1;\n\t\n\t  var $pos = doc.resolve(pos)\n\t  for (var d = $pos.depth;; d--) {\n\t    var before = (void 0), after = (void 0)\n\t    if (d == $pos.depth) {\n\t      before = $pos.nodeBefore\n\t      after = $pos.nodeAfter\n\t    } else if (dir > 0) {\n\t      before = $pos.node(d + 1)\n\t      after = $pos.node(d).maybeChild($pos.index(d) + 1)\n\t    } else {\n\t      before = $pos.node(d).maybeChild($pos.index(d) - 1)\n\t      after = $pos.node(d + 1)\n\t    }\n\t    if (before && !before.isTextblock && joinable(before, after)) { return pos }\n\t    if (d == 0) { break }\n\t    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n\t  }\n\t}\n\texports.joinPoint = joinPoint\n\t\n\t// :: (number, ?number, ?bool) → Transform\n\t// Join the blocks around the given position. If depth is 2, their\n\t// last and first siblings are also joined, and so on.\n\tTransform.prototype.join = function(pos, depth) {\n\t  if ( depth === void 0 ) depth = 1;\n\t\n\t  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n\t  return this.step(step)\n\t}\n\t\n\t// :: (Node, number, NodeType, ?Object) → ?number\n\t// Try to find a point where a node of the given type can be inserted\n\t// near `pos`, by searching up the node hierarchy when `pos` itself\n\t// isn't a valid place but is at the start or end of a node. Return\n\t// null if no position was found.\n\tfunction insertPoint(doc, pos, nodeType, attrs) {\n\t  var $pos = doc.resolve(pos)\n\t  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType, attrs)) { return pos }\n\t\n\t  if ($pos.parentOffset == 0)\n\t    { for (var d = $pos.depth - 1; d >= 0; d--) {\n\t      var index = $pos.index(d)\n\t      if ($pos.node(d).canReplaceWith(index, index, nodeType, attrs)) { return $pos.before(d + 1) }\n\t      if (index > 0) { return null }\n\t    } }\n\t  if ($pos.parentOffset == $pos.parent.content.size)\n\t    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n\t      var index$1 = $pos.indexAfter(d$1)\n\t      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType, attrs)) { return $pos.after(d$1 + 1) }\n\t      if (index$1 < $pos.node(d$1).childCount) { return null }\n\t    } }\n\t}\n\texports.insertPoint = insertPoint\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\tfunction compareObjs(a, b) {\n\t  if (a == b) { return true }\n\t  for (var p in a) { if (a[p] !== b[p]) { return false } }\n\t  for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n\t  return true\n\t}\n\t\n\tvar WidgetType = function(widget, options) {\n\t  if (widget.nodeType != 1) {\n\t    var wrap = document.createElement(\"span\")\n\t    wrap.appendChild(widget)\n\t    widget = wrap\n\t  }\n\t  widget.contentEditable = false\n\t  widget.classList.add(\"ProseMirror-widget\")\n\t  this.widget = widget\n\t  this.options = options || noOptions\n\t};\n\t\n\tWidgetType.prototype.map = function (mapping, span, offset, oldOffset) {\n\t  var ref = mapping.mapResult(span.from + oldOffset, this.options.associative == \"left\" ? -1 : 1);\n\t    var pos = ref.pos;\n\t    var deleted = ref.deleted;\n\t  return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n\t};\n\t\n\tWidgetType.prototype.valid = function () { return true };\n\t\n\tWidgetType.prototype.eq = function (other) {\n\t  return this == other ||\n\t    (other instanceof WidgetType && (this.widget == other.widget || this.options.key) &&\n\t     compareObjs(this.options, other.options))\n\t};\n\t\n\tvar InlineType = function(attrs, options) {\n\t  this.options = options || noOptions\n\t  this.attrs = attrs\n\t};\n\t\n\tInlineType.prototype.map = function (mapping, span, offset, oldOffset) {\n\t  var from = mapping.map(span.from + oldOffset, this.options.inclusiveLeft ? -1 : 1) - offset\n\t  var to = mapping.map(span.to + oldOffset, this.options.inclusiveRight ? 1 : -1) - offset\n\t  return from >= to ? null : new Decoration(from, to, this)\n\t};\n\t\n\tInlineType.prototype.valid = function (_, span) { return span.from < span.to };\n\t\n\tInlineType.prototype.eq = function (other) {\n\t  return this == other ||\n\t    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n\t     compareObjs(this.options, other.options))\n\t};\n\t\n\tInlineType.is = function (span) { return span.type instanceof InlineType };\n\t\n\tvar NodeType = function(attrs, options) {\n\t  this.attrs = attrs\n\t  this.options = options || noOptions\n\t};\n\t\n\tNodeType.prototype.map = function (mapping, span, offset, oldOffset) {\n\t  var from = mapping.mapResult(span.from + oldOffset, 1)\n\t  if (from.deleted) { return null }\n\t  var to = mapping.mapResult(span.to + oldOffset, -1)\n\t  if (to.deleted || to.pos <= from.pos) { return null }\n\t  return new Decoration(from.pos - offset, to.pos - offset, this)\n\t};\n\t\n\tNodeType.prototype.valid = function (node, span) {\n\t  var ref = node.content.findIndex(span.from);\n\t    var index = ref.index;\n\t    var offset = ref.offset;\n\t  return offset == span.from && offset + node.child(index).nodeSize == span.to\n\t};\n\t\n\tNodeType.prototype.eq = function (other) {\n\t  return this == other ||\n\t    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n\t     compareObjs(this.options, other.options))\n\t};\n\t\n\t// ::- Decorations can be provided to the view (through the\n\t// [`decorations` prop](#view.EditorProps.decorations)) to adjust the\n\t// way the document is drawn. They come in several variants. See the\n\t// static members of this class for details.\n\tvar Decoration = function(from, to, type) {\n\t  this.from = from\n\t  this.to = to\n\t  this.type = type\n\t};\n\t\n\tvar prototypeAccessors = { options: {} };\n\t\n\tDecoration.prototype.copy = function (from, to) {\n\t  return new Decoration(from, to, this.type)\n\t};\n\t\n\tDecoration.prototype.eq = function (other) {\n\t  return this.type.eq(other.type) && this.from == other.from && this.to == other.to\n\t};\n\t\n\tDecoration.prototype.map = function (mapping, offset, oldOffset) {\n\t  return this.type.map(mapping, this, offset, oldOffset)\n\t};\n\t\n\t// :: (number, dom.Node, ?Object) → Decoration\n\t// Creates a widget decoration, which is a DOM node that's shown in\n\t// the document at the given position.\n\t//\n\t// options::- These options are supported:\n\t//\n\t//   associative:: ?string\n\t//   By default, widgets are right-associative, meaning they end\n\t//   up to the right of content inserted at their position. You\n\t//   can set this to `\"left\"` to make it left-associative, so that\n\t//   the inserted content will end up after the widget.\n\t//\n\t//   stopEvent:: ?(event: dom.Event) → bool\n\t//   Can be used to control which DOM events, when they bubble out\n\t//   of this widget, the editor view should ignore.\n\t//\n\t//   key:: ?string\n\t//   When comparing decorations of this type (in order to decide\n\t//   whether it needs to be redrawn), ProseMirror will by default\n\t//   compare the widget DOM node by identity. If you pass a key,\n\t//   that key will be compared instead, which can be useful when\n\t//   you generate decorations on the fly and don't want to store\n\t//   and reuse DOM nodes.\n\tDecoration.widget = function (pos, dom, options) {\n\t  return new Decoration(pos, pos, new WidgetType(dom, options))\n\t};\n\t\n\t// :: (number, number, DecorationAttrs, ?Object) → Decoration\n\t// Creates an inline decoration, which adds the given attributes to\n\t// each inline node between `from` and `to`.\n\t//\n\t// options::- These options are recognized:\n\t//\n\t//   inclusiveLeft:: ?bool\n\t//   Determines how the left side of the decoration is\n\t//   [mapped](#transform.Position_Mapping) when content is\n\t//   inserted directly at that positon. By default, the decoration\n\t//   won't include the new content, but you can set this to `true`\n\t//   to make it inclusive.\n\t//\n\t//   inclusiveRight:: ?bool\n\t//   Determines how the right side of the decoration is mapped.\n\t//   See\n\t//   [`inclusiveLeft`](#view.Decoration^inline^options.inclusiveLeft).\n\tDecoration.inline = function (from, to, attrs, options) {\n\t  return new Decoration(from, to, new InlineType(attrs, options))\n\t};\n\t\n\t// :: (number, number, DecorationAttrs, ?Object) → Decoration\n\t// Creates a node decoration. `from` and `to` should point precisely\n\t// before and after a node in the document. That node, and only that\n\t// node, will receive the given attributes.\n\tDecoration.node = function (from, to, attrs, options) {\n\t  return new Decoration(from, to, new NodeType(attrs, options))\n\t};\n\t\n\t// :: Object\n\t// The options provided when creating this decoration. Can be useful\n\t// if you've stored extra information in that object.\n\tprototypeAccessors.options.get = function () { return this.type.options };\n\t\n\tObject.defineProperties( Decoration.prototype, prototypeAccessors );\n\texports.Decoration = Decoration\n\t\n\t// DecorationAttrs:: interface\n\t// A set of attributes to add to a decorated node. Most properties\n\t// simply directly correspond to DOM attributes of the same name,\n\t// which will be set to the property's value. These are exceptions:\n\t//\n\t//   class:: ?string\n\t//   A CSS class name or a space-separated set of class names to be\n\t//   _added_ to the classes that the node already had.\n\t//\n\t//   style:: ?string\n\t//   A string of CSS to be _added_ to the node's existing `style` property.\n\t//\n\t//   nodeName:: ?string\n\t//   When non-null, the target node is wrapped in a DOM element of\n\t//   this type (and the other attributes are applied to this element).\n\t\n\tvar none = [], noOptions = {}\n\t\n\t// ::- A collection of [decorations](#view.Decoration), organized in\n\t// such a way that the drawing algorithm can efficiently use and\n\t// compare them. This is a persistent data structure—it is not\n\t// modified, updates create a new value.\n\tvar DecorationSet = function(local, children) {\n\t  this.local = local && local.length ? local : none\n\t  this.children = children && children.length ? children : none\n\t};\n\t\n\t// :: (Node, [Decoration]) → DecorationSet\n\t// Create a set of decorations, using the structure of the given\n\t// document.\n\tDecorationSet.create = function (doc, decorations) {\n\t  return decorations.length ? buildTree(decorations, doc, 0, noOptions) : empty\n\t};\n\t\n\t// :: (?number, ?number) → [Decoration]\n\t// Find all decorations in this set which touch the given range\n\t// (including decorations that start or end directly at the\n\t// boundaries). When the arguments are omitted, all decorations in\n\t// the set are collected.\n\tDecorationSet.prototype.find = function (start, end) {\n\t  var result = []\n\t  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0)\n\t  return result\n\t};\n\t\n\tDecorationSet.prototype.findInner = function (start, end, result, offset) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < this.local.length; i++) {\n\t    var span = this$1.local[i]\n\t    if (span.from <= end && span.to >= start)\n\t      { result.push(span.copy(span.from + offset, span.to + offset)) }\n\t  }\n\t  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {\n\t    if (this$1.children[i$1] < end && this$1.children[i$1 + 1] > start) {\n\t      var childOff = this$1.children[i$1] + 1\n\t      this$1.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff)\n\t    }\n\t  }\n\t};\n\t\n\t// :: (Mapping, Node, ?Object) → DecorationSet\n\t// Map the set of decorations in response to a change in the\n\t// document.\n\t//\n\t// options::- An optional set of options.\n\t//\n\t//   onRemove:: ?(decorationOptions: Object)\n\t//   When given, this function will be called for each decoration\n\t//   that gets dropped as a result of the mapping, passing the\n\t//   options of that decoration.\n\tDecorationSet.prototype.map = function (mapping, doc, options) {\n\t  if (this == empty || mapping.maps.length == 0) { return this }\n\t  return this.mapInner(mapping, doc, 0, 0, options || noOptions)\n\t};\n\t\n\tDecorationSet.prototype.mapInner = function (mapping, node, offset, oldOffset, options) {\n\t    var this$1 = this;\n\t\n\t  var newLocal\n\t  for (var i = 0; i < this.local.length; i++) {\n\t    var mapped = this$1.local[i].map(mapping, offset, oldOffset)\n\t    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped) }\n\t    else if (options.onRemove) { options.onRemove(this$1.local[i].options) }\n\t  }\n\t\n\t  if (this.children.length)\n\t    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }\n\t  else\n\t    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }\n\t};\n\t\n\t// :: (Node, [Decoration]) → DecorationSet\n\t// Add the given array of decorations to the ones in the set,\n\t// producing a new set. Needs access to the current document to\n\t// create the appropriate tree structure.\n\tDecorationSet.prototype.add = function (doc, decorations) {\n\t  if (!decorations.length) { return this }\n\t  if (this == empty) { return DecorationSet.create(doc, decorations) }\n\t  return this.addInner(doc, decorations, 0)\n\t};\n\t\n\tDecorationSet.prototype.addInner = function (doc, decorations, offset) {\n\t    var this$1 = this;\n\t\n\t  var children, childIndex = 0\n\t  doc.forEach(function (childNode, childOffset) {\n\t    var baseOffset = childOffset + offset, found\n\t    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }\n\t\n\t    if (!children) { children = this$1.children.slice() }\n\t    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3 }\n\t    if (children[childIndex] == childOffset)\n\t      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1) }\n\t    else\n\t      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noOptions)) }\n\t    childIndex += 3\n\t  })\n\t\n\t  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset)\n\t  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n\t                           children || this.children)\n\t};\n\t\n\t// :: ([Decoration]) → DecorationSet\n\t// Create a new set that contains the decorations in this set, minus\n\t// the ones in the given array.\n\tDecorationSet.prototype.remove = function (decorations) {\n\t  if (decorations.length == 0 || this == empty) { return this }\n\t  return this.removeInner(decorations, 0)\n\t};\n\t\n\tDecorationSet.prototype.removeInner = function (decorations, offset) {\n\t    var this$1 = this;\n\t\n\t  var children = this.children, local = this.local\n\t  for (var i = 0; i < children.length; i += 3) {\n\t    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset\n\t    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {\n\t      if (span.from > from && span.to < to) {\n\t        decorations[j] = null\n\t        ;(found || (found = [])).push(span)\n\t      }\n\t    } }\n\t    if (!found) { continue }\n\t    if (children == this$1.children) { children = this$1.children.slice() }\n\t    var removed = children[i + 2].removeInner(found, from + 1)\n\t    if (removed != empty) {\n\t      children[i + 2] = removed\n\t    } else {\n\t      children.splice(i, 3)\n\t      i -= 3\n\t    }\n\t  }\n\t  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {\n\t    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].type == span$1.type) {\n\t      if (local == this$1.local) { local = this$1.local.slice() }\n\t      local.splice(j$1--, 1)\n\t    } }\n\t  } } }\n\t  if (children == this.children && local == this.local) { return this }\n\t  return local.length || children.length ? new DecorationSet(local, children) : empty\n\t};\n\t\n\tDecorationSet.prototype.forChild = function (offset, node) {\n\t    var this$1 = this;\n\t\n\t  if (this == empty) { return this }\n\t  if (node.isLeaf) { return DecorationSet.empty }\n\t\n\t  var child, local\n\t  for (var i = 0; i < this.children.length; i += 3) { if (this$1.children[i] >= offset) {\n\t    if (this$1.children[i] == offset) { child = this$1.children[i + 2] }\n\t    break\n\t  } }\n\t  var start = offset + 1, end = start + node.content.size\n\t  for (var i$1 = 0; i$1 < this.local.length; i$1++) {\n\t    var dec = this$1.local[i$1]\n\t    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n\t      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start\n\t      if (from < to) { (local || (local = [])).push(dec.copy(from, to)) }\n\t    }\n\t  }\n\t  if (local) {\n\t    var localSet = new DecorationSet(local)\n\t    return child ? new DecorationGroup([localSet, child]) : localSet\n\t  }\n\t  return child || empty\n\t};\n\t\n\tDecorationSet.prototype.eq = function (other) {\n\t    var this$1 = this;\n\t\n\t  if (this == other) { return true }\n\t  if (!(other instanceof DecorationSet) ||\n\t      this.local.length != other.local.length ||\n\t      this.children.length != other.children.length) { return false }\n\t  for (var i = 0; i < this.local.length; i++)\n\t    { if (!this$1.local[i].eq(other.local[i])) { return false } }\n\t  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)\n\t    { if (this$1.children[i$1] != other.children[i$1] ||\n\t        this$1.children[i$1 + 1] != other.children[i$1 + 1] ||\n\t        !this$1.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }\n\t  return false\n\t};\n\t\n\tDecorationSet.prototype.locals = function (node) {\n\t  return removeOverlap(this.localsInner(node))\n\t};\n\t\n\tDecorationSet.prototype.localsInner = function (node) {\n\t    var this$1 = this;\n\t\n\t  if (this == empty) { return none }\n\t  if (node.isTextblock || !this.local.some(InlineType.is)) { return this.local }\n\t  var result = []\n\t  for (var i = 0; i < this.local.length; i++) {\n\t    if (!(this$1.local[i].type instanceof InlineType))\n\t      { result.push(this$1.local[i]) }\n\t  }\n\t  return result\n\t};\n\texports.DecorationSet = DecorationSet\n\t\n\tvar empty = new DecorationSet()\n\t\n\t// :: DecorationSet\n\t// The empty set of decorations.\n\tDecorationSet.empty = empty\n\t\n\tvar DecorationGroup = function(members) {\n\t  this.members = members\n\t};\n\t\n\tDecorationGroup.prototype.forChild = function (offset, child) {\n\t    var this$1 = this;\n\t\n\t  if (child.isLeaf) { return DecorationSet.empty }\n\t  var found = []\n\t  for (var i = 0; i < this.members.length; i++) {\n\t    var result = this$1.members[i].forChild(offset, child)\n\t    if (result == empty) { continue }\n\t    if (result instanceof DecorationGroup) { found = found.concat(result.members) }\n\t    else { found.push(result) }\n\t  }\n\t  return DecorationGroup.from(found)\n\t};\n\t\n\tDecorationGroup.prototype.eq = function (other) {\n\t    var this$1 = this;\n\t\n\t  if (!(other instanceof DecorationGroup) ||\n\t      other.members.length != this.members.length) { return false }\n\t  for (var i = 0; i < this.members.length; i++)\n\t    { if (!this$1.members[i].eq(other.members[i])) { return false } }\n\t  return true\n\t};\n\t\n\tDecorationGroup.prototype.locals = function (node) {\n\t    var this$1 = this;\n\t\n\t  var result, sorted = true\n\t  for (var i = 0; i < this.members.length; i++) {\n\t    var locals = this$1.members[i].localsInner(node)\n\t    if (!locals.length) { continue }\n\t    if (!result) {\n\t      result = locals\n\t    } else {\n\t      if (sorted) {\n\t        result = result.slice()\n\t        sorted = false\n\t      }\n\t      for (var j = 0; j < locals.length; j++) { result.push(locals[j]) }\n\t    }\n\t  }\n\t  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n\t};\n\t\n\tDecorationGroup.from = function (members) {\n\t  switch (members.length) {\n\t    case 0: return empty\n\t    case 1: return members[0]\n\t    default: return new DecorationGroup(members)\n\t  }\n\t};\n\texports.DecorationGroup = DecorationGroup\n\t\n\tfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n\t  var children = oldChildren.slice()\n\t\n\t  // Mark the children that are directly touched by changes, and\n\t  // move those that are after the changes.\n\t  var shift = function (oldStart, oldEnd, newStart, newEnd) {\n\t    for (var i = 0; i < children.length; i += 3) {\n\t      var end = children[i + 1], dSize = (void 0)\n\t      if (end == -1 || oldStart > end + oldOffset) { continue }\n\t      if (oldEnd >= children[i] + oldOffset) {\n\t        children[i + 1] = -1\n\t      } else if (dSize = (newEnd - newStart) - (oldEnd - oldStart)) {\n\t        children[i] += dSize\n\t        children[i + 1] += dSize\n\t      }\n\t    }\n\t  }\n\t  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift) }\n\t\n\t  // Find the child nodes that still correspond to a single node,\n\t  // recursively call mapInner on them and update their positions.\n\t  var mustRebuild = false\n\t  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes\n\t    var from = mapping.map(children[i$1] + oldOffset), fromLocal = from - offset\n\t    if (fromLocal < 0 || fromLocal >= node.content.size) {\n\t      mustRebuild = true\n\t      continue\n\t    }\n\t    // Must read oldChildren because children was tagged with -1\n\t    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset\n\t    var ref = node.content.findIndex(fromLocal);\n\t    var index = ref.index;\n\t    var childOffset = ref.offset;\n\t    var childNode = node.maybeChild(index)\n\t    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n\t      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, children[i$1] + oldOffset + 1, options)\n\t      if (mapped != empty) {\n\t        children[i$1] = fromLocal\n\t        children[i$1 + 1] = toLocal\n\t        children[i$1 + 2] = mapped\n\t      } else {\n\t        children.splice(i$1, 3)\n\t        i$1 -= 3\n\t      }\n\t    } else {\n\t      mustRebuild = true\n\t    }\n\t  } }\n\t\n\t  // Remaining children must be collected and rebuilt into the appropriate structure\n\t  if (mustRebuild) {\n\t    var decorations = mapAndGatherRemainingDecorations(children, newLocal ? moveSpans(newLocal, offset) : [], mapping, oldOffset, options)\n\t    var built = buildTree(decorations, node, 0, options)\n\t    newLocal = built.local\n\t    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] == -1) {\n\t      children.splice(i$2, 3)\n\t      i$2 -= 3\n\t    } }\n\t    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {\n\t      var from$1 = built.children[i$3]\n\t      while (j < children.length && children[j] < from$1) { j += 3 }\n\t      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2])\n\t    }\n\t  }\n\t\n\t  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n\t}\n\t\n\tfunction moveSpans(spans, offset) {\n\t  if (!offset || !spans.length) { return spans }\n\t  var result = []\n\t  for (var i = 0; i < spans.length; i++) {\n\t    var span = spans[i]\n\t    result.push(new Decoration(span.from + offset, span.to + offset, span.type))\n\t  }\n\t  return result\n\t}\n\t\n\tfunction mapAndGatherRemainingDecorations(children, decorations, mapping, oldOffset, options) {\n\t  // Gather all decorations from the remaining marked children\n\t  function gather(set, oldOffset) {\n\t    for (var i = 0; i < set.local.length; i++) {\n\t      var mapped = set.local[i].map(mapping, 0, oldOffset)\n\t      if (mapped) { decorations.push(mapped) }\n\t      else if (options.onRemove) { options.onRemove(set.local[i].options) }\n\t    }\n\t    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)\n\t      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1) }\n\t  }\n\t  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)\n\t    { gather(children[i + 2], children[i] + oldOffset + 1) } }\n\t\n\t  return decorations\n\t}\n\t\n\tfunction takeSpansForNode(spans, node, offset) {\n\t  if (node.isLeaf) { return null }\n\t  var end = offset + node.nodeSize, found = null\n\t  for (var i = 0, span = (void 0); i < spans.length; i++) {\n\t    if ((span = spans[i]) && span.from > offset && span.to < end) {\n\t      ;(found || (found = [])).push(span)\n\t      spans[i] = null\n\t    }\n\t  }\n\t  return found\n\t}\n\t\n\tfunction withoutNulls(array) {\n\t  var result = []\n\t  for (var i = 0; i < array.length; i++)\n\t    { if (array[i] != null) { result.push(array[i]) } }\n\t  return result\n\t}\n\t\n\t// : ([Decoration], Node, number) → DecorationSet\n\t// Build up a tree that corresponds to a set of decorations. `offset`\n\t// is a base offset that should be subtractet from the `from` and `to`\n\t// positions in the spans (so that we don't have to allocate new spans\n\t// for recursive calls).\n\tfunction buildTree(spans, node, offset, options) {\n\t  var children = [], hasNulls = false\n\t  node.forEach(function (childNode, localStart) {\n\t    var found = takeSpansForNode(spans, childNode, localStart + offset)\n\t    if (found) {\n\t      hasNulls = true\n\t      var subtree = buildTree(found, childNode, offset + localStart + 1, options)\n\t      if (subtree != empty)\n\t        { children.push(localStart, localStart + childNode.nodeSize, subtree) }\n\t    }\n\t  })\n\t  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos)\n\t  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {\n\t    if (options.onRemove) { options.onRemove(locals[i].options) }\n\t    locals.splice(i--, 1)\n\t  } }\n\t  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n\t}\n\t\n\t// : (Decoration, Decoration) → number\n\t// Used to sort decorations so that ones with a low start position\n\t// come first, and within a set with the same start position, those\n\t// with an smaller end position come first.\n\tfunction byPos(a, b) {\n\t  return a.from - b.from || a.to - b.to\n\t}\n\t\n\t// : ([Decoration]) → [Decorations]\n\t// Scan a sorted array of decorations for partially overlapping spans,\n\t// and split those so that only fully overlapping spans are left (to\n\t// make subsequent rendering easier). Will return the input array if\n\t// no partially overlapping spans are found (the common case).\n\tfunction removeOverlap(spans) {\n\t  var working = spans\n\t  for (var i = 0; i < working.length - 1; i++) {\n\t    var span = working[i]\n\t    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {\n\t      var next = working[j]\n\t      if (next.from == span.from) {\n\t        if (next.to != span.to) {\n\t          if (working == spans) { working = spans.slice() }\n\t          // Followed by a partially overlapping larger span. Split that\n\t          // span.\n\t          working[j] = next.copy(next.from, span.to)\n\t          insertAhead(working, j + 1, next.copy(span.to, next.to))\n\t        }\n\t        continue\n\t      } else {\n\t        if (next.from < span.to) {\n\t          if (working == spans) { working = spans.slice() }\n\t          // The end of this one overlaps with a subsequent span. Split\n\t          // this one.\n\t          working[i] = span.copy(span.from, next.from)\n\t          insertAhead(working, j, span.copy(next.from, span.to))\n\t        }\n\t        break\n\t      }\n\t    } }\n\t  }\n\t  return working\n\t}\n\texports.removeOverlap = removeOverlap\n\t\n\tfunction insertAhead(array, i, deco) {\n\t  while (i < array.length && byPos(deco, array[i]) > 0) { i++ }\n\t  array.splice(i, 0, deco)\n\t}\n\t\n\t// : (EditorView) → union<DecorationSet, DecorationGroup>\n\t// Get the decorations associated with the current props of a view.\n\tfunction viewDecorations(view) {\n\t  var found = []\n\t  view.someProp(\"decorations\", function (f) {\n\t    var result = f(view.state)\n\t    if (result && result != empty) { found.push(result) }\n\t  })\n\t  return DecorationGroup.from(found)\n\t}\n\texports.viewDecorations = viewDecorations\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar EditorState = ref.EditorState;\n\tvar ref$1 = __webpack_require__(4);\n\tvar Mapping = ref$1.Mapping;\n\t\n\tvar TrackedRecord = function(prev, mapping, state) {\n\t  this.prev = prev\n\t  this.mapping = mapping\n\t  this.state = state\n\t};\n\t\n\tvar TrackMappings = function(state) {\n\t  this.seen = [new TrackedRecord(null, null, state)]\n\t  // Kludge to listen to state changes globally in order to be able\n\t  // to find mappings from a given state to another.\n\t  EditorState.addApplyListener(this.track = this.track.bind(this))\n\t};\n\t\n\tTrackMappings.prototype.destroy = function () {\n\t  EditorState.removeApplyListener(this.track)\n\t};\n\t\n\tTrackMappings.prototype.find = function (state) {\n\t    var this$1 = this;\n\t\n\t  for (var i = this.seen.length - 1; i >= 0; i--) {\n\t    var record = this$1.seen[i]\n\t    if (record.state == state) { return record }\n\t  }\n\t};\n\t\n\tTrackMappings.prototype.track = function (old, tr, state) {\n\t  var found = this.seen.length < 200 ? this.find(old) : null\n\t  if (found)\n\t    { this.seen.push(new TrackedRecord(found, tr.docChanged ? tr.mapping : null, state)) }\n\t};\n\t\n\tTrackMappings.prototype.getMapping = function (state) {\n\t  var found = this.find(state)\n\t  if (!found) { return null }\n\t  var mappings = []\n\t  for (var rec = found; rec; rec = rec.prev)\n\t    { if (rec.mapping) { mappings.push(rec.mapping) } }\n\t  var result = new Mapping\n\t  for (var i = mappings.length - 1; i >= 0; i--)\n\t    { result.appendMapping(mappings[i]) }\n\t  return result\n\t};\n\texports.TrackMappings = TrackMappings\n\n\n/***/ },\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(84), __esModule: true };\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(86), __esModule: true };\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _from = __webpack_require__(81);\n\t\n\tvar _from2 = _interopRequireDefault(_from);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t      arr2[i] = arr[i];\n\t    }\n\t\n\t    return arr2;\n\t  } else {\n\t    return (0, _from2.default)(arr);\n\t  }\n\t};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(113);\n\t__webpack_require__(111);\n\tmodule.exports = __webpack_require__(7).Array.from;\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core  = __webpack_require__(7)\n\t  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\n\tmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n\t  return $JSON.stringify.apply($JSON, arguments);\n\t};\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(112);\n\tmodule.exports = __webpack_require__(7).Object.assign;\n\n/***/ },\n/* 87 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(44)\n\t  , toLength  = __webpack_require__(45)\n\t  , toIndex   = __webpack_require__(108);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(36)\n\t  , TAG = __webpack_require__(3)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $defineProperty = __webpack_require__(13)\n\t  , createDesc      = __webpack_require__(25);\n\t\n\tmodule.exports = function(object, index, value){\n\t  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n\t  else object[index] = value;\n\t};\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8).document && document.documentElement;\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(10) && !__webpack_require__(22)(function(){\n\t  return Object.defineProperty(__webpack_require__(38)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// check on default Array iterator\n\tvar Iterators  = __webpack_require__(24)\n\t  , ITERATOR   = __webpack_require__(3)('iterator')\n\t  , ArrayProto = Array.prototype;\n\t\n\tmodule.exports = function(it){\n\t  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n\t};\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// call something on iterator step with safe closing on error\n\tvar anObject = __webpack_require__(9);\n\tmodule.exports = function(iterator, fn, value, entries){\n\t  try {\n\t    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch(e){\n\t    var ret = iterator['return'];\n\t    if(ret !== undefined)anObject(ret.call(iterator));\n\t    throw e;\n\t  }\n\t};\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(100)\n\t  , descriptor     = __webpack_require__(25)\n\t  , setToStringTag = __webpack_require__(42)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(12)(IteratorPrototype, __webpack_require__(3)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(98)\n\t  , $export        = __webpack_require__(21)\n\t  , redefine       = __webpack_require__(106)\n\t  , hide           = __webpack_require__(12)\n\t  , has            = __webpack_require__(11)\n\t  , Iterators      = __webpack_require__(24)\n\t  , $iterCreate    = __webpack_require__(95)\n\t  , setToStringTag = __webpack_require__(42)\n\t  , getPrototypeOf = __webpack_require__(103)\n\t  , ITERATOR       = __webpack_require__(3)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ITERATOR     = __webpack_require__(3)('iterator')\n\t  , SAFE_CLOSING = false;\n\t\n\ttry {\n\t  var riter = [7][ITERATOR]();\n\t  riter['return'] = function(){ SAFE_CLOSING = true; };\n\t  Array.from(riter, function(){ throw 2; });\n\t} catch(e){ /* empty */ }\n\t\n\tmodule.exports = function(exec, skipClosing){\n\t  if(!skipClosing && !SAFE_CLOSING)return false;\n\t  var safe = false;\n\t  try {\n\t    var arr  = [7]\n\t      , iter = arr[ITERATOR]();\n\t    iter.next = function(){ return {done: safe = true}; };\n\t    arr[ITERATOR] = function(){ return iter; };\n\t    exec(arr);\n\t  } catch(e){ /* empty */ }\n\t  return safe;\n\t};\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys  = __webpack_require__(41)\n\t  , gOPS     = __webpack_require__(102)\n\t  , pIE      = __webpack_require__(105)\n\t  , toObject = __webpack_require__(28)\n\t  , IObject  = __webpack_require__(40)\n\t  , $assign  = Object.assign;\n\t\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(22)(function(){\n\t  var A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , aLen  = arguments.length\n\t    , index = 1\n\t    , getSymbols = gOPS.f\n\t    , isEnum     = pIE.f;\n\t  while(aLen > index){\n\t    var S      = IObject(arguments[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(9)\n\t  , dPs         = __webpack_require__(101)\n\t  , enumBugKeys = __webpack_require__(39)\n\t  , IE_PROTO    = __webpack_require__(26)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(38)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(91).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(13)\n\t  , anObject = __webpack_require__(9)\n\t  , getKeys  = __webpack_require__(41);\n\t\n\tmodule.exports = __webpack_require__(10) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(11)\n\t  , toObject    = __webpack_require__(28)\n\t  , IE_PROTO    = __webpack_require__(26)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(11)\n\t  , toIObject    = __webpack_require__(44)\n\t  , arrayIndexOf = __webpack_require__(88)(false)\n\t  , IE_PROTO     = __webpack_require__(26)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(12);\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(27)\n\t  , defined   = __webpack_require__(20);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(27)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(23);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(89)\n\t  , ITERATOR  = __webpack_require__(3)('iterator')\n\t  , Iterators = __webpack_require__(24);\n\tmodule.exports = __webpack_require__(7).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ctx            = __webpack_require__(37)\n\t  , $export        = __webpack_require__(21)\n\t  , toObject       = __webpack_require__(28)\n\t  , call           = __webpack_require__(94)\n\t  , isArrayIter    = __webpack_require__(93)\n\t  , toLength       = __webpack_require__(45)\n\t  , createProperty = __webpack_require__(90)\n\t  , getIterFn      = __webpack_require__(110);\n\t\n\t$export($export.S + $export.F * !__webpack_require__(97)(function(iter){ Array.from(iter); }), 'Array', {\n\t  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n\t  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n\t    var O       = toObject(arrayLike)\n\t      , C       = typeof this == 'function' ? this : Array\n\t      , aLen    = arguments.length\n\t      , mapfn   = aLen > 1 ? arguments[1] : undefined\n\t      , mapping = mapfn !== undefined\n\t      , index   = 0\n\t      , iterFn  = getIterFn(O)\n\t      , length, result, step, iterator;\n\t    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n\t    // if object isn't iterable or it's array with default iterator - use simple case\n\t    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n\t      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n\t        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n\t      }\n\t    } else {\n\t      length = toLength(O.length);\n\t      for(result = new C(length); length > index; index++){\n\t        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n\t      }\n\t    }\n\t    result.length = index;\n\t    return result;\n\t  }\n\t});\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(21);\n\t\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(99)});\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(107)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(96)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n\t * @license MIT */\n\t\n\t;(function(root, factory) {\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory();\n\t  } else {\n\t    root.NProgress = factory();\n\t  }\n\t\n\t})(this, function() {\n\t  var NProgress = {};\n\t\n\t  NProgress.version = '0.2.0';\n\t\n\t  var Settings = NProgress.settings = {\n\t    minimum: 0.08,\n\t    easing: 'ease',\n\t    positionUsing: '',\n\t    speed: 200,\n\t    trickle: true,\n\t    trickleRate: 0.02,\n\t    trickleSpeed: 800,\n\t    showSpinner: true,\n\t    barSelector: '[role=\"bar\"]',\n\t    spinnerSelector: '[role=\"spinner\"]',\n\t    parent: 'body',\n\t    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n\t  };\n\t\n\t  /**\n\t   * Updates configuration.\n\t   *\n\t   *     NProgress.configure({\n\t   *       minimum: 0.1\n\t   *     });\n\t   */\n\t  NProgress.configure = function(options) {\n\t    var key, value;\n\t    for (key in options) {\n\t      value = options[key];\n\t      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Last number.\n\t   */\n\t\n\t  NProgress.status = null;\n\t\n\t  /**\n\t   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n\t   *\n\t   *     NProgress.set(0.4);\n\t   *     NProgress.set(1.0);\n\t   */\n\t\n\t  NProgress.set = function(n) {\n\t    var started = NProgress.isStarted();\n\t\n\t    n = clamp(n, Settings.minimum, 1);\n\t    NProgress.status = (n === 1 ? null : n);\n\t\n\t    var progress = NProgress.render(!started),\n\t        bar      = progress.querySelector(Settings.barSelector),\n\t        speed    = Settings.speed,\n\t        ease     = Settings.easing;\n\t\n\t    progress.offsetWidth; /* Repaint */\n\t\n\t    queue(function(next) {\n\t      // Set positionUsing if it hasn't already been set\n\t      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\t\n\t      // Add transition\n\t      css(bar, barPositionCSS(n, speed, ease));\n\t\n\t      if (n === 1) {\n\t        // Fade out\n\t        css(progress, { \n\t          transition: 'none', \n\t          opacity: 1 \n\t        });\n\t        progress.offsetWidth; /* Repaint */\n\t\n\t        setTimeout(function() {\n\t          css(progress, { \n\t            transition: 'all ' + speed + 'ms linear', \n\t            opacity: 0 \n\t          });\n\t          setTimeout(function() {\n\t            NProgress.remove();\n\t            next();\n\t          }, speed);\n\t        }, speed);\n\t      } else {\n\t        setTimeout(next, speed);\n\t      }\n\t    });\n\t\n\t    return this;\n\t  };\n\t\n\t  NProgress.isStarted = function() {\n\t    return typeof NProgress.status === 'number';\n\t  };\n\t\n\t  /**\n\t   * Shows the progress bar.\n\t   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n\t   *\n\t   *     NProgress.start();\n\t   *\n\t   */\n\t  NProgress.start = function() {\n\t    if (!NProgress.status) NProgress.set(0);\n\t\n\t    var work = function() {\n\t      setTimeout(function() {\n\t        if (!NProgress.status) return;\n\t        NProgress.trickle();\n\t        work();\n\t      }, Settings.trickleSpeed);\n\t    };\n\t\n\t    if (Settings.trickle) work();\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Hides the progress bar.\n\t   * This is the *sort of* the same as setting the status to 100%, with the\n\t   * difference being `done()` makes some placebo effect of some realistic motion.\n\t   *\n\t   *     NProgress.done();\n\t   *\n\t   * If `true` is passed, it will show the progress bar even if its hidden.\n\t   *\n\t   *     NProgress.done(true);\n\t   */\n\t\n\t  NProgress.done = function(force) {\n\t    if (!force && !NProgress.status) return this;\n\t\n\t    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n\t  };\n\t\n\t  /**\n\t   * Increments by a random amount.\n\t   */\n\t\n\t  NProgress.inc = function(amount) {\n\t    var n = NProgress.status;\n\t\n\t    if (!n) {\n\t      return NProgress.start();\n\t    } else {\n\t      if (typeof amount !== 'number') {\n\t        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n\t      }\n\t\n\t      n = clamp(n + amount, 0, 0.994);\n\t      return NProgress.set(n);\n\t    }\n\t  };\n\t\n\t  NProgress.trickle = function() {\n\t    return NProgress.inc(Math.random() * Settings.trickleRate);\n\t  };\n\t\n\t  /**\n\t   * Waits for all supplied jQuery promises and\n\t   * increases the progress as the promises resolve.\n\t   *\n\t   * @param $promise jQUery Promise\n\t   */\n\t  (function() {\n\t    var initial = 0, current = 0;\n\t\n\t    NProgress.promise = function($promise) {\n\t      if (!$promise || $promise.state() === \"resolved\") {\n\t        return this;\n\t      }\n\t\n\t      if (current === 0) {\n\t        NProgress.start();\n\t      }\n\t\n\t      initial++;\n\t      current++;\n\t\n\t      $promise.always(function() {\n\t        current--;\n\t        if (current === 0) {\n\t            initial = 0;\n\t            NProgress.done();\n\t        } else {\n\t            NProgress.set((initial - current) / initial);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    };\n\t\n\t  })();\n\t\n\t  /**\n\t   * (Internal) renders the progress bar markup based on the `template`\n\t   * setting.\n\t   */\n\t\n\t  NProgress.render = function(fromStart) {\n\t    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\t\n\t    addClass(document.documentElement, 'nprogress-busy');\n\t    \n\t    var progress = document.createElement('div');\n\t    progress.id = 'nprogress';\n\t    progress.innerHTML = Settings.template;\n\t\n\t    var bar      = progress.querySelector(Settings.barSelector),\n\t        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n\t        parent   = document.querySelector(Settings.parent),\n\t        spinner;\n\t    \n\t    css(bar, {\n\t      transition: 'all 0 linear',\n\t      transform: 'translate3d(' + perc + '%,0,0)'\n\t    });\n\t\n\t    if (!Settings.showSpinner) {\n\t      spinner = progress.querySelector(Settings.spinnerSelector);\n\t      spinner && removeElement(spinner);\n\t    }\n\t\n\t    if (parent != document.body) {\n\t      addClass(parent, 'nprogress-custom-parent');\n\t    }\n\t\n\t    parent.appendChild(progress);\n\t    return progress;\n\t  };\n\t\n\t  /**\n\t   * Removes the element. Opposite of render().\n\t   */\n\t\n\t  NProgress.remove = function() {\n\t    removeClass(document.documentElement, 'nprogress-busy');\n\t    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n\t    var progress = document.getElementById('nprogress');\n\t    progress && removeElement(progress);\n\t  };\n\t\n\t  /**\n\t   * Checks if the progress bar is rendered.\n\t   */\n\t\n\t  NProgress.isRendered = function() {\n\t    return !!document.getElementById('nprogress');\n\t  };\n\t\n\t  /**\n\t   * Determine which positioning CSS rule to use.\n\t   */\n\t\n\t  NProgress.getPositioningCSS = function() {\n\t    // Sniff on document.body.style\n\t    var bodyStyle = document.body.style;\n\t\n\t    // Sniff prefixes\n\t    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n\t                       ('MozTransform' in bodyStyle) ? 'Moz' :\n\t                       ('msTransform' in bodyStyle) ? 'ms' :\n\t                       ('OTransform' in bodyStyle) ? 'O' : '';\n\t\n\t    if (vendorPrefix + 'Perspective' in bodyStyle) {\n\t      // Modern browsers with 3D support, e.g. Webkit, IE10\n\t      return 'translate3d';\n\t    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n\t      // Browsers without 3D support, e.g. IE9\n\t      return 'translate';\n\t    } else {\n\t      // Browsers without translate() support, e.g. IE7-8\n\t      return 'margin';\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Helpers\n\t   */\n\t\n\t  function clamp(n, min, max) {\n\t    if (n < min) return min;\n\t    if (n > max) return max;\n\t    return n;\n\t  }\n\t\n\t  /**\n\t   * (Internal) converts a percentage (`0..1`) to a bar translateX\n\t   * percentage (`-100%..0%`).\n\t   */\n\t\n\t  function toBarPerc(n) {\n\t    return (-1 + n) * 100;\n\t  }\n\t\n\t\n\t  /**\n\t   * (Internal) returns the correct CSS for changing the bar's\n\t   * position given an n percentage, and speed and ease from Settings\n\t   */\n\t\n\t  function barPositionCSS(n, speed, ease) {\n\t    var barCSS;\n\t\n\t    if (Settings.positionUsing === 'translate3d') {\n\t      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n\t    } else if (Settings.positionUsing === 'translate') {\n\t      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n\t    } else {\n\t      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n\t    }\n\t\n\t    barCSS.transition = 'all '+speed+'ms '+ease;\n\t\n\t    return barCSS;\n\t  }\n\t\n\t  /**\n\t   * (Internal) Queues a function to be executed.\n\t   */\n\t\n\t  var queue = (function() {\n\t    var pending = [];\n\t    \n\t    function next() {\n\t      var fn = pending.shift();\n\t      if (fn) {\n\t        fn(next);\n\t      }\n\t    }\n\t\n\t    return function(fn) {\n\t      pending.push(fn);\n\t      if (pending.length == 1) next();\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * (Internal) Applies css properties to an element, similar to the jQuery \n\t   * css method.\n\t   *\n\t   * While this helper does assist with vendor prefixed property names, it \n\t   * does not perform any manipulation of values prior to setting styles.\n\t   */\n\t\n\t  var css = (function() {\n\t    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n\t        cssProps    = {};\n\t\n\t    function camelCase(string) {\n\t      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n\t        return letter.toUpperCase();\n\t      });\n\t    }\n\t\n\t    function getVendorProp(name) {\n\t      var style = document.body.style;\n\t      if (name in style) return name;\n\t\n\t      var i = cssPrefixes.length,\n\t          capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t          vendorName;\n\t      while (i--) {\n\t        vendorName = cssPrefixes[i] + capName;\n\t        if (vendorName in style) return vendorName;\n\t      }\n\t\n\t      return name;\n\t    }\n\t\n\t    function getStyleProp(name) {\n\t      name = camelCase(name);\n\t      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n\t    }\n\t\n\t    function applyCss(element, prop, value) {\n\t      prop = getStyleProp(prop);\n\t      element.style[prop] = value;\n\t    }\n\t\n\t    return function(element, properties) {\n\t      var args = arguments,\n\t          prop, \n\t          value;\n\t\n\t      if (args.length == 2) {\n\t        for (prop in properties) {\n\t          value = properties[prop];\n\t          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n\t        }\n\t      } else {\n\t        applyCss(element, args[1], args[2]);\n\t      }\n\t    }\n\t  })();\n\t\n\t  /**\n\t   * (Internal) Determines if an element or space separated list of class names contains a class name.\n\t   */\n\t\n\t  function hasClass(element, name) {\n\t    var list = typeof element == 'string' ? element : classList(element);\n\t    return list.indexOf(' ' + name + ' ') >= 0;\n\t  }\n\t\n\t  /**\n\t   * (Internal) Adds a class to an element.\n\t   */\n\t\n\t  function addClass(element, name) {\n\t    var oldList = classList(element),\n\t        newList = oldList + name;\n\t\n\t    if (hasClass(oldList, name)) return; \n\t\n\t    // Trim the opening space.\n\t    element.className = newList.substring(1);\n\t  }\n\t\n\t  /**\n\t   * (Internal) Removes a class from an element.\n\t   */\n\t\n\t  function removeClass(element, name) {\n\t    var oldList = classList(element),\n\t        newList;\n\t\n\t    if (!hasClass(element, name)) return;\n\t\n\t    // Replace the class name.\n\t    newList = oldList.replace(' ' + name + ' ', ' ');\n\t\n\t    // Trim the opening and closing spaces.\n\t    element.className = newList.substring(1, newList.length - 1);\n\t  }\n\t\n\t  /**\n\t   * (Internal) Gets a space separated list of the class names on the element. \n\t   * The list is wrapped with a single space on each end to facilitate finding \n\t   * matches within the list.\n\t   */\n\t\n\t  function classList(element) {\n\t    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n\t  }\n\t\n\t  /**\n\t   * (Internal) Removes an element from the DOM.\n\t   */\n\t\n\t  function removeElement(element) {\n\t    element && element.parentNode && element.parentNode.removeChild(element);\n\t  }\n\t\n\t  return NProgress;\n\t});\n\t\n\n\n/***/ },\n/* 134 */\n/***/ function(module, exports) {\n\n\t// ::- Persistent data structure representing an ordered mapping from\n\t// strings to values, with some convenient update methods.\n\tfunction OrderedMap(content) {\n\t  this.content = content\n\t}\n\t\n\tOrderedMap.prototype = {\n\t  constructor: OrderedMap,\n\t\n\t  find: function(key) {\n\t    for (var i = 0; i < this.content.length; i += 2)\n\t      if (this.content[i] === key) return i\n\t    return -1\n\t  },\n\t\n\t  // :: (string) → ?any\n\t  // Retrieve the value stored under `key`, or return undefined when\n\t  // no such key exists.\n\t  get: function(key) {\n\t    var found = this.find(key)\n\t    return found == -1 ? undefined : this.content[found + 1]\n\t  },\n\t\n\t  // :: (string, any, ?string) → OrderedMap\n\t  // Create a new map by replacing the value of `key` with a new\n\t  // value, or adding a binding to the end of the map. If `newKey` is\n\t  // given, the key of the binding will be replaced with that key.\n\t  update: function(key, value, newKey) {\n\t    var self = newKey && newKey != key ? this.remove(newKey) : this\n\t    var found = self.find(key), content = self.content.slice()\n\t    if (found == -1) {\n\t      content.push(newKey || key, value)\n\t    } else {\n\t      content[found + 1] = value\n\t      if (newKey) content[found] = newKey\n\t    }\n\t    return new OrderedMap(content)\n\t  },\n\t\n\t  // :: (string) → OrderedMap\n\t  // Return a map with the given key removed, if it existed.\n\t  remove: function(key) {\n\t    var found = this.find(key)\n\t    if (found == -1) return this\n\t    var content = this.content.slice()\n\t    content.splice(found, 2)\n\t    return new OrderedMap(content)\n\t  },\n\t\n\t  // :: (string, any) → OrderedMap\n\t  // Add a new key to the start of the map.\n\t  addToStart: function(key, value) {\n\t    return new OrderedMap([key, value].concat(this.remove(key).content))\n\t  },\n\t\n\t  // :: (string, any) → OrderedMap\n\t  // Add a new key to the end of the map.\n\t  addToEnd: function(key, value) {\n\t    var content = this.remove(key).content.slice()\n\t    content.push(key, value)\n\t    return new OrderedMap(content)\n\t  },\n\t\n\t  // :: (string, string, any) → OrderedMap\n\t  // Add a key after the given key. If `place` is not found, the new\n\t  // key is added to the end.\n\t  addBefore: function(place, key, value) {\n\t    var without = this.remove(key), content = without.content.slice()\n\t    var found = without.find(place)\n\t    content.splice(found == -1 ? content.length : found, 0, key, value)\n\t    return new OrderedMap(content)\n\t  },\n\t\n\t  // :: ((key: string, value: any))\n\t  // Call the given function for each key/value pair in the map, in\n\t  // order.\n\t  forEach: function(f) {\n\t    for (var i = 0; i < this.content.length; i += 2)\n\t      f(this.content[i], this.content[i + 1])\n\t  },\n\t\n\t  // :: (union<Object, OrderedMap>) → OrderedMap\n\t  // Create a new map by prepending the keys in this map that don't\n\t  // appear in `map` before the keys in `map`.\n\t  prepend: function(map) {\n\t    map = OrderedMap.from(map)\n\t    if (!map.size) return this\n\t    return new OrderedMap(map.content.concat(this.subtract(map).content))\n\t  },\n\t\n\t  // :: (union<Object, OrderedMap>) → OrderedMap\n\t  // Create a new map by appending the keys in this map that don't\n\t  // appear in `map` after the keys in `map`.\n\t  append: function(map) {\n\t    map = OrderedMap.from(map)\n\t    if (!map.size) return this\n\t    return new OrderedMap(this.subtract(map).content.concat(map.content))\n\t  },\n\t\n\t  // :: (union<Object, OrderedMap>) → OrderedMap\n\t  // Create a map containing all the keys in this map that don't\n\t  // appear in `map`.\n\t  subtract: function(map) {\n\t    var result = this\n\t    map = OrderedMap.from(map)\n\t    for (var i = 0; i < map.content.length; i += 2)\n\t      result = result.remove(map.content[i])\n\t    return result\n\t  },\n\t\n\t  // :: number\n\t  // The amount of keys in this map.\n\t  get size() {\n\t    return this.content.length >> 1\n\t  }\n\t}\n\t\n\t// :: (?union<Object, OrderedMap>) → OrderedMap\n\t// Return a map with the given content. If null, create an empty\n\t// map. If given an ordered map, return that map itself. If given an\n\t// object, create a map from the object's properties.\n\tOrderedMap.from = function(value) {\n\t  if (value instanceof OrderedMap) return value\n\t  var content = []\n\t  if (value) for (var prop in value) content.push(prop, value[prop])\n\t  return new OrderedMap(content)\n\t}\n\t\n\tmodule.exports = OrderedMap\n\n\n/***/ },\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar Plugin = ref.Plugin;\n\tvar ref$1 = __webpack_require__(34);\n\tvar Decoration = ref$1.Decoration;\n\tvar DecorationSet = ref$1.DecorationSet;\n\t\n\tvar gecko = typeof navigator != \"undefined\" && /gecko\\/\\d/i.test(navigator.userAgent)\n\tvar linux = typeof navigator != \"undefined\" && /linux/i.test(navigator.platform)\n\t\n\tfunction dropCursor(options) {\n\t  function dispatch(view, data) {\n\t    view.dispatch(view.state.tr.setMeta(plugin, data))\n\t  }\n\t\n\t  var timeout = null\n\t  function scheduleRemoval(view) {\n\t    clearTimeout(timeout)\n\t    timeout = setTimeout(function () {\n\t      if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n\t    }, 1000)\n\t  }\n\t\n\t  var plugin = new Plugin({\n\t    state: {\n\t      init: function init() { return null },\n\t      apply: function apply(tr, prev, state) {\n\t        // Firefox on Linux gets really confused an breaks dragging when we\n\t        // mess with the nodes around the target node during a drag. So\n\t        // disable this plugin there. See https://bugzilla.mozilla.org/show_bug.cgi?id=1323170\n\t        if (gecko && linux) { return null }\n\t        var command = tr.getMeta(plugin)\n\t        if (!command) { return prev }\n\t        if (command.type == \"set\") { return pluginStateFor(state, command.pos, options) }\n\t        return null\n\t      }\n\t    },\n\t    props: {\n\t      handleDOMEvents: {\n\t        dragover: function dragover(view, event) {\n\t          var active = plugin.getState(view.state)\n\t          var pos = view.posAtCoords({left: event.clientX, top: event.clientY})\n\t          if (pos && !active || active.pos != pos.pos) { dispatch(view, {type: \"setDropCursor\", pos: pos.pos}) }\n\t          scheduleRemoval(view)\n\t          return false\n\t        },\n\t\n\t        dragend: function dragend(view) {\n\t          if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n\t          return false\n\t        },\n\t\n\t        drop: function drop(view) {\n\t          if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n\t          return false\n\t        },\n\t\n\t        dragleave: function dragleave(view, event) {\n\t          if (event.target == view.content) { dispatch(view, {type: \"remove\"}) }\n\t          return false\n\t        }\n\t      },\n\t      decorations: function decorations(state) {\n\t        var active = plugin.getState(state)\n\t        return active && active.deco\n\t      }\n\t    }\n\t  })\n\t  return plugin\n\t}\n\texports.dropCursor = dropCursor\n\t\n\tfunction style(options, side) {\n\t  var width = (options && options.width) || 1\n\t  var color = (options && options.color) || \"black\"\n\t  return (\"border-\" + side + \": \" + width + \"px solid \" + color + \"; margin-\" + side + \": -\" + width + \"px\")\n\t}\n\t\n\tfunction pluginStateFor(state, pos, options) {\n\t  var $pos = state.doc.resolve(pos), deco\n\t  if (!$pos.parent.isTextblock) {\n\t    var before, after\n\t    if (before = $pos.nodeBefore)\n\t      { deco = Decoration.node(pos - before.nodeSize, pos, {nodeName: \"div\", style: style(options, \"right\")}) }\n\t    else if (after = $pos.nodeAfter)\n\t      { deco = Decoration.node(pos, pos + after.nodeSize, {nodeName: \"div\", style: style(options, \"left\")}) }\n\t  }\n\t  if (!deco) {\n\t    var node = document.createElement(\"span\")\n\t    node.textContent = \"\\u200b\"\n\t    node.style.cssText = style(options, \"left\") + \"; display: inline-block; pointer-events: none\"\n\t    deco = Decoration.widget(pos, node)\n\t  }\n\t  return {pos: pos, deco: DecorationSet.create(state.doc, [deco])}\n\t}\n\n\n/***/ },\n/* 136 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(48);\n\tvar blockQuoteRule = ref.blockQuoteRule;\n\tvar orderedListRule = ref.orderedListRule;\n\tvar bulletListRule = ref.bulletListRule;\n\tvar codeBlockRule = ref.codeBlockRule;\n\tvar headingRule = ref.headingRule;\n\tvar inputRules = ref.inputRules;\n\tvar allInputRules = ref.allInputRules;\n\tvar ref$1 = __webpack_require__(142);\n\tvar keymap = ref$1.keymap;\n\tvar ref$2 = __webpack_require__(29);\n\tvar history = ref$2.history;\n\tvar ref$3 = __webpack_require__(14);\n\tvar baseKeymap = ref$3.baseKeymap;\n\tvar ref$4 = __webpack_require__(2);\n\tvar Plugin = ref$4.Plugin;\n\tvar ref$5 = __webpack_require__(135);\n\tvar dropCursor = ref$5.dropCursor;\n\t\n\tvar ref$6 = __webpack_require__(138);\n\tvar buildMenuItems = ref$6.buildMenuItems;\n\texports.buildMenuItems = buildMenuItems\n\tvar ref$7 = __webpack_require__(137);\n\tvar buildKeymap = ref$7.buildKeymap;\n\texports.buildKeymap = buildKeymap\n\t\n\t// !! This module exports helper functions for deriving a set of basic\n\t// menu items, input rules, or key bindings from a schema. These\n\t// values need to know about the schema for two reasons—they need\n\t// access to specific instances of node and mark types, and they need\n\t// to know which of the node and mark types that they know about are\n\t// actually present in the schema.\n\t//\n\t// The `exampleSetup` plugin ties these together into a plugin that\n\t// will automatically enable this basic functionality in an editor.\n\t\n\t// :: (Object) → [Plugin]\n\t// A convenience plugin that bundles together a simple menu with basic\n\t// key bindings, input rules, and styling for the example schema.\n\t// Probably only useful for quickly setting up a passable\n\t// editor—you'll need more control over your settings in most\n\t// real-world situations.\n\t//\n\t//   options::- The following options are recognized:\n\t//\n\t//     schema:: Schema\n\t//     The schema to generate key bindings and menu items for.\n\t//\n\t//     mapKeys:: ?Object\n\t//     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.\n\tfunction exampleSetup(options) {\n\t  var plugins = [\n\t    inputRules({rules: allInputRules.concat(buildInputRules(options.schema))}),\n\t    keymap(buildKeymap(options.schema, options.mapKeys)),\n\t    keymap(baseKeymap),\n\t    dropCursor()\n\t  ]\n\t  if (options.history !== false) { plugins.push(history()) }\n\t\n\t  return plugins.concat(new Plugin({\n\t    props: {\n\t      attributes: {class: \"ProseMirror-example-setup-style\"},\n\t      menuContent: buildMenuItems(options.schema).fullMenu,\n\t      floatingMenu: true\n\t    }\n\t  }))\n\t}\n\texports.exampleSetup = exampleSetup\n\t\n\t// :: (Schema) → [InputRule]\n\t// A set of input rules for creating the basic block quotes, lists,\n\t// code blocks, and heading.\n\tfunction buildInputRules(schema) {\n\t  var result = [], type\n\t  if (type = schema.nodes.blockquote) { result.push(blockQuoteRule(type)) }\n\t  if (type = schema.nodes.ordered_list) { result.push(orderedListRule(type)) }\n\t  if (type = schema.nodes.bullet_list) { result.push(bulletListRule(type)) }\n\t  if (type = schema.nodes.code_block) { result.push(codeBlockRule(type)) }\n\t  if (type = schema.nodes.heading) { result.push(headingRule(type, 6)) }\n\t  return result\n\t}\n\texports.buildInputRules = buildInputRules\n\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(14);\n\tvar wrapIn = ref.wrapIn;\n\tvar setBlockType = ref.setBlockType;\n\tvar chainCommands = ref.chainCommands;\n\tvar toggleMark = ref.toggleMark;\n\tvar exitCode = ref.exitCode;\n\tvar ref$1 = __webpack_require__(55);\n\tvar selectNextCell = ref$1.selectNextCell;\n\tvar selectPreviousCell = ref$1.selectPreviousCell;\n\tvar ref$2 = __webpack_require__(54);\n\tvar wrapInList = ref$2.wrapInList;\n\tvar splitListItem = ref$2.splitListItem;\n\tvar liftListItem = ref$2.liftListItem;\n\tvar sinkListItem = ref$2.sinkListItem;\n\tvar ref$3 = __webpack_require__(29);\n\tvar undo = ref$3.undo;\n\tvar redo = ref$3.redo;\n\t\n\tvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\t\n\t// :: (Schema, ?Object) → Object\n\t// Inspect the given schema looking for marks and nodes from the\n\t// basic schema, and if found, add key bindings related to them.\n\t// This will add:\n\t//\n\t// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)\n\t// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)\n\t// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)\n\t// * **Ctrl-Shift-0** for making the current textblock a paragraph\n\t// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current\n\t//   textblock a heading of the corresponding level\n\t// * **Ctrl-Shift-Backslash** to make the current textblock a code block\n\t// * **Ctrl-Shift-8** to wrap the selection in an ordered list\n\t// * **Ctrl-Shift-9** to wrap the selection in a bullet list\n\t// * **Ctrl->** to wrap the selection in a block quote\n\t// * **Enter** to split a non-empty textblock in a list item while at\n\t//   the same time splitting the list item\n\t// * **Mod-Enter** to insert a hard break\n\t// * **Mod-_** to insert a horizontal rule\n\t//\n\t// You can suppress or map these bindings by passing a `mapKeys`\n\t// argument, which maps key names (say `\"Mod-B\"` to either `false`, to\n\t// remove the binding, or a new key name string.\n\tfunction buildKeymap(schema, mapKeys) {\n\t  var keys = {}, type\n\t  function bind(key, cmd) {\n\t    if (mapKeys) {\n\t      var mapped = mapKeys[key]\n\t      if (mapped === false) { return }\n\t      if (mapped) { key = mapped }\n\t    }\n\t    keys[key] = cmd\n\t  }\n\t\n\t  bind(\"Mod-z\", undo)\n\t  bind(\"Shift-Mod-z\", redo)\n\t  if (!mac) { bind(\"Mod-y\", redo) }\n\t\n\t  if (type = schema.marks.strong)\n\t    { bind(\"Mod-b\", toggleMark(type)) }\n\t  if (type = schema.marks.em)\n\t    { bind(\"Mod-i\", toggleMark(type)) }\n\t  if (type = schema.marks.code)\n\t    { bind(\"Mod-`\", toggleMark(type)) }\n\t\n\t  if (type = schema.nodes.bullet_list)\n\t    { bind(\"Shift-Ctrl-8\", wrapInList(type)) }\n\t  if (type = schema.nodes.ordered_list)\n\t    { bind(\"Shift-Ctrl-9\", wrapInList(type)) }\n\t  if (type = schema.nodes.blockquote)\n\t    { bind(\"Ctrl->\", wrapIn(type)) }\n\t  if (type = schema.nodes.hard_break) {\n\t    var br = type, cmd = chainCommands(exitCode, function (state, dispatch) {\n\t      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView())\n\t      return true\n\t    })\n\t    bind(\"Mod-Enter\", cmd)\n\t    bind(\"Shift-Enter\", cmd)\n\t    if (mac) { bind(\"Ctrl-Enter\", cmd) }\n\t  }\n\t  if (type = schema.nodes.list_item) {\n\t    bind(\"Enter\", splitListItem(type))\n\t    bind(\"Mod-[\", liftListItem(type))\n\t    bind(\"Mod-]\", sinkListItem(type))\n\t  }\n\t  if (type = schema.nodes.paragraph)\n\t    { bind(\"Shift-Ctrl-0\", setBlockType(type)) }\n\t  if (type = schema.nodes.code_block)\n\t    { bind(\"Shift-Ctrl-\\\\\", setBlockType(type)) }\n\t  if (type = schema.nodes.heading)\n\t    { for (var i = 1; i <= 6; i++) { bind(\"Shift-Ctrl-\" + i, setBlockType(type, {level: i})) } }\n\t  if (type = schema.nodes.horizontal_rule) {\n\t    var hr = type\n\t    bind(\"Mod-_\", function (state, dispatch) {\n\t      dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView())\n\t      return true\n\t    })\n\t  }\n\t\n\t  if (schema.nodes.table_row) {\n\t    bind(\"Tab\", selectNextCell)\n\t    bind(\"Shift-Tab\", selectPreviousCell)\n\t  }\n\t  return keys\n\t}\n\texports.buildKeymap = buildKeymap\n\n\n/***/ },\n/* 138 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(144);\n\tvar wrapItem = ref.wrapItem;\n\tvar blockTypeItem = ref.blockTypeItem;\n\tvar Dropdown = ref.Dropdown;\n\tvar DropdownSubmenu = ref.DropdownSubmenu;\n\tvar joinUpItem = ref.joinUpItem;\n\tvar liftItem = ref.liftItem;\n\tvar selectParentNodeItem = ref.selectParentNodeItem;\n\tvar undoItem = ref.undoItem;\n\tvar redoItem = ref.redoItem;\n\tvar icons = ref.icons;\n\tvar MenuItem = ref.MenuItem;\n\tvar ref$1 = __webpack_require__(55);\n\tvar createTable = ref$1.createTable;\n\tvar addColumnBefore = ref$1.addColumnBefore;\n\tvar addColumnAfter = ref$1.addColumnAfter;\n\tvar removeColumn = ref$1.removeColumn;\n\tvar addRowBefore = ref$1.addRowBefore;\n\tvar addRowAfter = ref$1.addRowAfter;\n\tvar removeRow = ref$1.removeRow;\n\tvar ref$2 = __webpack_require__(2);\n\tvar Selection = ref$2.Selection;\n\tvar ref$3 = __webpack_require__(14);\n\tvar toggleMark = ref$3.toggleMark;\n\tvar ref$4 = __webpack_require__(54);\n\tvar wrapInList = ref$4.wrapInList;\n\tvar ref$5 = __webpack_require__(139);\n\tvar TextField = ref$5.TextField;\n\tvar openPrompt = ref$5.openPrompt;\n\t\n\t// Helpers to create specific types of items\n\t\n\tfunction canInsert(state, nodeType, attrs) {\n\t  var $from = state.selection.$from\n\t  for (var d = $from.depth; d >= 0; d--) {\n\t    var index = $from.index(d)\n\t    if ($from.node(d).canReplaceWith(index, index, nodeType, attrs)) { return true }\n\t  }\n\t  return false\n\t}\n\t\n\tfunction insertImageItem(nodeType) {\n\t  return new MenuItem({\n\t    title: \"Insert image\",\n\t    label: \"Image\",\n\t    select: function select(state) { return canInsert(state, nodeType) },\n\t    run: function run(state, _, view) {\n\t      var ref = state.selection;\n\t      var node = ref.node;\n\t      var from = ref.from;\n\t      var to = ref.to;\n\t      var attrs = nodeType && node && node.type == nodeType && node.attrs\n\t      openPrompt({\n\t        title: \"Insert image\",\n\t        fields: {\n\t          src: new TextField({label: \"Location\", required: true, value: attrs && attrs.src}),\n\t          title: new TextField({label: \"Title\", value: attrs && attrs.title}),\n\t          alt: new TextField({label: \"Description\",\n\t                              value: attrs ? attrs.title : state.doc.textBetween(from, to, \" \")})\n\t        },\n\t        // FIXME this (and similar uses) won't have the current state\n\t        // when it runs, leading to problems in, for example, a\n\t        // collaborative setup\n\t        callback: function callback(attrs) {\n\t          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)))\n\t          view.focus()\n\t        }\n\t      })\n\t    }\n\t  })\n\t}\n\t\n\tfunction positiveInteger(value) {\n\t  if (!/^[1-9]\\d*$/.test(value)) { return \"Should be a positive integer\" }\n\t}\n\t\n\tfunction insertTableItem(tableType) {\n\t  return new MenuItem({\n\t    title: \"Insert a table\",\n\t    run: function run(_, _a, view) {\n\t      openPrompt({\n\t        title: \"Insert table\",\n\t        fields: {\n\t          rows: new TextField({label: \"Rows\", validate: positiveInteger}),\n\t          cols: new TextField({label: \"Columns\", validate: positiveInteger})\n\t        },\n\t        callback: function callback(ref) {\n\t          var rows = ref.rows;\n\t          var cols = ref.cols;\n\t\n\t          var tr = view.state.tr.replaceSelectionWith(createTable(tableType, +rows, +cols))\n\t          tr.setSelection(Selection.near(tr.doc.resolve(view.state.selection.from)))\n\t          view.dispatch(tr.scrollIntoView())\n\t          view.focus()\n\t        }\n\t      })\n\t    },\n\t    select: function select(state) {\n\t      var $from = state.selection.$from\n\t      for (var d = $from.depth; d >= 0; d--) {\n\t        var index = $from.index(d)\n\t        if ($from.node(d).canReplaceWith(index, index, tableType)) { return true }\n\t      }\n\t      return false\n\t    },\n\t    label: \"Table\"\n\t  })\n\t}\n\t\n\tfunction cmdItem(cmd, options) {\n\t  var passedOptions = {\n\t    label: options.title,\n\t    run: cmd,\n\t    select: function select(state) { return cmd(state) }\n\t  }\n\t  for (var prop in options) { passedOptions[prop] = options[prop] }\n\t  return new MenuItem(passedOptions)\n\t}\n\t\n\tfunction markActive(state, type) {\n\t  var ref = state.selection;\n\t  var from = ref.from;\n\t  var $from = ref.$from;\n\t  var to = ref.to;\n\t  var empty = ref.empty;\n\t  if (empty) { return type.isInSet(state.storedMarks || $from.marks()) }\n\t  else { return state.doc.rangeHasMark(from, to, type) }\n\t}\n\t\n\tfunction markItem(markType, options) {\n\t  var passedOptions = {\n\t    active: function active(state) { return markActive(state, markType) }\n\t  }\n\t  for (var prop in options) { passedOptions[prop] = options[prop] }\n\t  return cmdItem(toggleMark(markType), passedOptions)\n\t}\n\t\n\tfunction linkItem(markType) {\n\t  return markItem(markType, {\n\t    title: \"Add or remove link\",\n\t    icon: icons.link,\n\t    run: function run(state, dispatch, view) {\n\t      if (markActive(state, markType)) {\n\t        toggleMark(markType)(state, dispatch)\n\t        return true\n\t      }\n\t      openPrompt({\n\t        title: \"Create a link\",\n\t        fields: {\n\t          href: new TextField({\n\t            label: \"Link target\",\n\t            required: true,\n\t            clean: function (val) {\n\t              if (!/^https?:\\/\\//i.test(val))\n\t                { val = 'http://' + val }\n\t              return val\n\t            }\n\t          }),\n\t          title: new TextField({label: \"Title\"})\n\t        },\n\t        callback: function callback(attrs) {\n\t          toggleMark(markType, attrs)(view.state, view.dispatch)\n\t          view.focus()\n\t        }\n\t      })\n\t    }\n\t  })\n\t}\n\t\n\tfunction wrapListItem(nodeType, options) {\n\t  return cmdItem(wrapInList(nodeType, options.attrs), options)\n\t}\n\t\n\t// :: (Schema) → Object\n\t// Given a schema, look for default mark and node types in it and\n\t// return an object with relevant menu items relating to those marks:\n\t//\n\t// **`toggleStrong`**`: MenuItem`\n\t//   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).\n\t//\n\t// **`toggleEm`**`: MenuItem`\n\t//   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).\n\t//\n\t// **`toggleCode`**`: MenuItem`\n\t//   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).\n\t//\n\t// **`toggleLink`**`: MenuItem`\n\t//   : A menu item to toggle the [link mark](#schema-basic.LinkMark).\n\t//\n\t// **`insertImage`**`: MenuItem`\n\t//   : A menu item to insert an [image](#schema-basic.Image).\n\t//\n\t// **`wrapBulletList`**`: MenuItem`\n\t//   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).\n\t//\n\t// **`wrapOrderedList`**`: MenuItem`\n\t//   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).\n\t//\n\t// **`wrapBlockQuote`**`: MenuItem`\n\t//   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).\n\t//\n\t// **`makeParagraph`**`: MenuItem`\n\t//   : A menu item to set the current textblock to be a normal\n\t//     [paragraph](#schema-basic.Paragraph).\n\t//\n\t// **`makeCodeBlock`**`: MenuItem`\n\t//   : A menu item to set the current textblock to be a\n\t//     [code block](#schema-basic.CodeBlock).\n\t//\n\t// **`insertTable`**`: MenuItem`\n\t//   : An item to insert a [table](#schema-table).\n\t//\n\t// **`addRowBefore`**, **`addRowAfter`**, **`removeRow`**, **`addColumnBefore`**, **`addColumnAfter`**, **`removeColumn`**`: MenuItem`\n\t//   : Table-manipulation items.\n\t//\n\t// **`makeHead[N]`**`: MenuItem`\n\t//   : Where _N_ is 1 to 6. Menu items to set the current textblock to\n\t//     be a [heading](#schema-basic.Heading) of level _N_.\n\t//\n\t// **`insertHorizontalRule`**`: MenuItem`\n\t//   : A menu item to insert a horizontal rule.\n\t//\n\t// The return value also contains some prefabricated menu elements and\n\t// menus, that you can use instead of composing your own menu from\n\t// scratch:\n\t//\n\t// **`insertMenu`**`: Dropdown`\n\t//   : A dropdown containing the `insertImage` and\n\t//     `insertHorizontalRule` items.\n\t//\n\t// **`typeMenu`**`: Dropdown`\n\t//   : A dropdown containing the items for making the current\n\t//     textblock a paragraph, code block, or heading.\n\t//\n\t// **`fullMenu`**`: [[MenuElement]]`\n\t//   : An array of arrays of menu elements for use as the full menu\n\t//     for, for example the [menu bar](#menu.MenuBarEditorView).\n\tfunction buildMenuItems(schema) {\n\t  var r = {}, type\n\t  if (type = schema.marks.strong)\n\t    { r.toggleStrong = markItem(type, {title: \"Toggle strong style\", icon: icons.strong}) }\n\t  if (type = schema.marks.em)\n\t    { r.toggleEm = markItem(type, {title: \"Toggle emphasis\", icon: icons.em}) }\n\t  if (type = schema.marks.code)\n\t    { r.toggleCode = markItem(type, {title: \"Toggle code font\", icon: icons.code}) }\n\t  if (type = schema.marks.link)\n\t    { r.toggleLink = linkItem(type) }\n\t\n\t  if (type = schema.nodes.image)\n\t    { r.insertImage = insertImageItem(type) }\n\t  if (type = schema.nodes.bullet_list)\n\t    { r.wrapBulletList = wrapListItem(type, {\n\t      title: \"Wrap in bullet list\",\n\t      icon: icons.bulletList\n\t    }) }\n\t  if (type = schema.nodes.ordered_list)\n\t    { r.wrapOrderedList = wrapListItem(type, {\n\t      title: \"Wrap in ordered list\",\n\t      icon: icons.orderedList\n\t    }) }\n\t  if (type = schema.nodes.blockquote)\n\t    { r.wrapBlockQuote = wrapItem(type, {\n\t      title: \"Wrap in block quote\",\n\t      icon: icons.blockquote\n\t    }) }\n\t  if (type = schema.nodes.paragraph)\n\t    { r.makeParagraph = blockTypeItem(type, {\n\t      title: \"Change to paragraph\",\n\t      label: \"Plain\"\n\t    }) }\n\t  if (type = schema.nodes.code_block)\n\t    { r.makeCodeBlock = blockTypeItem(type, {\n\t      title: \"Change to code block\",\n\t      label: \"Code\"\n\t    }) }\n\t  if (type = schema.nodes.heading)\n\t    { for (var i = 1; i <= 10; i++)\n\t      { r[\"makeHead\" + i] = blockTypeItem(type, {\n\t        title: \"Change to heading \" + i,\n\t        label: \"Level \" + i,\n\t        attrs: {level: i}\n\t      }) } }\n\t  if (type = schema.nodes.horizontal_rule) {\n\t    var hr = type\n\t    r.insertHorizontalRule = new MenuItem({\n\t      title: \"Insert horizontal rule\",\n\t      label: \"Horizontal rule\",\n\t      select: function select(state) { return canInsert(state, hr) },\n\t      run: function run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())) }\n\t    })\n\t  }\n\t  if (type = schema.nodes.table)\n\t    { r.insertTable = insertTableItem(type) }\n\t  if (type = schema.nodes.table_row) {\n\t    r.addRowBefore = cmdItem(addRowBefore, {title: \"Add row before\"})\n\t    r.addRowAfter = cmdItem(addRowAfter, {title: \"Add row after\"})\n\t    r.removeRow = cmdItem(removeRow, {title: \"Remove row\"})\n\t    r.addColumnBefore = cmdItem(addColumnBefore, {title: \"Add column before\"})\n\t    r.addColumnAfter = cmdItem(addColumnAfter, {title: \"Add column after\"})\n\t    r.removeColumn = cmdItem(removeColumn, {title: \"Remove column\"})\n\t  }\n\t\n\t  var cut = function (arr) { return arr.filter(function (x) { return x; }); }\n\t  r.insertMenu = new Dropdown(cut([r.insertImage, r.insertHorizontalRule, r.insertTable]), {label: \"Insert\"})\n\t  r.typeMenu = new Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new DropdownSubmenu(cut([\n\t    r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6\n\t  ]), {label: \"Heading\"})]), {label: \"Type...\"})\n\t  var tableItems = cut([r.addRowBefore, r.addRowAfter, r.removeRow, r.addColumnBefore, r.addColumnAfter, r.removeColumn])\n\t  if (tableItems.length)\n\t    { r.tableMenu = new Dropdown(tableItems, {label: \"Table\"}) }\n\t\n\t  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink]), [r.insertMenu]]\n\t  r.blockMenu = [cut([r.typeMenu, r.tableMenu, r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, joinUpItem,\n\t                      liftItem, selectParentNodeItem])]\n\t  r.fullMenu = r.inlineMenu.concat(r.blockMenu).concat([[undoItem, redoItem]])\n\t\n\t  return r\n\t}\n\texports.buildMenuItems = buildMenuItems\n\n\n/***/ },\n/* 139 */\n/***/ function(module, exports) {\n\n\tvar prefix = \"ProseMirror-prompt\"\n\t\n\tfunction openPrompt(options) {\n\t  var wrapper = document.body.appendChild(document.createElement(\"div\"))\n\t  wrapper.className = prefix\n\t\n\t  var mouseOutside = function (e) { if (!wrapper.contains(e.target)) { close() } }\n\t  setTimeout(function () { return window.addEventListener(\"mousedown\", mouseOutside); }, 50)\n\t  var close = function () {\n\t    window.removeEventListener(\"mousedown\", mouseOutside)\n\t    if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper) }\n\t  }\n\t\n\t  var domFields = []\n\t  for (var name in options.fields) { domFields.push(options.fields[name].render()) }\n\t\n\t  var submitButton = document.createElement(\"button\")\n\t  submitButton.type = \"submit\"\n\t  submitButton.className = prefix + \"-submit\"\n\t  submitButton.textContent = \"OK\"\n\t  var cancelButton = document.createElement(\"button\")\n\t  cancelButton.type = \"button\"\n\t  cancelButton.className = prefix + \"-cancel\"\n\t  cancelButton.textContent = \"Cancel\"\n\t  cancelButton.addEventListener(\"click\", close)\n\t\n\t  var form = wrapper.appendChild(document.createElement(\"form\"))\n\t  if (options.title) { form.appendChild(document.createElement(\"h5\")).textContent = options.title }\n\t  domFields.forEach(function (field) {\n\t    form.appendChild(document.createElement(\"div\")).appendChild(field)\n\t  })\n\t  var buttons = form.appendChild(document.createElement(\"div\"))\n\t  buttons.className = prefix + \"-buttons\"\n\t  buttons.appendChild(submitButton)\n\t  buttons.appendChild(document.createTextNode(\" \"))\n\t  buttons.appendChild(cancelButton)\n\t\n\t  var box = wrapper.getBoundingClientRect()\n\t  wrapper.style.top = ((window.innerHeight - box.height) / 2) + \"px\"\n\t  wrapper.style.left = ((window.innerWidth - box.width) / 2) + \"px\"\n\t\n\t  var submit = function () {\n\t    var params = getValues(options.fields, domFields)\n\t    if (params) {\n\t      close()\n\t      options.callback(params)\n\t    }\n\t  }\n\t\n\t  form.addEventListener(\"submit\", function (e) {\n\t    e.preventDefault()\n\t    submit()\n\t  })\n\t\n\t  form.addEventListener(\"keydown\", function (e) {\n\t    if (e.keyCode == 27) {\n\t      e.preventDefault()\n\t      close()\n\t    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {\n\t      e.preventDefault()\n\t      submit()\n\t    } else if (e.keyCode == 9) {\n\t      window.setTimeout(function () {\n\t        if (!wrapper.contains(document.activeElement)) { close() }\n\t      }, 500)\n\t    }\n\t  })\n\t\n\t  var input = form.elements[0]\n\t  if (input) { input.focus() }\n\t}\n\texports.openPrompt = openPrompt\n\t\n\tfunction getValues(fields, domFields) {\n\t  var result = Object.create(null), i = 0\n\t  for (var name in fields) {\n\t    var field = fields[name], dom = domFields[i++]\n\t    var value = field.read(dom), bad = field.validate(value)\n\t    if (bad) {\n\t      reportInvalid(dom, bad)\n\t      return null\n\t    }\n\t    result[name] = field.clean(value)\n\t  }\n\t  return result\n\t}\n\t\n\tfunction reportInvalid(dom, message) {\n\t  // FIXME this is awful and needs a lot more work\n\t  var parent = dom.parentNode\n\t  var msg = parent.appendChild(document.createElement(\"div\"))\n\t  msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + \"px\"\n\t  msg.style.top = (dom.offsetTop - 5) + \"px\"\n\t  msg.className = \"ProseMirror-invalid\"\n\t  msg.textContent = message\n\t  setTimeout(function () { return parent.removeChild(msg); }, 1500)\n\t}\n\t\n\t// ::- The type of field that `FieldPrompt` expects to be passed to it.\n\tvar Field = function Field(options) { this.options = options };\n\t\n\t// render:: (state: EditorState, props: Object) → dom.Node\n\t// Render the field to the DOM. Should be implemented by all subclasses.\n\t\n\t// :: (dom.Node) → any\n\t// Read the field's value from its DOM node.\n\tField.prototype.read = function read (dom) { return dom.value };\n\t\n\t// :: (any) → ?string\n\t// A field-type-specific validation function.\n\tField.prototype.validateType = function validateType (_value) {};\n\t\n\tField.prototype.validate = function validate (value) {\n\t  if (!value && this.options.required)\n\t    { return \"Required field\" }\n\t  return this.validateType(value) || (this.options.validate && this.options.validate(value))\n\t};\n\t\n\tField.prototype.clean = function clean (value) {\n\t  return this.options.clean ? this.options.clean(value) : value\n\t};\n\texports.Field = Field\n\t\n\t// ::- A field class for single-line text fields.\n\tvar TextField = (function (Field) {\n\t  function TextField () {\n\t    Field.apply(this, arguments);\n\t  }\n\t\n\t  if ( Field ) TextField.__proto__ = Field;\n\t  TextField.prototype = Object.create( Field && Field.prototype );\n\t  TextField.prototype.constructor = TextField;\n\t\n\t  TextField.prototype.render = function render () {\n\t    var input = document.createElement(\"input\")\n\t    input.type = \"text\"\n\t    input.placeholder = this.options.label\n\t    input.value = this.options.value || \"\"\n\t    input.autocomplete = \"off\"\n\t    return input\n\t  };\n\t\n\t  return TextField;\n\t}(Field));\n\texports.TextField = TextField\n\t\n\t\n\t// ::- A field class for dropdown fields based on a plain `<select>`\n\t// tag. Expects an option `options`, which should be an array of\n\t// `{value: string, label: string}` objects, or a function taking a\n\t// `ProseMirror` instance and returning such an array.\n\tvar SelectField = (function (Field) {\n\t  function SelectField () {\n\t    Field.apply(this, arguments);\n\t  }\n\t\n\t  if ( Field ) SelectField.__proto__ = Field;\n\t  SelectField.prototype = Object.create( Field && Field.prototype );\n\t  SelectField.prototype.constructor = SelectField;\n\t\n\t  SelectField.prototype.render = function render () {\n\t    var this$1 = this;\n\t\n\t    var select = document.createElement(\"select\")\n\t    this.options.options.forEach(function (o) {\n\t      var opt = select.appendChild(document.createElement(\"option\"))\n\t      opt.value = o.value\n\t      opt.selected = o.value == this$1.options.value\n\t      opt.label = o.label\n\t    })\n\t    return select\n\t  };\n\t\n\t  return SelectField;\n\t}(Field));\n\texports.SelectField = SelectField\n\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(30);\n\tvar InputRule = ref.InputRule;\n\t\n\t// :: InputRule Converts double dashes to an emdash.\n\tvar emDash = new InputRule(/--$/, \"—\")\n\texports.emDash = emDash\n\t// :: InputRule Converts three dots to an ellipsis character.\n\tvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n\texports.ellipsis = ellipsis\n\t// :: InputRule “Smart” opening double quotes.\n\tvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n\texports.openDoubleQuote = openDoubleQuote\n\t// :: InputRule “Smart” closing double quotes.\n\tvar closeDoubleQuote = new InputRule(/\"$/, \"”\")\n\texports.closeDoubleQuote = closeDoubleQuote\n\t// :: InputRule “Smart” opening single quotes.\n\tvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n\texports.openSingleQuote = openSingleQuote\n\t// :: InputRule “Smart” closing single quotes.\n\tvar closeSingleQuote = new InputRule(/'$/, \"’\")\n\texports.closeSingleQuote = closeSingleQuote\n\t\n\t// :: [InputRule] Smart-quote related input rules.\n\tvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n\texports.smartQuotes = smartQuotes\n\t\n\t// :: [InputRule] All schema-independent input rules defined in this module.\n\tvar allInputRules = [emDash, ellipsis].concat(smartQuotes)\n\texports.allInputRules = allInputRules\n\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(30);\n\tvar InputRule = ref.InputRule;\n\tvar ref$1 = __webpack_require__(4);\n\tvar findWrapping = ref$1.findWrapping;\n\tvar canJoin = ref$1.canJoin;\n\t\n\t// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n\t// Build an input rule for automatically wrapping a textblock when a\n\t// given string is typed. The `regexp` argument is\n\t// directly passed through to the `InputRule` constructor. You'll\n\t// probably want the regexp to start with `^`, so that the pattern can\n\t// only occur at the start of a textblock.\n\t//\n\t// `nodeType` is the type of node to wrap in. If it needs attributes,\n\t// you can either pass them directly, or pass a function that will\n\t// compute them from the regular expression match.\n\t//\n\t// By default, if there's a node with the same type above the newly\n\t// wrapped node, the rule will try to [join](#transform.Transform.join) those\n\t// two nodes. You can pass a join predicate, which takes a regular\n\t// expression match and the node before the wrapped node, and can\n\t// return a boolean to indicate whether a join should happen.\n\tfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n\t  return new InputRule(regexp, function (state, match, start, end) {\n\t    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n\t    var tr = state.tr.delete(start, end)\n\t    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n\t    if (!wrapping) { return null }\n\t    tr.wrap(range, wrapping)\n\t    var before = tr.doc.resolve(start - 1).nodeBefore\n\t    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n\t        (!joinPredicate || joinPredicate(match, before)))\n\t      { tr.join(start - 1) }\n\t    return tr\n\t  })\n\t}\n\texports.wrappingInputRule = wrappingInputRule\n\t\n\t// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n\t// Build an input rule that changes the type of a textblock when the\n\t// matched text is typed into it. You'll usually want to start your\n\t// regexp with `^` to that it is only matched at the start of a\n\t// textblock. The optional `getAttrs` parameter can be used to compute\n\t// the new node's attributes, and works the same as in the\n\t// `wrappingInputRule` function.\n\tfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n\t  return new InputRule(regexp, function (state, match, start, end) {\n\t    var $start = state.doc.resolve(start)\n\t    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n\t    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType, attrs)) { return null }\n\t    return state.tr\n\t      .delete(start, end)\n\t      .setBlockType(start, start, nodeType, attrs)\n\t  })\n\t}\n\texports.textblockTypeInputRule = textblockTypeInputRule\n\t\n\t\n\t// :: (NodeType) → InputRule\n\t// Given a blockquote node type, returns an input rule that turns `\"> \"`\n\t// at the start of a textblock into a blockquote.\n\tfunction blockQuoteRule(nodeType) {\n\t  return wrappingInputRule(/^\\s*> $/, nodeType)\n\t}\n\texports.blockQuoteRule = blockQuoteRule\n\t\n\t// :: (NodeType) → InputRule\n\t// Given a list node type, returns an input rule that turns a number\n\t// followed by a dot at the start of a textblock into an ordered list.\n\tfunction orderedListRule(nodeType) {\n\t  return wrappingInputRule(/^(\\d+)\\. $/, nodeType, function (match) { return ({order: +match[1]}); },\n\t                           function (match, node) { return node.childCount + node.attrs.order == +match[1]; })\n\t}\n\texports.orderedListRule = orderedListRule\n\t\n\t// :: (NodeType) → InputRule\n\t// Given a list node type, returns an input rule that turns a bullet\n\t// (dash, plush, or asterisk) at the start of a textblock into a\n\t// bullet list.\n\tfunction bulletListRule(nodeType) {\n\t  return wrappingInputRule(/^\\s*([-+*]) $/, nodeType)\n\t}\n\texports.bulletListRule = bulletListRule\n\t\n\t// :: (NodeType) → InputRule\n\t// Given a code block node type, returns an input rule that turns a\n\t// textblock starting with three backticks into a code block.\n\tfunction codeBlockRule(nodeType) {\n\t  return textblockTypeInputRule(/^```$/, nodeType)\n\t}\n\texports.codeBlockRule = codeBlockRule\n\t\n\t// :: (NodeType, number) → InputRule\n\t// Given a node type and a maximum level, creates an input rule that\n\t// turns up to that number of `#` characters followed by a space at\n\t// the start of a textblock into a heading whose level corresponds to\n\t// the number of `#` signs.\n\tfunction headingRule(nodeType, maxLevel) {\n\t  return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"}) $\"),\n\t                                nodeType, function (match) { return ({level: match[1].length}); })\n\t}\n\texports.headingRule = headingRule\n\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar keyName = __webpack_require__(200)\n\tvar ref = __webpack_require__(2);\n\tvar Plugin = ref.Plugin;\n\t\n\t// declare global: navigator\n\t\n\tvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\t\n\tfunction normalizeKeyName(name) {\n\t  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n\t  if (result == \"Space\") { result = \" \" }\n\t  var alt, ctrl, shift, meta\n\t  for (var i = 0; i < parts.length - 1; i++) {\n\t    var mod = parts[i]\n\t    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true }\n\t    else if (/^a(lt)?$/i.test(mod)) { alt = true }\n\t    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }\n\t    else if (/^s(hift)?$/i.test(mod)) { shift = true }\n\t    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true } }\n\t    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n\t  }\n\t  if (alt) { result = \"Alt-\" + result }\n\t  if (ctrl) { result = \"Ctrl-\" + result }\n\t  if (meta) { result = \"Meta-\" + result }\n\t  if (shift) { result = \"Shift-\" + result }\n\t  return result\n\t}\n\t\n\tfunction normalize(map) {\n\t  var copy = Object.create(null)\n\t  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop] }\n\t  return copy\n\t}\n\t\n\tfunction modifiers(name, event, shift) {\n\t  if (event.altKey) { name = \"Alt-\" + name }\n\t  if (event.ctrlKey) { name = \"Ctrl-\" + name }\n\t  if (event.metaKey) { name = \"Meta-\" + name }\n\t  if (shift !== false && event.shiftKey) { name = \"Shift-\" + name }\n\t  return name\n\t}\n\t\n\t// :: (Object) → Plugin\n\t// Create a keymap plugin for the given set of bindings.\n\t//\n\t// Bindings should map key names to [command](#commands)-style\n\t// functions, which will be called with `(EditorState, dispatch,\n\t// EditorView)` arguments, and should return true when they've handled\n\t// the key. Note that the view argument isn't part of the command\n\t// protocol, but can be used as an escape hatch if a binding needs to\n\t// directly interact with the UI.\n\t//\n\t// Key names may be strings like `\"Shift-Ctrl-Enter\"`, a key\n\t// identifier prefixed with zero or more modifiers. Key identifiers\n\t// are based on the strings that can appear in\n\t// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n\t// Use lowercase letters to refer to letter keys (or uppercase letters\n\t// if you want shift to be held). You may use `\"Space\"` as an alias\n\t// for the `\" \"` name.\n\t//\n\t// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n\t// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n\t// `Meta-`) are recognized. For characters that are created by holding\n\t// shift, the `Shift-` prefix is implied, and should not be added\n\t// explicitly.\n\t//\n\t// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n\t// other platforms.\n\t//\n\t// You can add multiple keymap plugins to an editor. The order in\n\t// which they appear determines their precedence (the ones early in\n\t// the array get to dispatch first).\n\tfunction keymap(bindings) {\n\t  var map = normalize(bindings)\n\t\n\t  return new Plugin({\n\t    props: {\n\t      handleKeyDown: function handleKeyDown(view, event) {\n\t        var name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n\t        var direct = map[modifiers(name, event, !isChar)]\n\t        if (direct && direct(view.state, view.dispatch, view)) { return true }\n\t        if (event.shiftKey && isChar && (baseName = keyName.base[event.keyCode])) {\n\t          var withShift = map[modifiers(baseName, event, true)]\n\t          if (withShift && withShift(view.state, view.dispatch, view)) { return true }\n\t        }\n\t        return false\n\t      }\n\t    }\n\t  })\n\t}\n\texports.keymap = keymap\n\n\n/***/ },\n/* 143 */\n/***/ function(module, exports) {\n\n\tvar SVG = \"http://www.w3.org/2000/svg\"\n\tvar XLINK = \"http://www.w3.org/1999/xlink\"\n\t\n\tvar prefix = \"ProseMirror-icon\"\n\t\n\tfunction hashPath(path) {\n\t  var hash = 0\n\t  for (var i = 0; i < path.length; i++)\n\t    { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0 }\n\t  return hash\n\t}\n\t\n\tfunction getIcon(icon) {\n\t  var node = document.createElement(\"div\")\n\t  node.className = prefix\n\t  if (icon.path) {\n\t    var name = \"pm-icon-\" + hashPath(icon.path).toString(16)\n\t    if (!document.getElementById(name)) { buildSVG(name, icon) }\n\t    var svg = node.appendChild(document.createElementNS(SVG, \"svg\"))\n\t    svg.style.width = (icon.width / icon.height) + \"em\"\n\t    var use = svg.appendChild(document.createElementNS(SVG, \"use\"))\n\t    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#\" + name)\n\t  } else if (icon.dom) {\n\t    node.appendChild(icon.dom.cloneNode(true))\n\t  } else {\n\t    node.appendChild(document.createElement(\"span\")).textContent = icon.text || ''\n\t    if (icon.css) { node.firstChild.style.cssText = icon.css }\n\t  }\n\t  return node\n\t}\n\texports.getIcon = getIcon\n\t\n\tfunction buildSVG(name, data) {\n\t  var collection = document.getElementById(prefix + \"-collection\")\n\t  if (!collection) {\n\t    collection = document.createElementNS(SVG, \"svg\")\n\t    collection.id = prefix + \"-collection\"\n\t    collection.style.display = \"none\"\n\t    document.body.insertBefore(collection, document.body.firstChild)\n\t  }\n\t  var sym = document.createElementNS(SVG, \"symbol\")\n\t  sym.id = name\n\t  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height)\n\t  var path = sym.appendChild(document.createElementNS(SVG, \"path\"))\n\t  path.setAttribute(\"d\", data.path)\n\t  collection.appendChild(sym)\n\t}\n\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;var assign;\n\t((assign = __webpack_require__(49), exports.MenuItem = assign.MenuItem, exports.Dropdown = assign.Dropdown, exports.DropdownSubmenu = assign.DropdownSubmenu, exports.renderGrouped = assign.renderGrouped, exports.icons = assign.icons, exports.joinUpItem = assign.joinUpItem, exports.liftItem = assign.liftItem, exports.selectParentNodeItem = assign.selectParentNodeItem, exports.undoItem = assign.undoItem, exports.redoItem = assign.redoItem, exports.wrapItem = assign.wrapItem, exports.blockTypeItem = assign.blockTypeItem))\n\texports.MenuBarEditorView = __webpack_require__(145).MenuBarEditorView\n\t\n\t// !! This module defines a number of building blocks for ProseMirror\n\t// menus, along with a [menu bar](#menu.MenuBarEditorView) implementation.\n\t\n\t// MenuElement:: interface\n\t// The types defined in this module aren't the only thing you can\n\t// display in your menu. Anything that conforms to this interface can\n\t// be put into a menu structure.\n\t//\n\t//   render:: (pm: ProseMirror) → ?dom.Node\n\t//   Render the element for display in the menu. Returning `null` can be\n\t//   used to signal that this element shouldn't be displayed for the\n\t//   given editor state.\n\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar crel = __webpack_require__(47)\n\tvar ref = __webpack_require__(34);\n\tvar EditorView = ref.EditorView;\n\t\n\tvar ref$1 = __webpack_require__(49);\n\tvar renderGrouped = ref$1.renderGrouped;\n\t\n\tvar prefix = \"ProseMirror-menubar\"\n\t\n\t// ::- A wrapper around\n\t// [`EditorView`](http://prosemirror.net/ref.html#view.EditorView)\n\t// that adds a menubar above the editor.\n\t//\n\t// Supports the following additional props:\n\t//\n\t// - **`floatingMenu`**`: ?bool` determines whether the menu floats,\n\t//   i.e. whether it sticks to the top of the viewport when the editor\n\t//   is partially scrolled out of view.\n\t//\n\t// - **`menuContent`**`: [[MenuElement]]` provides the content of the\n\t//   menu, as a nested array to be passed to `renderGrouped`.\n\tvar MenuBarEditorView = function MenuBarEditorView(place, props) {\n\t  var this$1 = this;\n\t\n\t  // :: dom.Node The wrapping DOM element around the editor and the\n\t  // menu. Will get the CSS class `ProseMirror-menubar-wrapper`.\n\t  this.wrapper = crel(\"div\", {class: prefix + \"-wrapper\"})\n\t  if (place && place.appendChild) { place.appendChild(this.wrapper) }\n\t  else if (place) { place(this.wrapper) }\n\t  if (!props.dispatchTransaction)\n\t    { props.dispatchTransaction = function (tr) { return this$1.updateState(this$1.editor.state.apply(tr)); } }\n\t  // :: EditorView The wrapped editor view. _Don't_ directly call\n\t  // `update` or `updateState` on this, always go through the\n\t  // wrapping view.\n\t  this.editor = new EditorView(this.wrapper, props)\n\t\n\t  this.menu = crel(\"div\", {class: prefix})\n\t  this.menu.className = prefix\n\t  this.spacer = null\n\t\n\t  this.wrapper.insertBefore(this.menu, this.wrapper.firstChild)\n\t\n\t  this.maxHeight = 0\n\t  this.widthForMaxHeight = 0\n\t  this.floating = false\n\t\n\t  // :: EditorProps The current props of this view.\n\t  this.props = props\n\t  this.updateMenu()\n\t\n\t  if (this.editor.someProp(\"floatingMenu\")) {\n\t    this.updateFloat()\n\t    this.scrollFunc = function () {\n\t      if (!this$1.editor.root.contains(this$1.wrapper))\n\t        { window.removeEventListener(\"scroll\", this$1.scrollFunc) }\n\t      else\n\t        { this$1.updateFloat() }\n\t    }\n\t    window.addEventListener(\"scroll\", this.scrollFunc)\n\t  }\n\t};\n\t\n\t// :: (EditorProps) Update the view's props.\n\tMenuBarEditorView.prototype.update = function update (props) {\n\t  this.props = props\n\t  this.editor.update(props)\n\t  this.updateMenu()\n\t};\n\t\n\t// :: (EditorState) Update only the state of the editor.\n\tMenuBarEditorView.prototype.updateState = function updateState (state) {\n\t  this.editor.updateState(state)\n\t  this.updateMenu()\n\t};\n\t\n\tMenuBarEditorView.prototype.updateMenu = function updateMenu () {\n\t  this.menu.textContent = \"\"\n\t  this.menu.appendChild(renderGrouped(this.editor, this.editor.someProp(\"menuContent\")))\n\t\n\t  if (this.floating) {\n\t    this.updateScrollCursor()\n\t  } else {\n\t    if (this.menu.offsetWidth != this.widthForMaxHeight) {\n\t      this.widthForMaxHeight = this.menu.offsetWidth\n\t      this.maxHeight = 0\n\t    }\n\t    if (this.menu.offsetHeight > this.maxHeight) {\n\t      this.maxHeight = this.menu.offsetHeight\n\t      this.menu.style.minHeight = this.maxHeight + \"px\"\n\t    }\n\t  }\n\t};\n\t\n\t\n\tMenuBarEditorView.prototype.updateScrollCursor = function updateScrollCursor () {\n\t  var selection = this.editor.root.getSelection()\n\t  if (!selection.focusNode) { return }\n\t  var rects = selection.getRangeAt(0).getClientRects()\n\t  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1]\n\t  if (!selRect) { return }\n\t  var menuRect = this.menu.getBoundingClientRect()\n\t  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {\n\t    var scrollable = findWrappingScrollable(this.wrapper)\n\t    if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top) }\n\t  }\n\t};\n\t\n\tMenuBarEditorView.prototype.updateFloat = function updateFloat () {\n\t  var parent = this.wrapper, editorRect = parent.getBoundingClientRect()\n\t  if (this.floating) {\n\t    if (editorRect.top >= 0 || editorRect.bottom < this.menu.offsetHeight + 10) {\n\t      this.floating = false\n\t      this.menu.style.position = this.menu.style.left = this.menu.style.width = \"\"\n\t      this.menu.style.display = \"\"\n\t      this.spacer.parentNode.removeChild(this.spacer)\n\t      this.spacer = null\n\t    } else {\n\t      var border = (parent.offsetWidth - parent.clientWidth) / 2\n\t      this.menu.style.left = (editorRect.left + border) + \"px\"\n\t      this.menu.style.display = (editorRect.top > window.innerHeight ? \"none\" : \"\")\n\t    }\n\t  } else {\n\t    if (editorRect.top < 0 && editorRect.bottom >= this.menu.offsetHeight + 10) {\n\t      this.floating = true\n\t      var menuRect = this.menu.getBoundingClientRect()\n\t      this.menu.style.left = menuRect.left + \"px\"\n\t      this.menu.style.width = menuRect.width + \"px\"\n\t      this.menu.style.position = \"fixed\"\n\t      this.spacer = crel(\"div\", {class: prefix + \"-spacer\", style: (\"height: \" + (menuRect.height) + \"px\")})\n\t      parent.insertBefore(this.spacer, this.menu)\n\t    }\n\t  }\n\t};\n\t\n\t// :: ()\n\t// Destroy the editor instance.\n\tMenuBarEditorView.prototype.destroy = function destroy () {\n\t  this.editor.destroy()\n\t};\n\texports.MenuBarEditorView = MenuBarEditorView\n\t\n\t// Not precise, but close enough\n\tfunction selectionIsInverted(selection) {\n\t  if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }\n\t  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING\n\t}\n\t\n\tfunction findWrappingScrollable(node) {\n\t  for (var cur = node.parentNode; cur; cur = cur.parentNode)\n\t    { if (cur.scrollHeight > cur.clientHeight) { return cur } }\n\t}\n\n\n/***/ },\n/* 146 */\n/***/ function(module, exports) {\n\n\tfunction findDiffStart(a, b, pos) {\n\t  for (var i = 0;; i++) {\n\t    if (i == a.childCount || i == b.childCount)\n\t      { return a.childCount == b.childCount ? null : pos }\n\t\n\t    var childA = a.child(i), childB = b.child(i)\n\t    if (childA == childB) { pos += childA.nodeSize; continue }\n\t\n\t    if (!childA.sameMarkup(childB)) { return pos }\n\t\n\t    if (childA.isText && childA.text != childB.text) {\n\t      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n\t        { pos++ }\n\t      return pos\n\t    }\n\t    if (childA.content.size || childB.content.size) {\n\t      var inner = findDiffStart(childA.content, childB.content, pos + 1)\n\t      if (inner != null) { return inner }\n\t    }\n\t    pos += childA.nodeSize\n\t  }\n\t}\n\texports.findDiffStart = findDiffStart\n\t\n\tfunction findDiffEnd(a, b, posA, posB) {\n\t  for (var iA = a.childCount, iB = b.childCount;;) {\n\t    if (iA == 0 || iB == 0)\n\t      { return iA == iB ? null : {a: posA, b: posB} }\n\t\n\t    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n\t    if (childA == childB) {\n\t      posA -= size; posB -= size\n\t      continue\n\t    }\n\t\n\t    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\t\n\t    if (childA.isText && childA.text != childB.text) {\n\t      var same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n\t      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n\t        same++; posA--; posB--\n\t      }\n\t      return {a: posA, b: posB}\n\t    }\n\t    if (childA.content.size || childB.content.size) {\n\t      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n\t      if (inner) { return inner }\n\t    }\n\t    posA -= size; posB -= size\n\t  }\n\t}\n\texports.findDiffEnd = findDiffEnd\n\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(5);\n\tvar Fragment = ref.Fragment;\n\tvar ref$1 = __webpack_require__(31);\n\tvar Slice = ref$1.Slice;\n\tvar ref$2 = __webpack_require__(6);\n\tvar Mark = ref$2.Mark;\n\t\n\t// ParseRule:: interface\n\t// A value that describes how to parse a given DOM node or inline\n\t// style as a ProseMirror node or mark.\n\t//\n\t//   tag:: ?string\n\t//   A CSS selector describing the kind of DOM elements to match. A\n\t//   single rule should have _either_ a `tag` or a `style` property.\n\t//\n\t//   style:: ?string\n\t//   A CSS property name to match. When given, this rule matches\n\t//   inline styles that list that property.\n\t//\n\t//   node:: ?string\n\t//   The name of the node type to create when this rule matches. Only\n\t//   valid for rules with a `tag` property, not for style rules. Each\n\t//   rule should have one of a `node`, `mark`, or `ignore` property\n\t//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n\t//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n\t//   or `mark` property will be derived from its position).\n\t//\n\t//   mark:: ?string\n\t//   The name of the mark type to wrap the matched content in.\n\t//\n\t//   priority:: ?number\n\t//   Can be used to change the order in which the parse rules in a\n\t//   schema are tried. Those with higher priority come first. Rules\n\t//   without a priority are counted as having priority 50. This\n\t//   property is only meaningful in a schema—when directly\n\t//   constructing a parser, the order of the rule array is used.\n\t//\n\t//   ignore:: ?bool\n\t//   When true, ignore content that matches this rule.\n\t//\n\t//   skip:: ?bool\n\t//   When true, ignore the node that matches this rule, but do parse\n\t//   its content.\n\t//\n\t//   attrs:: ?Object\n\t//   Attributes for the node or mark created by this rule. When\n\t//   `getAttrs` is provided, it takes precedence.\n\t//\n\t//   getAttrs:: ?(union<dom.Node, string>) → ?union<bool, Object>\n\t//   A function used to compute the attributes for the node or mark\n\t//   created by this rule. Can also be used to describe further\n\t//   conditions the DOM element or style must match. When it returns\n\t//   `false`, the rule won't match. When it returns null or undefined,\n\t//   that is interpreted as an empty/default set of attributes.\n\t//\n\t//   Called with a DOM Element for `tag` rules, and with a string (the\n\t//   style's value) for `style` rules.\n\t//\n\t//   contentElement:: ?string\n\t//   For `tag` rules that produce non-leaf nodes or marks, by default\n\t//   the content of the DOM element is parsed as content of the mark\n\t//   or node. If the child nodes are in a descendent node, this may be\n\t//   a CSS selector string that the parser must use to find the actual\n\t//   content element.\n\t//\n\t//   getContent:: ?(dom.Node) → Fragment\n\t//   Can be used to override the content of a matched node. Will be\n\t//   called, and its result used, instead of parsing the node's child\n\t//   node.\n\t//\n\t//   preserveWhitespace:: ?bool\n\t//   Controls whether whitespace should be preserved when parsing the\n\t//   content inside the matched element.\n\t\n\t// ::- A DOM parser represents a strategy for parsing DOM content into\n\t// a ProseMirror document conforming to a given schema. Its behavior\n\t// is defined by an array of [rules](#model.ParseRule).\n\tvar DOMParser = function(schema, rules) {\n\t  var this$1 = this;\n\t\n\t  // :: Schema\n\t  this.schema = schema\n\t  // :: [ParseRule]\n\t  this.rules = rules\n\t  this.tags = []\n\t  this.styles = []\n\t\n\t  rules.forEach(function (rule) {\n\t    if (rule.tag) { this$1.tags.push(rule) }\n\t    else if (rule.style) { this$1.styles.push(rule) }\n\t  })\n\t};\n\t\n\t// :: (dom.Node, ?Object) → Node\n\t// Parse a document from the content of a DOM node.\n\t//\n\t// options::- Configuration options.\n\t//\n\t//   preserveWhitespace:: ?bool\n\t//   By default, whitespace is collapsed as per HTML's rules. Pass\n\t//   true here to prevent the parser from doing that.\n\t//\n\t//   findPositions:: ?[{node: dom.Node, offset: number}]\n\t//   When given, the parser will, beside parsing the content,\n\t//   record the document positions of the given DOM positions. It\n\t//   will do so by writing to the objects, adding a `pos` property\n\t//   that holds the document position. DOM positions that are not\n\t//   in the parsed content will not be written to.\n\t//\n\t//   from:: ?number\n\t//   The child node index to start parsing from.\n\t//\n\t//   to:: ?number\n\t//   The child node index to stop parsing at.\n\t//\n\t//   topNode:: ?Node\n\t//   By default, the content is parsed into a `doc` node. You can\n\t//   pass this option to use the type and attributes from a\n\t//   different node as the top container.\n\t//\n\t//   topStart:: ?number\n\t//   Can be used to influence the content match at the start of\n\t//   the topnode. When given, should be a valid index into\n\t//   `topNode`.\n\tDOMParser.prototype.parse = function (dom, options) {\n\t    if ( options === void 0 ) options = {};\n\t\n\t  var context = new ParseContext(this, options, false)\n\t  context.addAll(dom, null, options.from, options.to)\n\t  return context.finish()\n\t};\n\t\n\t// :: (dom.Node, ?Object) → Slice\n\t// Parses the content of the given DOM node, like\n\t// [`parse`](#model.DOMParser.parse), and takes the same set of\n\t// options. But unlike that method, which produces a whole node,\n\t// this one returns a slice that is open at the sides, meaning that\n\t// the schema constraints aren't applied to the start of nodes to\n\t// the left of the input and the end of nodes at the end.\n\tDOMParser.prototype.parseSlice = function (dom, options) {\n\t    if ( options === void 0 ) options = {};\n\t\n\t  var context = new ParseContext(this, options, true)\n\t  context.addAll(dom, null, options.from, options.to)\n\t  return Slice.maxOpen(context.finish())\n\t};\n\t\n\tDOMParser.prototype.matchTag = function (dom) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < this.tags.length; i++) {\n\t    var rule = this$1.tags[i]\n\t    if (matches(dom, rule.tag)) {\n\t      if (rule.getAttrs) {\n\t        var result = rule.getAttrs(dom)\n\t        if (result === false) { continue }\n\t        rule.attrs = result\n\t      }\n\t      return rule\n\t    }\n\t  }\n\t};\n\t\n\tDOMParser.prototype.matchStyle = function (prop, value) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < this.styles.length; i++) {\n\t    var rule = this$1.styles[i]\n\t    if (rule.style == prop) {\n\t      if (rule.getAttrs) {\n\t        var result = rule.getAttrs(value)\n\t        if (result === false) { continue }\n\t        rule.attrs = result\n\t      }\n\t      return rule\n\t    }\n\t  }\n\t};\n\t\n\t// :: (Schema) → [ParseRule]\n\t// Extract the parse rules listed in a schema's [node\n\t// specs](#model.NodeSpec.parseDOM).\n\tDOMParser.schemaRules = function (schema) {\n\t  var result = []\n\t  function insert(rule) {\n\t    var priority = rule.priority == null ? 50 : rule.priority, i = 0\n\t    for (; i < result.length; i++) {\n\t      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n\t      if (nextPriority < priority) { break }\n\t    }\n\t    result.splice(i, 0, rule)\n\t  }\n\t\n\t  var loop = function ( name ) {\n\t    var rules = schema.marks[name].spec.parseDOM\n\t    if (rules) { rules.forEach(function (rule) {\n\t      insert(rule = copy(rule))\n\t      rule.mark = name\n\t    }) }\n\t  };\n\t\n\t    for (var name in schema.marks) loop( name );\n\t  var loop$1 = function ( name ) {\n\t    var rules$1 = schema.nodes[name$1].spec.parseDOM\n\t    if (rules$1) { rules$1.forEach(function (rule) {\n\t      insert(rule = copy(rule))\n\t      rule.node = name$1\n\t    }) }\n\t  };\n\t\n\t    for (var name$1 in schema.nodes) loop$1( name );\n\t  return result\n\t};\n\t\n\t// :: (Schema) → DOMParser\n\t// Construct a DOM parser using the parsing rules listed in a\n\t// schema's [node specs](#model.NodeSpec.parseDOM).\n\tDOMParser.fromSchema = function (schema) {\n\t  return schema.cached.domParser ||\n\t    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n\t};\n\texports.DOMParser = DOMParser\n\t\n\t// : Object<bool> The block-level tags in HTML5\n\tvar blockTags = {\n\t  address: true, article: true, aside: true, blockquote: true, canvas: true,\n\t  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n\t  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n\t  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n\t  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n\t}\n\t\n\t// : Object<bool> The tags that we normally ignore.\n\tvar ignoreTags = {\n\t  head: true, noscript: true, object: true, script: true, style: true, title: true\n\t}\n\t\n\t// : Object<bool> List tags.\n\tvar listTags = {ol: true, ul: true}\n\t\n\t// Using a bitfield for node context options\n\tvar OPT_PRESERVE_WS = 1, OPT_OPEN_LEFT = 2\n\t\n\tvar NodeContext = function(type, attrs, solid, match, options) {\n\t  this.type = type\n\t  this.attrs = attrs\n\t  this.solid = solid\n\t  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentExpr.start(attrs))\n\t  this.options = options\n\t  this.content = []\n\t};\n\t\n\tNodeContext.prototype.findWrapping = function (type, attrs) {\n\t  if (!this.match) {\n\t    if (!this.type) { return [] }\n\t    var found = this.type.contentExpr.atType(this.attrs, type, attrs)\n\t    if (!found) {\n\t      var start = this.type.contentExpr.start(this.attrs), wrap\n\t      if (wrap = start.findWrapping(type, attrs)) {\n\t        this.match = start\n\t        return wrap\n\t      }\n\t    }\n\t    if (found) { this.match = found }\n\t    else { return null }\n\t  }\n\t  return this.match.findWrapping(type, attrs)\n\t};\n\t\n\tNodeContext.prototype.finish = function (openRight) {\n\t  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n\t    var last = this.content[this.content.length - 1], m\n\t    if (last && last.isText && (m = /\\s+$/.exec(last.text))) {\n\t      if (last.text.length == m[0].length) { this.content.pop() }\n\t      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)) }\n\t    }\n\t  }\n\t  var content = Fragment.from(this.content)\n\t  if (!openRight && this.match)\n\t    { content = content.append(this.match.fillBefore(Fragment.empty, true)) }\n\t  return this.type ? this.type.create(this.attrs, content) : content\n\t};\n\t\n\tvar ParseContext = function(parser, options, open) {\n\t  // : DOMParser The parser we are using.\n\t  this.parser = parser\n\t  // : Object The options passed to this parse.\n\t  this.options = options\n\t  this.isOpen = open\n\t  var topNode = options.topNode, topContext\n\t  var topOptions = (options.preserveWhitespace ? OPT_PRESERVE_WS : 0) | (open ? OPT_OPEN_LEFT : 0)\n\t  if (topNode)\n\t    { topContext = new NodeContext(topNode.type, topNode.attrs, true,\n\t                                 topNode.contentMatchAt(options.topStart || 0), topOptions) }\n\t  else if (open)\n\t    { topContext = new NodeContext(null, null, true, null, topOptions) }\n\t  else\n\t    { topContext = new NodeContext(parser.schema.nodes.doc, null, true, null, topOptions) }\n\t  this.nodes = [topContext]\n\t  // : [Mark] The current set of marks\n\t  this.marks = Mark.none\n\t  this.open = 0\n\t  this.find = options.findPositions\n\t};\n\t\n\tvar prototypeAccessors = { top: {},currentPos: {} };\n\t\n\tprototypeAccessors.top.get = function () {\n\t  return this.nodes[this.open]\n\t};\n\t\n\t// : (Mark) → [Mark]\n\t// Add a mark to the current set of marks, return the old set.\n\tParseContext.prototype.addMark = function (mark) {\n\t  var old = this.marks\n\t  this.marks = mark.addToSet(this.marks)\n\t  return old\n\t};\n\t\n\t// : (dom.Node)\n\t// Add a DOM node to the content. Text is inserted as text node,\n\t// otherwise, the node is passed to `addElement` or, if it has a\n\t// `style` attribute, `addElementWithStyles`.\n\tParseContext.prototype.addDOM = function (dom) {\n\t  if (dom.nodeType == 3) {\n\t    this.addTextNode(dom)\n\t  } else if (dom.nodeType == 1) {\n\t    var style = dom.getAttribute(\"style\")\n\t    if (style) { this.addElementWithStyles(parseStyles(style), dom) }\n\t    else { this.addElement(dom) }\n\t  }\n\t};\n\t\n\tParseContext.prototype.addTextNode = function (dom) {\n\t  var value = dom.nodeValue\n\t  var top = this.top\n\t  if ((top.type && top.type.isTextblock) || /\\S/.test(value)) {\n\t    if (!(top.options & OPT_PRESERVE_WS)) {\n\t      value = value.replace(/\\s+/g, \" \")\n\t      // If this starts with whitespace, and there is either no node\n\t      // before it or a node that ends with whitespace, strip the\n\t      // leading space.\n\t      if (/^\\s/.test(value)) {\n\t        var nodeBefore = top.content[top.content.length - 1]\n\t        if (!nodeBefore || nodeBefore.isText && /\\s$/.test(nodeBefore.text))\n\t          { value = value.slice(1) }\n\t      }\n\t    }\n\t    if (value) { this.insertNode(this.parser.schema.text(value, this.marks)) }\n\t    this.findInText(dom)\n\t  } else {\n\t    this.findInside(dom)\n\t  }\n\t};\n\t\n\t// : (dom.Element)\n\t// Try to find a handler for the given tag and use that to parse. If\n\t// none is found, the element's content nodes are added directly.\n\tParseContext.prototype.addElement = function (dom) {\n\t  var name = dom.nodeName.toLowerCase()\n\t  if (listTags.hasOwnProperty(name)) { normalizeList(dom) }\n\t  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom)\n\t  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n\t    this.findInside(dom)\n\t  } else if (!rule || rule.skip) {\n\t    if (rule && rule.skip.nodeType) { dom = rule.skip }\n\t    var sync = blockTags.hasOwnProperty(name) && this.top\n\t    this.addAll(dom)\n\t    if (sync) { this.sync(sync) }\n\t  } else {\n\t    this.addElementByRule(dom, rule)\n\t  }\n\t};\n\t\n\t// Run any style parser associated with the node's styles. After\n\t// that, if no style parser suppressed the node's content, pass it\n\t// through to `addElement`.\n\tParseContext.prototype.addElementWithStyles = function (styles, dom) {\n\t    var this$1 = this;\n\t\n\t  var oldMarks = this.marks, ignore = false\n\t  for (var i = 0; i < styles.length; i += 2) {\n\t    var rule = this$1.parser.matchStyle(styles[i], styles[i + 1])\n\t    if (!rule) { continue }\n\t    if (rule.ignore) { ignore = true; break }\n\t    this$1.addMark(this$1.parser.schema.marks[rule.mark].create(rule.attrs))\n\t  }\n\t  if (!ignore) { this.addElement(dom) }\n\t  this.marks = oldMarks\n\t};\n\t\n\t// : (dom.Element, ParseRule) → bool\n\t// Look up a handler for the given node. If none are found, return\n\t// false. Otherwise, apply it, use its return value to drive the way\n\t// the node's content is wrapped, and return true.\n\tParseContext.prototype.addElementByRule = function (dom, rule) {\n\t    var this$1 = this;\n\t\n\t  var sync, before, nodeType, markType, mark\n\t  if (rule.node) {\n\t    nodeType = this.parser.schema.nodes[rule.node]\n\t    if (nodeType.isLeaf) { this.insertNode(nodeType.create(rule.attrs, null, this.marks)) }\n\t    else { sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace) && this.top }\n\t  } else {\n\t    markType = this.parser.schema.marks[rule.mark]\n\t    before = this.addMark(mark = markType.create(rule.attrs))\n\t  }\n\t\n\t  if (nodeType && nodeType.isLeaf) {\n\t    this.findInside(dom)\n\t  } else if (rule.getContent) {\n\t    this.findInside(dom)\n\t    rule.getContent(dom).forEach(function (node) { return this$1.insertNode(mark ? node.mark(mark.addToSet(node.marks)) : node); })\n\t  } else {\n\t    var contentDOM = rule.contentElement\n\t    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM) }\n\t    if (!contentDOM) { contentDOM = dom }\n\t    this.findAround(dom, contentDOM, true)\n\t    this.addAll(contentDOM, sync)\n\t    if (sync) { this.sync(sync); this.open-- }\n\t    else if (before) { this.marks = before }\n\t    this.findAround(dom, contentDOM, true)\n\t  }\n\t  return true\n\t};\n\t\n\t// : (dom.Node, ?NodeBuilder, ?number, ?number)\n\t// Add all child nodes between `startIndex` and `endIndex` (or the\n\t// whole node, if not given). If `sync` is passed, use it to\n\t// synchronize after every block element.\n\tParseContext.prototype.addAll = function (parent, sync, startIndex, endIndex) {\n\t    var this$1 = this;\n\t\n\t  var index = startIndex || 0\n\t  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n\t           end = endIndex == null ? null : parent.childNodes[endIndex];\n\t       dom != end; dom = dom.nextSibling, ++index) {\n\t    this$1.findAtPoint(parent, index)\n\t    this$1.addDOM(dom)\n\t    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n\t      { this$1.sync(sync) }\n\t  }\n\t  this.findAtPoint(parent, index)\n\t};\n\t\n\t// Try to find a way to fit the given node type into the current\n\t// context. May add intermediate wrappers and/or leave non-solid\n\t// nodes that we're in.\n\tParseContext.prototype.findPlace = function (type, attrs) {\n\t    var this$1 = this;\n\t\n\t  var route, sync\n\t  for (var depth = this.open; depth >= 0; depth--) {\n\t    var node = this$1.nodes[depth]\n\t    var found = node.findWrapping(type, attrs)\n\t    if (found && (!route || route.length > found.length)) {\n\t      route = found\n\t      sync = node\n\t      if (!found.length) { break }\n\t    }\n\t    if (node.solid) { break }\n\t  }\n\t  if (!route) { return false }\n\t  this.sync(sync)\n\t  for (var i = 0; i < route.length; i++)\n\t    { this$1.enterInner(route[i].type, route[i].attrs, false) }\n\t  return true\n\t};\n\t\n\t// : (Node) → ?Node\n\t// Try to insert the given node, adjusting the context when needed.\n\tParseContext.prototype.insertNode = function (node) {\n\t  if (this.findPlace(node.type, node.attrs)) {\n\t    this.closeExtra()\n\t    var top = this.top\n\t    if (top.match) {\n\t      var match = top.match.matchNode(node)\n\t      if (!match) {\n\t        node = node.mark(node.marks.filter(function (mark) { return top.match.allowsMark(mark.type); }))\n\t        match = top.match.matchNode(node)\n\t      }\n\t      top.match = match\n\t    }\n\t    top.content.push(node)\n\t  }\n\t};\n\t\n\t// : (NodeType, ?Object) → bool\n\t// Try to start a node of the given type, adjusting the context when\n\t// necessary.\n\tParseContext.prototype.enter = function (type, attrs, preserveWS) {\n\t  var ok = this.findPlace(type, attrs)\n\t  if (ok) { this.enterInner(type, attrs, true, preserveWS) }\n\t  return ok\n\t};\n\t\n\t// Open a node of the given type\n\tParseContext.prototype.enterInner = function (type, attrs, solid, preserveWS) {\n\t  this.closeExtra()\n\t  var top = this.top\n\t  top.match = top.match && top.match.matchType(type, attrs)\n\t  var options = preserveWS == null ? top.options & OPT_PRESERVE_WS : preserveWS ? OPT_PRESERVE_WS : 0\n\t  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT }\n\t  this.nodes.push(new NodeContext(type, attrs, solid, null, options))\n\t  this.open++\n\t};\n\t\n\t// Make sure all nodes above this.open are finished and added to\n\t// their parents\n\tParseContext.prototype.closeExtra = function (openRight) {\n\t    var this$1 = this;\n\t\n\t  var i = this.nodes.length - 1\n\t  if (i > this.open) {\n\t    this.marks = Mark.none\n\t    for (; i > this.open; i--) { this$1.nodes[i - 1].content.push(this$1.nodes[i].finish(openRight)) }\n\t    this.nodes.length = this.open + 1\n\t  }\n\t};\n\t\n\tParseContext.prototype.finish = function () {\n\t  this.open = 0\n\t  this.closeExtra(this.isOpen)\n\t  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n\t};\n\t\n\tParseContext.prototype.sync = function (to) {\n\t    var this$1 = this;\n\t\n\t  for (var i = this.open; i >= 0; i--) { if (this$1.nodes[i] == to) {\n\t    this$1.open = i\n\t    return\n\t  } }\n\t};\n\t\n\tprototypeAccessors.currentPos.get = function () {\n\t    var this$1 = this;\n\t\n\t  this.closeExtra()\n\t  var pos = 0\n\t  for (var i = this.open; i >= 0; i--) {\n\t    var content = this$1.nodes[i].content\n\t    for (var j = content.length - 1; j >= 0; j--)\n\t      { pos += content[j].nodeSize }\n\t    if (i) { pos++ }\n\t  }\n\t  return pos\n\t};\n\t\n\tParseContext.prototype.findAtPoint = function (parent, offset) {\n\t    var this$1 = this;\n\t\n\t  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n\t    if (this$1.find[i].node == parent && this$1.find[i].offset == offset)\n\t      { this$1.find[i].pos = this$1.currentPos }\n\t  } }\n\t};\n\t\n\tParseContext.prototype.findInside = function (parent) {\n\t    var this$1 = this;\n\t\n\t  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n\t    if (this$1.find[i].pos == null && parent.contains(this$1.find[i].node))\n\t      { this$1.find[i].pos = this$1.currentPos }\n\t  } }\n\t};\n\t\n\tParseContext.prototype.findAround = function (parent, content, before) {\n\t    var this$1 = this;\n\t\n\t  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n\t    if (this$1.find[i].pos == null && parent.contains(this$1.find[i].node)) {\n\t      var pos = content.compareDocumentPosition(this$1.find[i].node)\n\t      if (pos & (before ? 2 : 4))\n\t        { this$1.find[i].pos = this$1.currentPos }\n\t    }\n\t  } }\n\t};\n\t\n\tParseContext.prototype.findInText = function (textNode) {\n\t    var this$1 = this;\n\t\n\t  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n\t    if (this$1.find[i].node == textNode)\n\t      { this$1.find[i].pos = this$1.currentPos - (textNode.nodeValue.length - this$1.find[i].offset) }\n\t  } }\n\t};\n\t\n\tObject.defineProperties( ParseContext.prototype, prototypeAccessors );\n\t\n\t// Kludge to work around directly nested list nodes produced by some\n\t// tools and allowed by browsers to mean that the nested list is\n\t// actually part of the list item above it.\n\tfunction normalizeList(dom) {\n\t  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n\t    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n\t    if (name && listTags.hasOwnProperty(name) && prevItem) {\n\t      prevItem.appendChild(child)\n\t      child = prevItem\n\t    } else if (name == \"li\") {\n\t      prevItem = child\n\t    } else if (name) {\n\t      prevItem = null\n\t    }\n\t  }\n\t}\n\t\n\t// Apply a CSS selector.\n\tfunction matches(dom, selector) {\n\t  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n\t}\n\t\n\t// : (string) → [string]\n\t// Tokenize a style attribute into property/value pairs.\n\tfunction parseStyles(style) {\n\t  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n\t  while (m = re.exec(style)) { result.push(m[1], m[2].trim()) }\n\t  return result\n\t}\n\t\n\tfunction copy(obj) {\n\t  var copy = {}\n\t  for (var prop in obj) { copy[prop] = obj[prop] }\n\t  return copy\n\t}\n\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar OrderedMap = __webpack_require__(134)\n\t\n\tvar ref = __webpack_require__(52);\n\tvar Node = ref.Node;\n\tvar TextNode = ref.TextNode;\n\tvar ref$1 = __webpack_require__(5);\n\tvar Fragment = ref$1.Fragment;\n\tvar ref$2 = __webpack_require__(6);\n\tvar Mark = ref$2.Mark;\n\tvar ref$3 = __webpack_require__(51);\n\tvar ContentExpr = ref$3.ContentExpr;\n\t\n\t// For node types where all attrs have a default value (or which don't\n\t// have any attributes), build up a single reusable default attribute\n\t// object, and use it for all nodes that don't specify specific\n\t// attributes.\n\tfunction defaultAttrs(attrs) {\n\t  var defaults = Object.create(null)\n\t  for (var attrName in attrs) {\n\t    var attr = attrs[attrName]\n\t    if (attr.default === undefined) { return null }\n\t    defaults[attrName] = attr.default\n\t  }\n\t  return defaults\n\t}\n\t\n\tfunction computeAttrs(attrs, value) {\n\t  var built = Object.create(null)\n\t  for (var name in attrs) {\n\t    var given = value && value[name]\n\t    if (given == null) {\n\t      var attr = attrs[name]\n\t      if (attr.default !== undefined)\n\t        { given = attr.default }\n\t      else if (attr.compute)\n\t        { given = attr.compute() }\n\t      else\n\t        { throw new RangeError(\"No value supplied for attribute \" + name) }\n\t    }\n\t    built[name] = given\n\t  }\n\t  return built\n\t}\n\t\n\tfunction initAttrs(attrs) {\n\t  var result = Object.create(null)\n\t  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]) } }\n\t  return result\n\t}\n\t\n\t// ::- Node types are objects allocated once per `Schema` and used to\n\t// tag `Node` instances with a type. They contain information about\n\t// the node type, such as its name and what kind of node it\n\t// represents.\n\tvar NodeType = function(name, schema, spec) {\n\t  // :: string\n\t  // The name the node type has in this schema.\n\t  this.name = name\n\t\n\t  // :: Schema\n\t  // A link back to the `Schema` the node type belongs to.\n\t  this.schema = schema\n\t\n\t  // :: NodeSpec\n\t  // The spec that this type is based on\n\t  this.spec = spec\n\t\n\t  this.attrs = initAttrs(spec.attrs)\n\t\n\t  this.defaultAttrs = defaultAttrs(this.attrs)\n\t  this.contentExpr = null\n\t\n\t  // :: bool\n\t  // True if this is a block type\n\t  this.isBlock = !(spec.inline || name == \"text\")\n\t\n\t  // :: bool\n\t  // True if this is the text node type.\n\t  this.isText = name == \"text\"\n\t};\n\t\n\tvar prototypeAccessors = { isInline: {},isTextblock: {},isLeaf: {} };\n\t\n\t// :: bool\n\t// True if this is an inline type.\n\tprototypeAccessors.isInline.get = function () { return !this.isBlock };\n\t\n\t// :: bool\n\t// True if this is a textblock type, a block that contains inline\n\t// content.\n\tprototypeAccessors.isTextblock.get = function () { return this.isBlock && this.contentExpr.inlineContent };\n\t\n\t// :: bool\n\t// True for node types that allow no content.\n\tprototypeAccessors.isLeaf.get = function () { return this.contentExpr.isLeaf };\n\t\n\tNodeType.prototype.hasRequiredAttrs = function (ignore) {\n\t    var this$1 = this;\n\t\n\t  for (var n in this$1.attrs)\n\t    { if (this$1.attrs[n].isRequired && (!ignore || !(n in ignore))) { return true } }\n\t  return false\n\t};\n\t\n\tNodeType.prototype.compatibleContent = function (other) {\n\t  return this == other || this.contentExpr.compatible(other.contentExpr)\n\t};\n\t\n\tNodeType.prototype.computeAttrs = function (attrs) {\n\t  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n\t  else { return computeAttrs(this.attrs, attrs) }\n\t};\n\t\n\t// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n\t// Create a `Node` of this type. The given attributes are\n\t// checked and defaulted (you can pass `null` to use the type's\n\t// defaults entirely, if no required attributes exist). `content`\n\t// may be a `Fragment`, a node, an array of nodes, or\n\t// `null`. Similarly `marks` may be `null` to default to the empty\n\t// set of marks.\n\tNodeType.prototype.create = function (attrs, content, marks) {\n\t  if (typeof content == \"string\") { throw new Error(\"Calling create with string\") }\n\t  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n\t};\n\t\n\t// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n\t// Like [`create`](#model.NodeType.create), but check the given content\n\t// against the node type's content restrictions, and throw an error\n\t// if it doesn't match.\n\tNodeType.prototype.createChecked = function (attrs, content, marks) {\n\t  attrs = this.computeAttrs(attrs)\n\t  content = Fragment.from(content)\n\t  if (!this.validContent(content, attrs))\n\t    { throw new RangeError(\"Invalid content for node \" + this.name) }\n\t  return new Node(this, attrs, content, Mark.setFrom(marks))\n\t};\n\t\n\t// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n\t// Like [`create`](#model.NodeType.create), but see if it is necessary to\n\t// add nodes to the start or end of the given fragment to make it\n\t// fit the node. If no fitting wrapping can be found, return null.\n\t// Note that, due to the fact that required nodes can always be\n\t// created, this will always succeed if you pass null or\n\t// `Fragment.empty` as content.\n\tNodeType.prototype.createAndFill = function (attrs, content, marks) {\n\t  attrs = this.computeAttrs(attrs)\n\t  content = Fragment.from(content)\n\t  if (content.size) {\n\t    var before = this.contentExpr.start(attrs).fillBefore(content)\n\t    if (!before) { return null }\n\t    content = before.append(content)\n\t  }\n\t  var after = this.contentExpr.getMatchAt(attrs, content).fillBefore(Fragment.empty, true)\n\t  if (!after) { return null }\n\t  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n\t};\n\t\n\t// :: (Fragment, ?Object) → bool\n\t// Returns true if the given fragment is valid content for this node\n\t// type with the given attributes.\n\tNodeType.prototype.validContent = function (content, attrs) {\n\t  return this.contentExpr.matches(attrs, content)\n\t};\n\t\n\tNodeType.compile = function (nodes, schema) {\n\t  var result = Object.create(null)\n\t  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); })\n\t\n\t  if (!result.doc) { throw new RangeError(\"Every schema needs a 'doc' type\") }\n\t  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n\t\n\t  return result\n\t};\n\t\n\tObject.defineProperties( NodeType.prototype, prototypeAccessors );\n\texports.NodeType = NodeType\n\t\n\t// Attribute descriptors\n\t\n\tvar Attribute = function(options) {\n\t  this.default = options.default\n\t  this.compute = options.compute\n\t};\n\t\n\tvar prototypeAccessors$1 = { isRequired: {} };\n\t\n\tprototypeAccessors$1.isRequired.get = function () {\n\t  return this.default === undefined && !this.compute\n\t};\n\t\n\tObject.defineProperties( Attribute.prototype, prototypeAccessors$1 );\n\t\n\t// Marks\n\t\n\t// ::- Like nodes, marks (which are associated with nodes to signify\n\t// things like emphasis or being part of a link) are tagged with type\n\t// objects, which are instantiated once per `Schema`.\n\tvar MarkType = function(name, rank, schema, spec) {\n\t  // :: string\n\t  // The name of the mark type.\n\t  this.name = name\n\t\n\t  // :: Schema\n\t  // The schema that this mark type instance is part of.\n\t  this.schema = schema\n\t\n\t  // :: MarkSpec\n\t  // The spec on which the type is based.\n\t  this.spec = spec\n\t\n\t  this.attrs = initAttrs(spec.attrs)\n\t\n\t  this.rank = rank\n\t  var defaults = defaultAttrs(this.attrs)\n\t  this.instance = defaults && new Mark(this, defaults)\n\t};\n\t\n\t// :: (?Object) → Mark\n\t// Create a mark of this type. `attrs` may be `null` or an object\n\t// containing only some of the mark's attributes. The others, if\n\t// they have defaults, will be added.\n\tMarkType.prototype.create = function (attrs) {\n\t  if (!attrs && this.instance) { return this.instance }\n\t  return new Mark(this, computeAttrs(this.attrs, attrs))\n\t};\n\t\n\tMarkType.compile = function (marks, schema) {\n\t  var result = Object.create(null), rank = 0\n\t  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); })\n\t  return result\n\t};\n\t\n\t// :: ([Mark]) → [Mark]\n\t// When there is a mark of this type in the given set, a new set\n\t// without it is returned. Otherwise, the input set is returned.\n\tMarkType.prototype.removeFromSet = function (set) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < set.length; i++)\n\t    { if (set[i].type == this$1)\n\t      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n\t  return set\n\t};\n\t\n\t// :: ([Mark]) → ?Mark\n\t// Tests whether there is a mark of this type in the given set.\n\tMarkType.prototype.isInSet = function (set) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0; i < set.length; i++)\n\t    { if (set[i].type == this$1) { return set[i] } }\n\t};\n\texports.MarkType = MarkType\n\t\n\t// SchemaSpec:: interface\n\t// An object describing a schema, as passed to the `Schema`\n\t// constructor.\n\t//\n\t//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n\t//   The node types in this schema. Maps names to `NodeSpec` objects\n\t//   describing the node to be associated with that name. Their order\n\t//   is significant\n\t//\n\t//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n\t//   The mark types that exist in this schema.\n\t\n\t// NodeSpec:: interface\n\t//\n\t//   content:: ?string\n\t//   The content expression for this node, as described in the [schema\n\t//   guide](guide/schema.html). When not given, the node does not allow\n\t//   any content.\n\t//\n\t//   group:: ?string\n\t//   The group or space-separated groups to which this node belongs, as\n\t//   referred to in the content expressions for the schema.\n\t//\n\t//   inline:: ?bool\n\t//   Should be set to a truthy value for inline nodes. (Implied for\n\t//   text nodes.)\n\t//\n\t//   attrs:: ?Object<AttributeSpec>\n\t//   The attributes that nodes of this type get.\n\t//\n\t//   selectable:: ?bool\n\t//   Controls whether nodes of this type can be selected (as a [node\n\t//   selection](#state.NodeSelection)). Defaults to true for non-text\n\t//   nodes.\n\t//\n\t//   draggable:: ?bool\n\t//   Determines whether nodes of this type can be dragged. Enabling it\n\t//   causes ProseMirror to set a `draggable` attribute on its DOM\n\t//   representation, and to put its HTML serialization into the drag\n\t//   event's [data\n\t//   transfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)\n\t//   when dragged. Defaults to false.\n\t//\n\t//   code:: ?bool\n\t//   Can be used to indicate that this node contains code, which\n\t//   causes some commands to behave differently.\n\t//\n\t//   defining:: ?bool\n\t//   Determines whether this node is considered an important parent\n\t//   node during replace operations (such as paste). Non-defining (the\n\t//   default) nodes get dropped when their entire content is replaced,\n\t//   whereas defining nodes persist and wrap the inserted content.\n\t//   Likewise, the the _inserted_ content, when not inserting into a\n\t//   textblock, the defining parents of the content are preserved.\n\t//   Typically, non-default-paragraph textblock types, and possible\n\t//   list items, are marked as defining.\n\t//\n\t//   toDOM:: ?(Node) → DOMOutputSpec\n\t//   Defines the default way a node of this type should be serialized\n\t//   to DOM/HTML (as used by\n\t//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema).\n\t//   Should return an [array structure](#model.DOMOutputSpec) that\n\t//   describes the resulting DOM structure, with an optional number\n\t//   zero (“hole”) in it to indicate where the node's content should\n\t//   be inserted.\n\t//\n\t//   parseDOM:: ?[ParseRule]\n\t//   Associates DOM parser information with this node, which can be\n\t//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n\t//   automatically derive a parser. The `node` field in the rules is\n\t//   implied (the name of this node will be filled in automatically).\n\t//   If you supply your own parser, you do not need to also specify\n\t//   parsing rules in your schema.\n\t\n\t// MarkSpec:: interface\n\t//\n\t//   attrs:: ?Object<AttributeSpec>\n\t//   The attributes that marks of this type get.\n\t//\n\t//   inclusiveRight:: ?bool\n\t//   Whether this mark should be active when the cursor is positioned\n\t//   at the end of the mark. Defaults to true.\n\t//\n\t//   toDOM:: ?(mark: Mark) → DOMOutputSpec\n\t//   Defines the default way marks of this type should be serialized\n\t//   to DOM/HTML.\n\t//\n\t//   parseDOM:: ?[ParseRule]\n\t//   Associates DOM parser information with this mark (see the\n\t//   corresponding [node spec field](#model.NodeSpec.parseDOM). The\n\t//   `mark` field in the rules is implied.\n\t\n\t// AttributeSpec:: interface\n\t//\n\t// Used to define attributes. Attributes that have no default or\n\t// compute property must be provided whenever a node or mark of a type\n\t// that has them is created.\n\t//\n\t// The following fields are supported:\n\t//\n\t//   default:: ?any\n\t//   The default value for this attribute, to choose when no\n\t//   explicit value is provided.\n\t//\n\t//   compute:: ?() → any\n\t//   A function that computes a default value for the attribute.\n\t\n\t// ::- A document schema.\n\tvar Schema = function(spec) {\n\t  var this$1 = this;\n\t\n\t  // :: OrderedMap<NodeSpec> The node specs that the schema is based on.\n\t  this.nodeSpec = OrderedMap.from(spec.nodes)\n\t  // :: OrderedMap<MarkSpec> The mark spec that the schema is based on.\n\t  this.markSpec = OrderedMap.from(spec.marks)\n\t\n\t  // :: Object<NodeType>\n\t  // An object mapping the schema's node names to node type objects.\n\t  this.nodes = NodeType.compile(this.nodeSpec, this)\n\t\n\t  // :: Object<MarkType>\n\t  // A map from mark names to mark type objects.\n\t  this.marks = MarkType.compile(this.markSpec, this)\n\t\n\t  for (var prop in this$1.nodes) {\n\t    if (prop in this$1.marks)\n\t      { throw new RangeError(prop + \" can not be both a node and a mark\") }\n\t    var type = this$1.nodes[prop]\n\t    type.contentExpr = ContentExpr.parse(type, this$1.nodeSpec.get(prop).content || \"\", this$1.nodeSpec)\n\t  }\n\t\n\t  // :: Object\n\t  // An object for storing whatever values modules may want to\n\t  // compute and cache per schema. (If you want to store something\n\t  // in it, try to use property names unlikely to clash.)\n\t  this.cached = Object.create(null)\n\t  this.cached.wrappings = Object.create(null)\n\t\n\t  this.nodeFromJSON = this.nodeFromJSON.bind(this)\n\t  this.markFromJSON = this.markFromJSON.bind(this)\n\t};\n\t\n\t// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n\t// Create a node in this schema. The `type` may be a string or a\n\t// `NodeType` instance. Attributes will be extended\n\t// with defaults, `content` may be a `Fragment`,\n\t// `null`, a `Node`, or an array of nodes.\n\tSchema.prototype.node = function (type, attrs, content, marks) {\n\t  if (typeof type == \"string\")\n\t    { type = this.nodeType(type) }\n\t  else if (!(type instanceof NodeType))\n\t    { throw new RangeError(\"Invalid node type: \" + type) }\n\t  else if (type.schema != this)\n\t    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\t\n\t  return type.createChecked(attrs, content, marks)\n\t};\n\t\n\t// :: (string, ?[Mark]) → Node\n\t// Create a text node in the schema. Empty text nodes are not\n\t// allowed.\n\tSchema.prototype.text = function (text$1, marks) {\n\t  var type = this.nodes.text\n\t  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n\t};\n\t\n\t// :: (union<string, MarkType>, ?Object) → Mark\n\t// Create a mark with the given type and attributes.\n\tSchema.prototype.mark = function (type, attrs) {\n\t  if (typeof type == \"string\") { type = this.marks[type] }\n\t  return type.create(attrs)\n\t};\n\t\n\t// :: (Object) → Node\n\t// Deserialize a node from its JSON representation. This method is\n\t// bound.\n\tSchema.prototype.nodeFromJSON = function (json) {\n\t  return Node.fromJSON(this, json)\n\t};\n\t\n\t// :: (Object) → Mark\n\t// Deserialize a mark from its JSON representation. This method is\n\t// bound.\n\tSchema.prototype.markFromJSON = function (json) {\n\t  return Mark.fromJSON(this, json)\n\t};\n\t\n\tSchema.prototype.nodeType = function (name) {\n\t  var found = this.nodes[name]\n\t  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n\t  return found\n\t};\n\texports.Schema = Schema\n\n\n/***/ },\n/* 149 */\n/***/ function(module, exports) {\n\n\t// DOMOutputSpec:: interface\n\t// A description of a DOM structure. Can be either a string, which is\n\t// interpreted as a text node, a DOM node, which is interpreted as\n\t// itself, or an array.\n\t//\n\t// An array describes a DOM element. The first element in the array\n\t// should be a string, and is the name of the DOM element. If the\n\t// second element is a non-Array, non-DOM node object, it is\n\t// interpreted as an object providing the DOM element's attributes.\n\t// Any elements after that (including the 2nd if it's not an attribute\n\t// object) are interpreted as children of the DOM elements, and must\n\t// either be valid `DOMOutputSpec` values, or the number zero.\n\t//\n\t// The number zero (pronounced “hole”) is used to indicate the place\n\t// where a ProseMirror node's content should be inserted.\n\t\n\t// ::- A DOM serializer knows how to convert ProseMirror nodes and\n\t// marks of various types to DOM nodes.\n\tvar DOMSerializer = function(nodes, marks) {\n\t  // :: Object<(node: Node) → DOMOutputSpec>\n\t  this.nodes = nodes || {}\n\t  // :: Object<(mark: Mark) → DOMOutputSpec>\n\t  this.marks = marks || {}\n\t};\n\t\n\t// :: (Fragment, ?Object) → dom.DocumentFragment\n\t// Serialize the content of this fragment to a DOM fragment. When\n\t// not in the browser, the `document` option, containing a DOM\n\t// document, should be passed so that the serialize can create\n\t// nodes.\n\tDOMSerializer.prototype.serializeFragment = function (fragment, options, target) {\n\t    var this$1 = this;\n\t    if ( options === void 0 ) options = {};\n\t\n\t  if (!target) { target = doc(options).createDocumentFragment() }\n\t\n\t  var top = target, active = null\n\t  fragment.forEach(function (node) {\n\t    if (active || node.marks.length) {\n\t      if (!active) { active = [] }\n\t      var keep = 0\n\t      for (; keep < Math.min(active.length, node.marks.length); ++keep)\n\t        { if (!node.marks[keep].eq(active[keep])) { break } }\n\t      while (keep < active.length) {\n\t        active.pop()\n\t        top = top.parentNode\n\t      }\n\t      while (active.length < node.marks.length) {\n\t        var add = node.marks[active.length]\n\t        active.push(add)\n\t        top = top.appendChild(this$1.serializeMark(add, options))\n\t      }\n\t    }\n\t    top.appendChild(this$1.serializeNode(node, options))\n\t  })\n\t\n\t  return target\n\t};\n\t\n\t// :: (Node, ?Object) → dom.Node\n\t// Serialize this node to a DOM node. This can be useful when you\n\t// need to serialize a part of a document, as opposed to the whole\n\t// document. To serialize a whole document, use\n\t// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n\t// its [`content`](#model.Node.content).\n\tDOMSerializer.prototype.serializeNode = function (node, options) {\n\t    if ( options === void 0 ) options = {};\n\t\n\t  return this.renderStructure(this.nodes[node.type.name](node), node, options)\n\t};\n\t\n\tDOMSerializer.prototype.serializeNodeAndMarks = function (node, options) {\n\t    var this$1 = this;\n\t    if ( options === void 0 ) options = {};\n\t\n\t  var dom = this.serializeNode(node, options)\n\t  for (var i = node.marks.length - 1; i >= 0; i--) {\n\t    var wrap = this$1.serializeMark(node.marks[i], options)\n\t    wrap.appendChild(dom)\n\t    dom = wrap\n\t  }\n\t  return dom\n\t};\n\t\n\tDOMSerializer.prototype.serializeMark = function (mark, options) {\n\t    if ( options === void 0 ) options = {};\n\t\n\t  return this.renderStructure(this.marks[mark.type.name](mark), null, options)\n\t};\n\t\n\t// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n\t// Render an [output spec](##model.DOMOutputSpec).\n\tDOMSerializer.renderSpec = function (doc, structure) {\n\t  if (typeof structure == \"string\")\n\t    { return {dom: doc.createTextNode(structure)} }\n\t  if (structure.nodeType != null)\n\t    { return {dom: structure} }\n\t  var dom = doc.createElement(structure[0]), contentDOM = null\n\t  var attrs = structure[1], start = 1\n\t  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n\t    start = 2\n\t    for (var name in attrs) {\n\t      if (name == \"style\") { dom.style.cssText = attrs[name] }\n\t      else if (attrs[name] != null) { dom.setAttribute(name, attrs[name]) }\n\t    }\n\t  }\n\t  for (var i = start; i < structure.length; i++) {\n\t    var child = structure[i]\n\t    if (child === 0) {\n\t      if (i < structure.length - 1 || i > start)\n\t        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n\t      return {dom: dom, contentDOM: dom}\n\t    } else {\n\t      var ref = DOMSerializer.renderSpec(doc, child);\n\t        var inner = ref.dom;\n\t        var innerContent = ref.contentDOM;\n\t      dom.appendChild(inner)\n\t      if (innerContent) {\n\t        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n\t        contentDOM = innerContent\n\t      }\n\t    }\n\t  }\n\t  return {dom: dom, contentDOM: contentDOM}\n\t};\n\t\n\tDOMSerializer.prototype.renderStructure = function (structure, node, options) {\n\t  var ref = DOMSerializer.renderSpec(doc(options), structure);\n\t    var dom = ref.dom;\n\t    var contentDOM = ref.contentDOM;\n\t  if (node && !node.isLeaf) {\n\t    if (!contentDOM) { throw new RangeError(\"No content hole in template for non-leaf node\") }\n\t    if (options.onContent)\n\t      { options.onContent(node, contentDOM, options) }\n\t    else\n\t      { this.serializeFragment(node.content, options, contentDOM) }\n\t  } else if (contentDOM) {\n\t    throw new RangeError(\"Content hole not allowed in a mark or leaf node spec\")\n\t  }\n\t  return dom\n\t};\n\t\n\t// :: (Schema) → DOMSerializer\n\t// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n\t// properties in a schema's node and mark specs.\n\tDOMSerializer.fromSchema = function (schema) {\n\t  return schema.cached.domSerializer ||\n\t    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n\t};\n\t\n\t// :: (Schema) → Object<(node: Node) → DOMOutputSpec>\n\t// Gather the serializers in a schema's node specs into an object.\n\t// This can be useful as a base to build a custom serializer from.\n\tDOMSerializer.nodesFromSchema = function (schema) {\n\t  return gatherToDOM(schema.nodes)\n\t};\n\t\n\t// :: (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n\t// Gather the serializers in a schema's mark specs into an object.\n\tDOMSerializer.marksFromSchema = function (schema) {\n\t  return gatherToDOM(schema.marks)\n\t};\n\texports.DOMSerializer = DOMSerializer\n\t\n\tfunction gatherToDOM(obj) {\n\t  var result = {}\n\t  for (var name in obj) {\n\t    var toDOM = obj[name].spec.toDOM\n\t    if (toDOM) { result[name] = toDOM }\n\t  }\n\t  return result\n\t}\n\t\n\tfunction doc(options) {\n\t  // declare global: window\n\t  return options.document || window.document\n\t}\n\n\n/***/ },\n/* 150 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Schema = ref.Schema;\n\t\n\t// :: Object\n\t//\n\t//   doc:: NodeSpec The top level document node.\n\t//\n\t//   paragraph:: NodeSpec A plain paragraph textblock.\n\t//\n\t//   blockquote:: NodeSpec A blockquote wrapping one or more blocks.\n\t//\n\t//   horizontal_rule:: NodeSpec A horizontal rule.\n\t//\n\t//   heading:: NodeSpec A heading textblock, with a `level`\n\t//   attribute that should hold the number 1 to 6.\n\t//\n\t//   code_block:: NodeSpec A code listing. Disallows marks or\n\t//   non-text inline nodes by default.\n\t//\n\t//   text:: NodeSpec The text node.\n\t//\n\t//   image:: NodeSpec An inline image node. Supports `src`, `alt`, and\n\t//   `href` attributes. The latter two default to the empty string.\n\t//\n\t//   hard_break:: NodeSpec A hard line break.\n\tvar nodes = {\n\t  doc: {\n\t    content: \"block+\"\n\t  },\n\t\n\t  paragraph: {\n\t    content: \"inline<_>*\",\n\t    group: \"block\",\n\t    parseDOM: [{tag: \"p\"}],\n\t    toDOM: function toDOM() { return [\"p\", 0] }\n\t  },\n\t\n\t  blockquote: {\n\t    content: \"block+\",\n\t    group: \"block\",\n\t    defining: true,\n\t    parseDOM: [{tag: \"blockquote\"}],\n\t    toDOM: function toDOM() { return [\"blockquote\", 0] }\n\t  },\n\t\n\t  horizontal_rule: {\n\t    group: \"block\",\n\t    parseDOM: [{tag: \"hr\"}],\n\t    toDOM: function toDOM() { return [\"hr\"] }\n\t  },\n\t\n\t  heading: {\n\t    attrs: {level: {default: 1}},\n\t    content: \"inline<_>*\",\n\t    group: \"block\",\n\t    defining: true,\n\t    parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n\t               {tag: \"h2\", attrs: {level: 2}},\n\t               {tag: \"h3\", attrs: {level: 3}},\n\t               {tag: \"h4\", attrs: {level: 4}},\n\t               {tag: \"h5\", attrs: {level: 5}},\n\t               {tag: \"h6\", attrs: {level: 6}}],\n\t    toDOM: function toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n\t  },\n\t\n\t  code_block: {\n\t    content: \"text*\",\n\t    group: \"block\",\n\t    code: true,\n\t    defining: true,\n\t    parseDOM: [{tag: \"pre\", preserveWhitespace: true}],\n\t    toDOM: function toDOM() { return [\"pre\", [\"code\", 0]] }\n\t  },\n\t\n\t  text: {\n\t    group: \"inline\",\n\t    toDOM: function toDOM(node) { return node.text }\n\t  },\n\t\n\t  image: {\n\t    inline: true,\n\t    attrs: {\n\t      src: {},\n\t      alt: {default: null},\n\t      title: {default: null}\n\t    },\n\t    group: \"inline\",\n\t    draggable: true,\n\t    parseDOM: [{tag: \"img[src]\", getAttrs: function getAttrs(dom) {\n\t      return {\n\t        src: dom.getAttribute(\"src\"),\n\t        title: dom.getAttribute(\"title\"),\n\t        alt: dom.getAttribute(\"alt\")\n\t      }\n\t    }}],\n\t    toDOM: function toDOM(node) { return [\"img\", node.attrs] }\n\t  },\n\t\n\t  hard_break: {\n\t    inline: true,\n\t    group: \"inline\",\n\t    selectable: false,\n\t    parseDOM: [{tag: \"br\"}],\n\t    toDOM: function toDOM() { return [\"br\"] }\n\t  }\n\t}\n\texports.nodes = nodes\n\t\n\t// :: Object\n\t//\n\t//  em:: MarkSpec An emphasis mark.\n\t//\n\t//  strong:: MarkSpec A strong mark.\n\t//\n\t//  link:: MarkSpec A link. Has `href` and `title` attributes.\n\t//  `title` defaults to the empty string.\n\t//\n\t//  code:: MarkSpec Code font mark.\n\tvar marks = {\n\t  em: {\n\t    parseDOM: [{tag: \"i\"}, {tag: \"em\"},\n\t               {style: \"font-style\", getAttrs: function (value) { return value == \"italic\" && null; }}],\n\t    toDOM: function toDOM() { return [\"em\"] }\n\t  },\n\t\n\t  strong: {\n\t    parseDOM: [{tag: \"strong\"},\n\t               // This works around a Google Docs misbehavior where\n\t               // pasted content will be inexplicably wrapped in `<b>`\n\t               // tags with a font-weight normal.\n\t               {tag: \"b\", getAttrs: function (node) { return node.style.fontWeight != \"normal\" && null; }},\n\t               {style: \"font-weight\", getAttrs: function (value) { return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null; }}],\n\t    toDOM: function toDOM() { return [\"strong\"] }\n\t  },\n\t\n\t  link: {\n\t    attrs: {\n\t      href: {},\n\t      title: {default: null}\n\t    },\n\t    parseDOM: [{tag: \"a[href]\", getAttrs: function getAttrs(dom) {\n\t      return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n\t    }}],\n\t    toDOM: function toDOM(node) { return [\"a\", node.attrs] }\n\t  },\n\t\n\t  code: {\n\t    parseDOM: [{tag: \"code\"}],\n\t    toDOM: function toDOM() { return [\"code\"] }\n\t  }\n\t}\n\texports.marks = marks\n\t\n\t// :: Schema\n\t// This schema rougly corresponds to the document schema used by\n\t// CommonMark, minus the list elements, which are defined in the\n\t// [schema-list](#schema-list) module.\n\t//\n\t// To reuse elements from this schema, extend or read from its\n\t// [`nodeSpec`](#model.Schema.nodeSpec) and\n\t// [`markSpec`](#model.Schema.markSpec) properties.\n\tvar schema = new Schema({nodes: nodes, marks: marks})\n\texports.schema = schema\n\n\n/***/ },\n/* 151 */\n/***/ function(module, exports) {\n\n\t// ::- Plugins wrap extra functionality that can be added to an\n\t// editor. They can define new [state fields](#state.StateField), and\n\t// add [view props](#view.EditorProps).\n\tvar Plugin = function Plugin(options) {\n\t  var this$1 = this;\n\t\n\t  // :: EditorProps\n\t  // The props exported by this plugin.\n\t  this.props = {}\n\t  if (options.props) { for (var prop in options.props) {\n\t    var val = options.props[prop]\n\t    if (val instanceof Function) { val = val.bind(this$1) }\n\t    this$1.props[prop] = val\n\t  } }\n\t  // :: Object\n\t  // The plugin's configuration object.\n\t  this.options = options\n\t  this.key = options.key ? options.key.key : createKey(\"plugin\")\n\t};\n\t\n\t// :: (EditorState) → any\n\t// Get the state field for this plugin.\n\tPlugin.prototype.getState = function getState (state) { return state[this.key] };\n\texports.Plugin = Plugin\n\t\n\t// StateField:: interface<T>\n\t// A plugin may provide a state field (under its `state` property) of\n\t// this type, which describes the state it wants to keep. Functions\n\t// provided here are always called with the plugin instance as their\n\t// `this` binding.\n\t//\n\t//   init:: (config: Object, instance: EditorState) → T\n\t//   Initialize the value of this field. `config` will be the object\n\t//   passed to [`EditorState.create`](#state.EditorState^create). Note\n\t//   that `instance` is a half-initialized state instance, and will\n\t//   not have values for any fields initialzed after this one.\n\t//\n\t//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n\t//   Apply the given transaction to this state field, producing a new\n\t//   field value. Note that the `newState` argument is a partially\n\t//   constructed state does not yet contain the state from plugins\n\t//   coming after this plugin.\n\t//\n\t//   toJSON:: ?(value: T) → *\n\t//   Convert this field to JSON. Optional, can be left off to disable\n\t//   JSON serialization for the field.\n\t//\n\t//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n\t//   Deserialize the JSON representation of this field. Note that the\n\t//   `state` argument is again a half-initialized state.\n\t\n\tvar keys = Object.create(null)\n\t\n\tfunction createKey(name) {\n\t  if (name in keys) { return name + \"$\" + ++keys[name] }\n\t  keys[name] = 0\n\t  return name + \"$\"\n\t}\n\t\n\t// ::- A key is used to [tag](#state.Plugin.constructor^options.key)\n\t// plugins in a way that makes it possible to find them, given an\n\t// editor state. Assigning a key does mean only one plugin of that\n\t// type can be active in a state.\n\tvar PluginKey = function PluginKey(name) {\n\tif ( name === void 0 ) name = \"key\";\n\t this.key = createKey(name) };\n\t\n\t// :: (EditorState) → ?Plugin\n\t// Get the active plugin with this key, if any, from an editor\n\t// state.\n\tPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\t\n\t// :: (EditorState) → ?any\n\t// Get the plugin's state from an editor state.\n\tPluginKey.prototype.getState = function getState (state) { return state[this.key] };\n\texports.PluginKey = PluginKey\n\n\n/***/ },\n/* 152 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Node = ref.Node;\n\t\n\tvar ref$1 = __webpack_require__(32);\n\tvar Selection = ref$1.Selection;\n\tvar ref$2 = __webpack_require__(56);\n\tvar Transaction = ref$2.Transaction;\n\t\n\tfunction bind(f, self) {\n\t  return !self || !f ? f : f.bind(self)\n\t}\n\t\n\tvar FieldDesc = function FieldDesc(name, desc, self) {\n\t  this.name = name\n\t  this.init = bind(desc.init, self)\n\t  this.apply = bind(desc.apply, self)\n\t};\n\t\n\tvar baseFields = [\n\t  new FieldDesc(\"doc\", {\n\t    init: function init(config) { return config.doc || config.schema.nodes.doc.createAndFill() },\n\t    apply: function apply(tr) { return tr.doc }\n\t  }),\n\t\n\t  new FieldDesc(\"selection\", {\n\t    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n\t    apply: function apply(tr) { return tr.selection }\n\t  }),\n\t\n\t  new FieldDesc(\"storedMarks\", {\n\t    init: function init() { return null },\n\t    apply: function apply(tr, _marks, _old, state) { return state.selection.empty ? tr.storedMarks : null }\n\t  }),\n\t\n\t  new FieldDesc(\"scrollToSelection\", {\n\t    init: function init() { return 0 },\n\t    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n\t  })\n\t]\n\t\n\t// Object wrapping the part of a state object that stays the same\n\t// across transactions. Stored in the state's `config` property.\n\tvar Configuration = function Configuration(schema, plugins) {\n\t  var this$1 = this;\n\t\n\t  this.schema = schema\n\t  this.fields = baseFields.concat()\n\t  this.plugins = []\n\t  this.pluginsByKey = Object.create(null)\n\t  if (plugins) { plugins.forEach(function (plugin) {\n\t    if (this$1.pluginsByKey[plugin.key])\n\t      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n\t    this$1.plugins.push(plugin)\n\t    this$1.pluginsByKey[plugin.key] = plugin\n\t    if (plugin.options.state)\n\t      { this$1.fields.push(new FieldDesc(plugin.key, plugin.options.state, plugin)) }\n\t  }) }\n\t};\n\t\n\t// ::- The state of a ProseMirror editor is represented by an object\n\t// of this type. This is a persistent data structure—it isn't updated,\n\t// but rather a new state value is computed from an old one with the\n\t// [`apply`](#state.EditorState.apply) method.\n\t//\n\t// In addition to the built-in state fields, plugins can define\n\t// additional pieces of state.\n\tvar EditorState = function EditorState(config) {\n\t  this.config = config\n\t};\n\t\n\tvar prototypeAccessors = { schema: {},plugins: {},tr: {} };\n\t\n\t// doc:: Node\n\t// The current document.\n\t\n\t// selection:: Selection\n\t// The selection.\n\t\n\t// storedMarks:: ?[Mark]\n\t// A set of marks to apply to the next character that's typed. Will\n\t// be null whenever no explicit marks have been set.\n\t\n\t// :: Schema\n\t// The schema of the state's document.\n\tprototypeAccessors.schema.get = function () {\n\t  return this.config.schema\n\t};\n\t\n\t// :: [Plugin]\n\t// The plugins that are active in this state.\n\tprototypeAccessors.plugins.get = function () {\n\t  return this.config.plugins\n\t};\n\t\n\t// :: (Transaction) → EditorState\n\t// Apply the given transaction to produce a new state.\n\tEditorState.prototype.apply = function apply (tr) {\n\t  return this.applyTransaction(tr).state\n\t};\n\t\n\t// : (Transaction) → ?Transaction\n\tEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n\t    var this$1 = this;\n\t    if ( ignore === void 0 ) ignore = -1;\n\t\n\t  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n\t    var plugin = this$1.config.plugins[i]\n\t    if (plugin.options.filterTransaction && !plugin.options.filterTransaction.call(plugin, tr, this$1))\n\t      { return false }\n\t  } }\n\t  return true\n\t};\n\t\n\t// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n\t// Verbose variant of [`apply`](##state.EditorState.apply) that\n\t// returns the precise transactions that were applied (which might\n\t// be influenced by the [transaction\n\t// hooks](##state.Plugin.constructor^options.filterTransaction) of\n\t// plugins) along with the new state.\n\tEditorState.prototype.applyTransaction = function applyTransaction (tr) {\n\t    var this$1 = this;\n\t\n\t  if (!this.filterTransaction(tr)) { return {state: this, transactions: []} }\n\t\n\t  var trs = [tr], newState = this.applyInner(tr), seen = null\n\t  // This loop repeatedly gives plugins a chance to respond to\n\t  // transactions as new transactions are added, making sure to only\n\t  // pass the transactions the plugin did not see before.\n\t  outer: for (;;) {\n\t    var haveNew = false\n\t    for (var i = 0; i < this.config.plugins.length; i++) {\n\t      var plugin = this$1.config.plugins[i]\n\t      if (plugin.options.appendTransaction) {\n\t        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this$1\n\t        var tr$1 = n < trs.length &&\n\t            plugin.options.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n\t        if (tr$1 && newState.filterTransaction(tr$1, i)) {\n\t          if (!seen) {\n\t            seen = []\n\t            for (var j = 0; j < this.config.plugins.length; j++)\n\t              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this$1, n: 0}) }\n\t          }\n\t          trs.push(tr$1)\n\t          newState = newState.applyInner(tr$1)\n\t          haveNew = true\n\t        }\n\t        if (seen) { seen[i] = {state: newState, n: trs.length} }\n\t      }\n\t    }\n\t    if (!haveNew) { return {state: newState, transactions: trs} }\n\t  }\n\t};\n\t\n\t// : (Transaction) → EditorState\n\tEditorState.prototype.applyInner = function applyInner (tr) {\n\t    var this$1 = this;\n\t\n\t  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n\t  var newInstance = new EditorState(this.config), fields = this.config.fields\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i]\n\t    newInstance[field.name] = field.apply(tr, this$1[field.name], this$1, newInstance)\n\t  }\n\t  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this$1, tr, newInstance) }\n\t  return newInstance\n\t};\n\t\n\t// :: Transaction\n\t// Start a [transaction](#state.Transaction) from this state.\n\tprototypeAccessors.tr.get = function () { return new Transaction(this) };\n\t\n\t// :: (Object) → EditorState\n\t// Create a state. `config` must be an object containing at least a\n\t// `schema` (the schema to use) or `doc` (the starting document)\n\t// property. When it has a `selection` property, that should be a\n\t// valid [selection](#state.Selection) in the given document, to use\n\t// as starting selection. Plugins, which are specified as an array\n\t// in the `plugins` property, may read additional fields from the\n\t// config object.\n\tEditorState.create = function create (config) {\n\t  var $config = new Configuration(config.schema || config.doc.type.schema, config.plugins)\n\t  var instance = new EditorState($config)\n\t  for (var i = 0; i < $config.fields.length; i++)\n\t    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance) }\n\t  return instance\n\t};\n\t\n\t// :: (Object) → EditorState\n\t// Create a new state based on this one, but with an adjusted set of\n\t// active plugins. State fields that exist in both sets of plugins\n\t// are kept unchanged. Those that no longer exist are dropped, and\n\t// those that are new are initialized using their\n\t// [`init`](#state.StateField.init) method, passing in the new\n\t// configuration object..\n\tEditorState.prototype.reconfigure = function reconfigure (config) {\n\t    var this$1 = this;\n\t\n\t  var $config = new Configuration(config.schema || this.schema, config.plugins)\n\t  var fields = $config.fields, instance = new EditorState($config)\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var name = fields[i].name\n\t    instance[name] = this$1.hasOwnProperty(name) ? this$1[name] : fields[i].init(config, instance)\n\t  }\n\t  return instance\n\t};\n\t\n\t// :: (?Object<Plugin>) → Object\n\t// Serialize this state to JSON. If you want to serialize the state\n\t// of plugins, pass an object mapping property names to use in the\n\t// resulting JSON object to plugin objects.\n\tEditorState.prototype.toJSON = function toJSON (pluginFields) {\n\t    var this$1 = this;\n\t\n\t  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n\t  if (pluginFields) { for (var prop in pluginFields) {\n\t    if (prop == \"doc\" || prop == \"selection\")\n\t      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n\t    var plugin = pluginFields[prop], state = plugin.options.state\n\t    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this$1[plugin.key]) }\n\t  } }\n\t  return result\n\t};\n\t\n\t// :: (Object, Object, ?Object<Plugin>) → EditorState\n\t// Deserialize a JSON representation of a state. `config` should\n\t// have at least a `schema` field, and should contain array of\n\t// plugins to initialize the state with. `pluginFields` can be used\n\t// to deserialize the state of plugins, by associating plugin\n\t// instances with the property names they use in the JSON object.\n\tEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n\t  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n\t  var $config = new Configuration(config.schema, config.plugins)\n\t  var instance = new EditorState($config)\n\t  $config.fields.forEach(function (field) {\n\t    if (field.name == \"doc\") {\n\t      instance.doc = Node.fromJSON(config.schema, json.doc)\n\t    } else if (field.name == \"selection\") {\n\t      instance.selection = Selection.fromJSON(instance.doc, json.selection)\n\t    } else {\n\t      if (pluginFields) { for (var prop in pluginFields) {\n\t        var plugin = pluginFields[prop], state = plugin.options.state\n\t        if (plugin.key == field.name && state && state.fromJSON &&\n\t            Object.prototype.hasOwnProperty.call(json, prop)) {\n\t          // This field belongs to a plugin mapped to a JSON field, read it from there.\n\t          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n\t          return\n\t        }\n\t      } }\n\t      instance[field.name] = field.init(config, instance)\n\t    }\n\t  })\n\t  return instance\n\t};\n\t\n\t// Kludge to allow the view to track mappings between different\n\t// instances of a state.\n\tEditorState.addApplyListener = function addApplyListener (f) {\n\t  applyListeners.push(f)\n\t};\n\tEditorState.removeApplyListener = function removeApplyListener (f) {\n\t  var found = applyListeners.indexOf(f)\n\t  if (found > -1) { applyListeners.splice(found, 1) }\n\t};\n\t\n\tObject.defineProperties( EditorState.prototype, prototypeAccessors );\n\texports.EditorState = EditorState\n\t\n\tvar applyListeners = []\n\n\n/***/ },\n/* 153 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar MarkType = ref.MarkType;\n\tvar Slice = ref.Slice;\n\tvar Fragment = ref.Fragment;\n\t\n\tvar ref$1 = __webpack_require__(17);\n\tvar Transform = ref$1.Transform;\n\tvar ref$2 = __webpack_require__(57);\n\tvar AddMarkStep = ref$2.AddMarkStep;\n\tvar RemoveMarkStep = ref$2.RemoveMarkStep;\n\tvar ref$3 = __webpack_require__(16);\n\tvar ReplaceStep = ref$3.ReplaceStep;\n\t\n\t// :: (number, number, Mark) → Transform\n\t// Add the given mark to the inline content between `from` and `to`.\n\tTransform.prototype.addMark = function(from, to, mark) {\n\t  var this$1 = this;\n\t\n\t  var removed = [], added = [], removing = null, adding = null\n\t  this.doc.nodesBetween(from, to, function (node, pos, parent, index) {\n\t    if (!node.isInline) { return }\n\t    var marks = node.marks\n\t    if (mark.isInSet(marks) || !parent.contentMatchAt(index + 1).allowsMark(mark.type)) {\n\t      adding = removing = null\n\t    } else {\n\t      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n\t      var rm = mark.type.isInSet(marks)\n\t\n\t      if (!rm)\n\t        { removing = null }\n\t      else if (removing && removing.mark.eq(rm))\n\t        { removing.to = end }\n\t      else\n\t        { removed.push(removing = new RemoveMarkStep(start, end, rm)) }\n\t\n\t      if (adding)\n\t        { adding.to = end }\n\t      else\n\t        { added.push(adding = new AddMarkStep(start, end, mark)) }\n\t    }\n\t  })\n\t\n\t  removed.forEach(function (s) { return this$1.step(s); })\n\t  added.forEach(function (s) { return this$1.step(s); })\n\t  return this\n\t}\n\t\n\t// :: (number, number, ?union<Mark, MarkType>) → Transform\n\t// Remove the given mark, or all marks of the given type, from inline\n\t// nodes between `from` and `to`.\n\tTransform.prototype.removeMark = function(from, to, mark) {\n\t  var this$1 = this;\n\t  if ( mark === void 0 ) mark = null;\n\t\n\t  var matched = [], step = 0\n\t  this.doc.nodesBetween(from, to, function (node, pos) {\n\t    if (!node.isInline) { return }\n\t    step++\n\t    var toRemove = null\n\t    if (mark instanceof MarkType) {\n\t      var found = mark.isInSet(node.marks)\n\t      if (found) { toRemove = [found] }\n\t    } else if (mark) {\n\t      if (mark.isInSet(node.marks)) { toRemove = [mark] }\n\t    } else {\n\t      toRemove = node.marks\n\t    }\n\t    if (toRemove && toRemove.length) {\n\t      var end = Math.min(pos + node.nodeSize, to)\n\t      for (var i = 0; i < toRemove.length; i++) {\n\t        var style = toRemove[i], found$1 = (void 0)\n\t        for (var j = 0; j < matched.length; j++) {\n\t          var m = matched[j]\n\t          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m }\n\t        }\n\t        if (found$1) {\n\t          found$1.to = end\n\t          found$1.step = step\n\t        } else {\n\t          matched.push({style: style, from: Math.max(pos, from), to: end, step: step})\n\t        }\n\t      }\n\t    }\n\t  })\n\t  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); })\n\t  return this\n\t}\n\t\n\t// :: (number, number) → Transform\n\t// Remove all marks and non-text inline nodes from the given range.\n\tTransform.prototype.clearMarkup = function(from, to) {\n\t  var this$1 = this;\n\t\n\t  var delSteps = [] // Must be accumulated and applied in inverse order\n\t  this.doc.nodesBetween(from, to, function (node, pos) {\n\t    if (!node.isInline) { return }\n\t    if (!node.type.isText) {\n\t      delSteps.push(new ReplaceStep(pos, pos + node.nodeSize, Slice.empty))\n\t      return\n\t    }\n\t    for (var i = 0; i < node.marks.length; i++)\n\t      { this$1.step(new RemoveMarkStep(Math.max(pos, from), Math.min(pos + node.nodeSize, to), node.marks[i])) }\n\t  })\n\t  for (var i = delSteps.length - 1; i >= 0; i--) { this$1.step(delSteps[i]) }\n\t  return this\n\t}\n\t\n\tTransform.prototype.clearNonMatching = function(pos, match) {\n\t  var this$1 = this;\n\t\n\t  var node = this.doc.nodeAt(pos)\n\t  var delSteps = [], cur = pos + 1\n\t  for (var i = 0; i < node.childCount; i++) {\n\t    var child = node.child(i), end = cur + child.nodeSize\n\t    var allowed = match.matchType(child.type, child.attrs)\n\t    if (!allowed) {\n\t      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n\t    } else {\n\t      match = allowed\n\t      for (var j = 0; j < child.marks.length; j++) { if (!match.allowsMark(child.marks[j]))\n\t        { this$1.step(new RemoveMarkStep(cur, end, child.marks[j])) } }\n\t    }\n\t    cur = end\n\t  }\n\t  if (!match.validEnd()) {\n\t    var fill = match.fillBefore(Fragment.empty, true)\n\t    this.replace(cur, cur, new Slice(fill, 0, 0))\n\t  }\n\t  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this$1.step(delSteps[i$1]) }\n\t  return this\n\t}\n\n\n/***/ },\n/* 154 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Fragment = ref.Fragment;\n\tvar Slice = ref.Slice;\n\t\n\tvar ref$1 = __webpack_require__(16);\n\tvar ReplaceStep = ref$1.ReplaceStep;\n\tvar ReplaceAroundStep = ref$1.ReplaceAroundStep;\n\tvar ref$2 = __webpack_require__(17);\n\tvar Transform = ref$2.Transform;\n\tvar ref$3 = __webpack_require__(58);\n\tvar insertPoint = ref$3.insertPoint;\n\t\n\t// :: (number, number, Slice) → Transform\n\t// Replace a range of the document with a given slice, using `from`,\n\t// `to`, and the slice's [`openLeft`](#model.Slice.openLeft) property\n\t// as hints, rather than fixed start and end points. This method may\n\t// grow the replaced area or close open nodes in the slice in order to\n\t// get a fit that is more in line with WYSIWYG expectations, by\n\t// dropping fully covered parent nodes of the replaced region when\n\t// they are marked [non-defining](#model.NodeSpec.defining), or\n\t// including an open parent node from the slice that _is_ marked as\n\t// [defining](#model.NodeSpec.defining).\n\t//\n\t// This is the method, for example, to handle paste. The similar\n\t// [`replace`](#transform.Transform.replace) method is a more\n\t// primitive tool which will _not_ move the start and end of its given\n\t// range, and is useful in situations where you need more precise\n\t// control over what happens.\n\tTransform.prototype.replaceRange = function(from, to, slice) {\n\t  var this$1 = this;\n\t\n\t  if (!slice.size) { return this.deleteRange(from, to) }\n\t\n\t  var $from = this.doc.resolve(from)\n\t  if (fitsTrivially($from, this.doc.resolve(to), slice))\n\t    { return this.step(new ReplaceStep(from, to, slice)) }\n\t\n\t  var canExpand = coveredDepths($from, this.doc.resolve(to)), preferredExpand = 0\n\t  canExpand.unshift($from.depth + 1)\n\t  for (var d = $from.depth; d > 0; d--) {\n\t    if ($from.node(d).type.spec.defining) { break }\n\t    var found = canExpand.indexOf(d, 1)\n\t    if (found > -1) { preferredExpand = found }\n\t  }\n\t\n\t  var leftNodes = [], preferredDepth = slice.openLeft\n\t  for (var content = slice.content, i = 0;; i++) {\n\t    var node = content.firstChild\n\t    leftNodes.push(node)\n\t    if (i == slice.openLeft) { break }\n\t    content = node.content\n\t  }\n\t  // Back up if the node directly above openLeft, or the node above\n\t  // that separated only by a non-defining textblock node, is defining.\n\t  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining)\n\t    { preferredDepth -= 1 }\n\t  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining)\n\t    { preferredDepth -= 2 }\n\t\n\t  for (var j = slice.openLeft; j >= 0; j--) {\n\t    var openDepth = (j + preferredDepth + 1) % (slice.openLeft + 1)\n\t    var insert = leftNodes[openDepth]\n\t    if (!insert) { continue }\n\t    for (var i$1 = 0; i$1 < canExpand.length; i$1++) {\n\t      // Loop over possible expansion levels, starting with the\n\t      // preferred one\n\t      var expandDepth = canExpand[(i$1 + preferredExpand) % canExpand.length]\n\t      var parent = $from.node(expandDepth - 1), index = $from.index(expandDepth - 1)\n\t      if (parent.canReplaceWith(index, index, insert.type, insert.attrs, insert.marks))\n\t        { return this$1.replace($from.before(expandDepth), expandDepth > $from.depth ? to : $from.after(expandDepth),\n\t                            new Slice(closeFragment(slice.content, 0, slice.openLeft, openDepth),\n\t                                      openDepth, slice.openRight)) }\n\t    }\n\t  }\n\t\n\t  return this.replace(from, to, slice)\n\t}\n\t\n\tfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n\t  if (depth < oldOpen) {\n\t    var first = fragment.firstChild\n\t    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n\t  }\n\t  if (depth > newOpen)\n\t    { fragment = parent.contentMatchAt(0).fillBefore(fragment).append(fragment) }\n\t  return fragment\n\t}\n\t\n\t// :: (number, number, Node) → Transform\n\t// Replace the given range with a node, but use `from` and `to` as\n\t// hints, rather than precise positions. When from and to are the same\n\t// and are at the start or end of a parent node in which the given\n\t// node doesn't fit, this method may _move_ them out towards a parent\n\t// that does allow the given node to be placed. When the given range\n\t// completely covers a parent node, this method may completely replace\n\t// that parent node.\n\tTransform.prototype.replaceRangeWith = function(from, to, node) {\n\t  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n\t    var point = insertPoint(this.doc, from, node.type, node.attrs)\n\t    if (point != null) { from = to = point }\n\t  }\n\t  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n\t}\n\t\n\t// :: (number, number) → Transform\n\t// Delete the given range, and any fully covered parent nodes that are\n\t// not allowed to be empty.\n\tTransform.prototype.deleteRange = function(from, to) {\n\t  var $from = this.doc.resolve(from)\n\t  var covered = coveredDepths($from, this.doc.resolve(to)), grown = false\n\t  // Find the innermost covered node that allows its whole content to\n\t  // be deleted\n\t  for (var i = 0; i < covered.length; i++) {\n\t    if ($from.node(covered[i]).contentMatchAt(0).validEnd()) {\n\t      from = $from.start(covered[i])\n\t      to = $from.end(covered[i])\n\t      grown = true\n\t      break\n\t    }\n\t  }\n\t  // If no such node was found and the outermose covered node can be\n\t  // deleted entirely, do that\n\t  if (!grown && covered.length) {\n\t    var depth = covered[covered.length - 1]\n\t    if ($from.node(depth - 1).canReplace($from.index(depth - 1), $from.indexAfter(depth - 1))) {\n\t      from = $from.before(depth)\n\t      to = $from.after(depth)\n\t    }\n\t  }\n\t  return this.delete(from, to)\n\t}\n\t\n\t// : (ResolvedPos, ResolvedPos) → [number]\n\t// Returns an array of all depths for which $from - $to spans the\n\t// whole content of the node at that depth.\n\tfunction coveredDepths($from, $to) {\n\t  var result = []\n\t  for (var i = 0; i < $from.depth; i++) {\n\t    var depth = $from.depth - i\n\t    if ($from.pos - i > $from.start(depth)) { break }\n\t    if ($to.depth >= depth && $to.pos + ($to.depth - depth) == $from.end(depth)) { result.push(depth) }\n\t  }\n\t  return result\n\t}\n\t\n\t// :: (number, number) → Transform\n\t// Delete the content between the given positions.\n\tTransform.prototype.delete = function(from, to) {\n\t  return this.replace(from, to, Slice.empty)\n\t}\n\t\n\t// :: (Node, number, ?number, ?Slice) → ?Step\n\t// \"Fit\" a slice into a given position in the document, producing a\n\t// [step](#transform.Step) that inserts it.\n\tfunction replaceStep(doc, from, to, slice) {\n\t  if ( to === void 0 ) to = from;\n\t  if ( slice === void 0 ) slice = Slice.empty;\n\t\n\t  if (from == to && !slice.size) { return null }\n\t\n\t  var $from = doc.resolve(from), $to = doc.resolve(to)\n\t  // Optimization -- avoid work if it's obvious that it's not needed.\n\t  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n\t  var placed = placeSlice($from, slice)\n\t\n\t  var fittedLeft = fitLeft($from, placed)\n\t  var fitted = fitRight($from, $to, fittedLeft)\n\t  if (!fitted) { return null }\n\t  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {\n\t    var d = $to.depth, after = $to.after(d)\n\t    while (d > 1 && after == $to.end(--d)) { ++after }\n\t    var fittedAfter = fitRight($from, doc.resolve(after), fittedLeft)\n\t    if (fittedAfter)\n\t      { return new ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size) }\n\t  }\n\t  return new ReplaceStep(from, to, fitted)\n\t}\n\texports.replaceStep = replaceStep\n\t\n\t// :: (number, ?number, ?Slice) → Transform\n\t// Replace the part of the document between `from` and `to` with the\n\t// given `slice`.\n\tTransform.prototype.replace = function(from, to, slice) {\n\t  if ( to === void 0 ) to = from;\n\t  if ( slice === void 0 ) slice = Slice.empty;\n\t\n\t  var step = replaceStep(this.doc, from, to, slice)\n\t  if (step) { this.step(step) }\n\t  return this\n\t}\n\t\n\t// :: (number, number, union<Fragment, Node, [Node]>) → Transform\n\t// Replace the given range with the given content, which may be a\n\t// fragment, node, or array of nodes.\n\tTransform.prototype.replaceWith = function(from, to, content) {\n\t  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n\t}\n\t\n\t// :: (number, union<Fragment, Node, [Node]>) → Transform\n\t// Insert the given content at the given position.\n\tTransform.prototype.insert = function(pos, content) {\n\t  return this.replaceWith(pos, pos, content)\n\t}\n\t\n\t\n\t\n\tfunction fitLeftInner($from, depth, placed, placedBelow) {\n\t  var content = Fragment.empty, openRight = 0, placedHere = placed[depth]\n\t  if ($from.depth > depth) {\n\t    var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere)\n\t    openRight = inner.openRight + 1\n\t    content = Fragment.from($from.node(depth + 1).copy(inner.content))\n\t  }\n\t\n\t  if (placedHere) {\n\t    content = content.append(placedHere.content)\n\t    openRight = placedHere.openRight\n\t  }\n\t  if (placedBelow) {\n\t    content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(Fragment.empty, true))\n\t    openRight = 0\n\t  }\n\t\n\t  return {content: content, openRight: openRight}\n\t}\n\t\n\tfunction fitLeft($from, placed) {\n\t  var ref = fitLeftInner($from, 0, placed, false);\n\t  var content = ref.content;\n\t  var openRight = ref.openRight;\n\t  return new Slice(content, $from.depth, openRight || 0)\n\t}\n\t\n\tfunction fitRightJoin(content, parent, $from, $to, depth, openLeft, openRight) {\n\t  var match, count = content.childCount, matchCount = count - (openRight > 0 ? 1 : 0)\n\t  if (openLeft < 0)\n\t    { match = parent.contentMatchAt(matchCount) }\n\t  else if (count == 1 && openRight > 0)\n\t    { match = $from.node(depth).contentMatchAt(openLeft ? $from.index(depth) : $from.indexAfter(depth)) }\n\t  else\n\t    { match = $from.node(depth).contentMatchAt($from.indexAfter(depth))\n\t      .matchFragment(content, count > 0 && openLeft ? 1 : 0, matchCount) }\n\t\n\t  var toNode = $to.node(depth)\n\t  if (openRight > 0 && depth < $to.depth) {\n\t    var after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild)\n\t    var joinable$1 = match.fillBefore(after, true)\n\t    // Can't insert content if there's a single node stretched across this gap\n\t    if (joinable$1 && joinable$1.size && openLeft > 0 && count == 1) { joinable$1 = null }\n\t\n\t    if (joinable$1) {\n\t      var inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to,\n\t                               depth + 1, count == 1 ? openLeft - 1 : -1, openRight - 1)\n\t      if (inner) {\n\t        var last = content.lastChild.copy(inner)\n\t        if (joinable$1.size)\n\t          { return content.cutByIndex(0, count - 1).append(joinable$1).addToEnd(last) }\n\t        else\n\t          { return content.replaceChild(count - 1, last) }\n\t      }\n\t    }\n\t  }\n\t  if (openRight > 0)\n\t    { match = match.matchNode(count == 1 && openLeft > 0 ? $from.node(depth + 1) : content.lastChild) }\n\t\n\t  // If we're here, the next level can't be joined, so we see what\n\t  // happens if we leave it open.\n\t  var toIndex = $to.index(depth)\n\t  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) { return null }\n\t  var joinable = match.fillBefore(toNode.content, true, toIndex)\n\t  if (!joinable) { return null }\n\t\n\t  if (openRight > 0) {\n\t    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1,\n\t                                count == 1 ? openLeft - 1 : -1)\n\t    content = content.replaceChild(count - 1, closed)\n\t  }\n\t  content = content.append(joinable)\n\t  if ($to.depth > depth)\n\t    { content = content.addToEnd(fitRightSeparate($to, depth + 1)) }\n\t  return content\n\t}\n\t\n\tfunction fitRightClosed(node, openRight, $from, depth, openLeft) {\n\t  var match, content = node.content, count = content.childCount\n\t  if (openLeft >= 0)\n\t    { match = $from.node(depth).contentMatchAt($from.indexAfter(depth))\n\t      .matchFragment(content, openLeft > 0 ? 1 : 0, count) }\n\t  else\n\t    { match = node.contentMatchAt(count) }\n\t\n\t  if (openRight > 0) {\n\t    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1,\n\t                                count == 1 ? openLeft - 1 : -1)\n\t    content = content.replaceChild(count - 1, closed)\n\t  }\n\t\n\t  return node.copy(content.append(match.fillBefore(Fragment.empty, true)))\n\t}\n\t\n\tfunction fitRightSeparate($to, depth) {\n\t  var node = $to.node(depth)\n\t  var fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth))\n\t  if ($to.depth > depth) { fill = fill.addToEnd(fitRightSeparate($to, depth + 1)) }\n\t  return node.copy(fill)\n\t}\n\t\n\tfunction normalizeSlice(content, openLeft, openRight) {\n\t  while (openLeft > 0 && openRight > 0 && content.childCount == 1) {\n\t    content = content.firstChild.content\n\t    openLeft--\n\t    openRight--\n\t  }\n\t  return new Slice(content, openLeft, openRight)\n\t}\n\t\n\t// : (ResolvedPos, ResolvedPos, number, Slice) → Slice\n\tfunction fitRight($from, $to, slice) {\n\t  var fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openLeft, slice.openRight)\n\t  if (!fitted) { return null }\n\t  return normalizeSlice(fitted, slice.openLeft, $to.depth)\n\t}\n\t\n\tfunction fitsTrivially($from, $to, slice) {\n\t  return !slice.openLeft && !slice.openRight && $from.start() == $to.start() &&\n\t    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n\t}\n\t\n\tfunction canMoveText($from, $to, slice) {\n\t  if (!$to.parent.isTextblock) { return false }\n\t\n\t  var match\n\t  if (!slice.openRight) {\n\t    var parent = $from.node($from.depth - (slice.openLeft - slice.openRight))\n\t    if (!parent.isTextblock) { return false }\n\t    match = parent.contentMatchAt(parent.childCount)\n\t    if (slice.size)\n\t      { match = match.matchFragment(slice.content, slice.openLeft ? 1 : 0) }\n\t  } else {\n\t    var parent$1 = nodeRight(slice.content, slice.openRight)\n\t    if (!parent$1.isTextblock) { return false }\n\t    match = parent$1.contentMatchAt(parent$1.childCount)\n\t  }\n\t  match = match.matchFragment($to.parent.content, $to.index())\n\t  return match && match.validEnd()\n\t}\n\t\n\t// Algorithm for 'placing' the elements of a slice into a gap:\n\t//\n\t// We consider the content of each node that is open to the left to be\n\t// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n\t// paragraph on the left is open, \"foo\" can be placed (somewhere on\n\t// the left side of the replacement gap) independently from p(\"bar\").\n\t//\n\t// So placeSlice splits up a slice into a number of sub-slices,\n\t// along with information on where they can be placed on the given\n\t// left-side edge. It works by walking the open side of the slice,\n\t// from the inside out, and trying to find a landing spot for each\n\t// element, by simultaneously scanning over the gap side. When no\n\t// place is found for an open node's content, it is left in that node.\n\t//\n\t// If the outer content can't be placed, a set of wrapper nodes is\n\t// made up for it (by rooting it in the document node type using\n\t// findWrapping), and the algorithm continues to iterate over those.\n\t// This is guaranteed to find a fit, since both stacks now start with\n\t// the same node type (doc).\n\t\n\tfunction nodeLeft(content, depth) {\n\t  for (var i = 1; i < depth; i++) { content = content.firstChild.content }\n\t  return content.firstChild\n\t}\n\t\n\tfunction nodeRight(content, depth) {\n\t  for (var i = 1; i < depth; i++) { content = content.lastChild.content }\n\t  return content.lastChild\n\t}\n\t\n\t// : (ResolvedPos, Slice) → [{content: Fragment, openRight: number, depth: number}]\n\tfunction placeSlice($from, slice) {\n\t  var dFrom = $from.depth, unplaced = null\n\t  var placed = [], parents = null\n\t\n\t  // Loop over the open side of the slice, trying to find a place for\n\t  // each open fragment.\n\t  for (var dSlice = slice.openLeft;; --dSlice) {\n\t    // Get the components of the node at this level\n\t    var curType = (void 0), curAttrs = (void 0), curFragment = (void 0)\n\t    if (dSlice >= 0) {\n\t      if (dSlice > 0) { // Inside slice\n\t        ;var assign;\n\t        ((assign = nodeLeft(slice.content, dSlice), curType = assign.type, curAttrs = assign.attrs, curFragment = assign.content))\n\t      } else if (dSlice == 0) { // Top of slice\n\t        curFragment = slice.content\n\t      }\n\t      if (dSlice < slice.openLeft) { curFragment = curFragment.cut(curFragment.firstChild.nodeSize) }\n\t    } else { // Outside slice, in generated wrappers (see below)\n\t      curFragment = Fragment.empty\n\t      var parent = parents[parents.length + dSlice - 1]\n\t      curType = parent.type\n\t      curAttrs = parent.attrs\n\t    }\n\t    // If the last iteration left unplaced content, include it in the fragment\n\t    if (unplaced) { curFragment = curFragment.addToStart(unplaced) }\n\t\n\t    // If there's nothing left to place, we're done\n\t    if (curFragment.size == 0 && dSlice <= 0) { break }\n\t\n\t    // This will go through the positions in $from, down from dFrom,\n\t    // to find a fit\n\t    var found = findPlacement(curFragment, $from, dFrom, placed)\n\t    if (found) {\n\t      // If there was a fit, store it, and consider this content placed\n\t      if (found.fragment.size > 0) { placed[found.depth] = {\n\t        content: found.fragment,\n\t        openRight: endOfContent(slice, dSlice) ? slice.openRight - dSlice : 0,\n\t        depth: found.depth\n\t      } }\n\t      // If that was the last of the content, we're done\n\t      if (dSlice <= 0) { break }\n\t      unplaced = null\n\t      dFrom = found.depth - (curType == $from.node(found.depth).type ? 1 : 0)\n\t    } else {\n\t      if (dSlice == 0) {\n\t        // This is the top of the slice, and we haven't found a place to insert it.\n\t        var top = $from.node(0)\n\t        // Try to find a wrapping that makes its first child fit in the top node.\n\t        var wrap = top.contentMatchAt($from.index(0)).findWrappingFor(curFragment.firstChild)\n\t        // If no such thing exists, give up.\n\t        if (!wrap || wrap.length == 0) { break }\n\t        var last = wrap[wrap.length - 1]\n\t        // Check that the fragment actually fits in the wrapping.\n\t        if (!last.type.contentExpr.matches(last.attrs, curFragment)) { break }\n\t        // Store the result for subsequent iterations.\n\t        parents = [{type: top.type, attrs: top.attrs}].concat(wrap)\n\t        ;var assign$1;\n\t        ((assign$1 = last, curType = assign$1.type, curAttrs = assign$1.attrs))\n\t      }\n\t      if (curFragment.size) {\n\t        curFragment = curType.contentExpr.start(curAttrs).fillBefore(curFragment, true).append(curFragment)\n\t        unplaced = curType.create(curAttrs, curFragment)\n\t      } else {\n\t        unplaced = null\n\t      }\n\t    }\n\t  }\n\t\n\t  return placed\n\t}\n\t\n\tfunction endOfContent(slice, depth) {\n\t  for (var i = 0, content = slice.content; i < depth; i++) {\n\t    if (content.childCount > 1) { return false }\n\t    content = content.firstChild.content\n\t  }\n\t  return true\n\t}\n\t\n\tfunction findPlacement(fragment, $from, start, placed) {\n\t  var hasMarks = false\n\t  for (var i = 0; i < fragment.childCount; i++)\n\t    { if (fragment.child(i).marks.length) { hasMarks = true } }\n\t  for (var d = start; d >= 0; d--) {\n\t    var startMatch = $from.node(d).contentMatchAt($from.indexAfter(d))\n\t    var existing = placed[d]\n\t    if (existing) { startMatch = startMatch.matchFragment(existing.content) }\n\t    var match = startMatch.fillBefore(fragment)\n\t    if (match) { return {depth: d, fragment: (existing ? existing.content.append(match) : match).append(fragment)} }\n\t    if (hasMarks) {\n\t      var stripped = matchStrippingMarks(startMatch, fragment)\n\t      if (stripped) { return {depth: d, fragment: existing ? existing.content.append(stripped) : stripped} }\n\t    }\n\t  }\n\t}\n\t\n\tfunction matchStrippingMarks(match, fragment) {\n\t  var newNodes = []\n\t  for (var i = 0; i < fragment.childCount; i++) {\n\t    var node = fragment.child(i), stripped = node.mark(node.marks.filter(function (m) { return match.allowsMark(m.type); }))\n\t    match = match.matchNode(stripped)\n\t    if (!match) { return null }\n\t    newNodes.push(stripped)\n\t  }\n\t  return Fragment.from(newNodes)\n\t}\n\n\n/***/ },\n/* 155 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar Selection = ref.Selection;\n\tvar NodeSelection = ref.NodeSelection;\n\tvar TextSelection = ref.TextSelection;\n\tvar browser = __webpack_require__(18)\n\t\n\tfunction moveSelectionBlock(state, dir) {\n\t  var ref = state.selection;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  var node = ref.node;\n\t  var $side = dir > 0 ? $to : $from\n\t  var $start = node && node.isBlock ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null\n\t  return $start && Selection.findFrom($start, dir)\n\t}\n\t\n\tfunction apply(view, sel) {\n\t  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView())\n\t  return true\n\t}\n\t\n\tfunction selectHorizontally(view, dir) {\n\t  var ref = view.state.selection;\n\t  var empty = ref.empty;\n\t  var node = ref.node;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  if (!empty && !node) { return false }\n\t\n\t  if (node && node.isInline)\n\t    { return apply(view, new TextSelection(dir > 0 ? $to : $from)) }\n\t\n\t  if (!node && !view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n\t    var ref$1 = dir > 0\n\t        ? $from.parent.childAfter($from.parentOffset)\n\t        : $from.parent.childBefore($from.parentOffset);\n\t    var nextNode = ref$1.node;\n\t    var offset = ref$1.offset;\n\t    if (nextNode && NodeSelection.isSelectable(nextNode) && offset == $from.parentOffset - (dir > 0 ? 0 : nextNode.nodeSize))\n\t      { return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($from.pos - nextNode.nodeSize) : $from)) }\n\t    return false\n\t  }\n\t\n\t  var next = moveSelectionBlock(view.state, dir)\n\t  if (next && (next instanceof NodeSelection || node))\n\t    { return apply(view, next) }\n\t\n\t  return false\n\t}\n\t\n\tfunction nodeLen(node) {\n\t  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n\t}\n\t\n\tfunction isIgnorable(dom) {\n\t  var desc = dom.pmViewDesc\n\t  return desc && desc.size == 0\n\t}\n\t\n\t// Make sure the cursor isn't directly after one or more ignored\n\t// nodes, which will confuse the browser's cursor motion logic.\n\tfunction skipIgnoredNodesLeft(view) {\n\t  var sel = view.root.getSelection()\n\t  var node = sel.anchorNode, offset = sel.anchorOffset\n\t  var moveNode, moveOffset\n\t  for (;;) {\n\t    if (offset > 0) {\n\t      if (node.nodeType != 1) { break }\n\t      var before = node.childNodes[offset - 1]\n\t      if (isIgnorable(before)) {\n\t        moveNode = node\n\t        moveOffset = --offset\n\t      }\n\t      else { break }\n\t    } else if (isBlockNode(node)) {\n\t      break\n\t    } else {\n\t      var prev = node.previousSibling\n\t      while (prev && isIgnorable(prev)) {\n\t        moveNode = node.parentNode\n\t        moveOffset = Array.prototype.indexOf.call(moveNode.childNodes, prev)\n\t        prev = prev.previousSibling\n\t      }\n\t      if (!prev) {\n\t        node = node.parentNode\n\t        if (node == view.content) { break }\n\t        offset = 0\n\t      } else {\n\t        node = prev\n\t        offset = nodeLen(node)\n\t      }\n\t    }\n\t  }\n\t  if (moveNode) { setSel(sel, moveNode, moveOffset) }\n\t}\n\t\n\t// Make sure the cursor isn't directly before one or more ignored\n\t// nodes.\n\tfunction skipIgnoredNodesRight(view) {\n\t  var sel = view.root.getSelection()\n\t  var node = sel.anchorNode, offset = sel.anchorOffset, len = nodeLen(node)\n\t  var moveNode, moveOffset\n\t  for (;;) {\n\t    if (offset < len) {\n\t      if (node.nodeType != 1) { break }\n\t      var after = node.childNodes[offset]\n\t      if (isIgnorable(after)) {\n\t        moveNode = node\n\t        moveOffset = ++offset\n\t      }\n\t      else { break }\n\t    } else if (isBlockNode(node)) {\n\t      break\n\t    } else {\n\t      var next = node.nextSibling\n\t      while (next && isIgnorable(next)) {\n\t        moveNode = next.parentNode\n\t        moveOffset = Array.prototype.indexOf.call(moveNode.childNodes, next) + 1\n\t        next = next.nextSibling\n\t      }\n\t      if (!next) {\n\t        node = node.parentNode\n\t        if (node == view.content) { break }\n\t        offset = len = 0\n\t      } else {\n\t        node = next\n\t        offset = 0\n\t        len = nodeLen(node)\n\t      }\n\t    }\n\t  }\n\t  if (moveNode) { setSel(sel, moveNode, moveOffset) }\n\t}\n\t\n\tfunction isBlockNode(dom) {\n\t  var desc = dom.pmViewDesc\n\t  return desc && desc.node && desc.node.isBlock\n\t}\n\t\n\tfunction setSel(sel, node, offset) {\n\t  var range = document.createRange()\n\t  range.setEnd(node, offset)\n\t  range.setStart(node, offset)\n\t  sel.removeAllRanges()\n\t  sel.addRange(range)\n\t}\n\t\n\t// : (EditorState, number)\n\t// Check whether vertical selection motion would involve node\n\t// selections. If so, apply it (if not, the result is left to the\n\t// browser)\n\tfunction selectVertically(view, dir) {\n\t  var ref = view.state.selection;\n\t  var empty = ref.empty;\n\t  var node = ref.node;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  if (!empty && !node) { return false }\n\t\n\t  var leavingTextblock = true, $start = dir < 0 ? $from : $to\n\t  if (!node || node.isInline)\n\t    { leavingTextblock = view.endOfTextblock(dir < 0 ? \"up\" : \"down\") }\n\t\n\t  if (leavingTextblock) {\n\t    var next = moveSelectionBlock(view.state, dir)\n\t    if (next && (next instanceof NodeSelection))\n\t      { return apply(view, next) }\n\t  }\n\t\n\t  if (!node || node.isInline) { return false }\n\t\n\t  var beyond = Selection.findFrom($start, dir)\n\t  return beyond ? apply(view, beyond) : true\n\t}\n\t\n\tfunction stopNativeHorizontalDelete(view, dir) {\n\t  var ref = view.state.selection;\n\t  var $head = ref.$head;\n\t  var $anchor = ref.$anchor;\n\t  var empty = ref.empty;\n\t  if (!$head || !$head.sameParent($anchor) || !$head.parent.isTextblock) { return true }\n\t  if (!empty) { return false }\n\t  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) { return true }\n\t  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter)\n\t  if (nextNode && !nextNode.isText) {\n\t    var tr = view.state.tr\n\t    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos) }\n\t    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize) }\n\t    view.dispatch(tr)\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\t// A backdrop keymap used to make sure we always suppress keys that\n\t// have a dangerous default effect, even if the commands they are\n\t// bound to return false, and to make sure that cursor-motion keys\n\t// find a cursor (as opposed to a node selection) when pressed. For\n\t// cursor-motion keys, the code in the handlers also takes care of\n\t// block selections.\n\t\n\tfunction captureKeyDown(view, event) {\n\t  var code = event.keyCode, mod = browser.mac ? event.metaKey : event.ctrlKey\n\t  if (code == 8) { // Backspace\n\t    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n\t  } else if (code == 46) { // Delete\n\t    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n\t  } else if (code == 13 || code == 27) { // Enter, Esc\n\t    return true\n\t  } else if (code == 37) { // Left arrow\n\t    return selectHorizontally(view, -1) || skipIgnoredNodesLeft(view)\n\t  } else if (code == 39) { // Right arrow\n\t    return selectHorizontally(view, 1) || skipIgnoredNodesRight(view)\n\t  } else if (code == 38) { // Up arrow\n\t    return selectVertically(view, -1)\n\t  } else if (code == 40) { // Down arrow\n\t    return selectVertically(view, 1)\n\t  } else if (mod && !event.altKey && !event.shiftKey) { // Mod-\n\t    if (code == 66 || code == 73 || code == 89 || code == 90) // Mod-[biyz]\n\t      { return true }\n\t    if (browser.mac && code == 68) // Mod-d\n\t      { return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view) }\n\t    if (browser.mac && code == 72) // Mod-h\n\t      { return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view) }\n\t  } else if (browser.mac && code == 68 && event.altKey && !mod && !event.shiftKey) { // Alt-d\n\t    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n\t  }\n\t  return false\n\t}\n\texports.captureKeyDown = captureKeyDown\n\n\n/***/ },\n/* 156 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Slice = ref.Slice;\n\tvar Fragment = ref.Fragment;\n\tvar DOMParser = ref.DOMParser;\n\tvar DOMSerializer = ref.DOMSerializer;\n\t\n\t// : (EditorView, Selection, dom.DataTransfer) → Slice\n\t// Store the content of a selection in the clipboard (or whatever the\n\t// given data transfer refers to)\n\tfunction toClipboard(view, range, dataTransfer) {\n\t  // Node selections are copied using just the node, text selection include parents\n\t  var doc = view.state.doc, fullSlice = doc.slice(range.from, range.to, !range.node)\n\t  var slice = fullSlice, context\n\t  if (!range.node) {\n\t    // Shrink slices for non-node selections to hold only the parent\n\t    // node, store rest in context string, so that other tools don't\n\t    // get confused\n\t    var cut = Math.max(0, range.$from.sharedDepth(range.to) - 1)\n\t    context = sliceContext(slice, cut)\n\t    var content = slice.content\n\t    for (var i = 0; i < cut; i++) { content = content.firstChild.content }\n\t    slice = new Slice(content, slice.openLeft - cut, slice.openRight - cut)\n\t  }\n\t\n\t  var serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema)\n\t  var dom = serializer.serializeFragment(slice.content), wrap = document.createElement(\"div\")\n\t  wrap.appendChild(dom)\n\t  var child = wrap.firstChild.nodeType == 1 && wrap.firstChild\n\t  if (child) {\n\t    if (range.node)\n\t      { child.setAttribute(\"data-pm-node-selection\", true) }\n\t    else\n\t      { child.setAttribute(\"data-pm-context\", context) }\n\t  }\n\t\n\t  dataTransfer.clearData()\n\t  dataTransfer.setData(\"text/html\", wrap.innerHTML)\n\t  dataTransfer.setData(\"text/plain\", slice.content.textBetween(0, slice.content.size, \"\\n\\n\"))\n\t  return fullSlice\n\t}\n\texports.toClipboard = toClipboard\n\t\n\tvar cachedCanUpdateClipboard = null\n\tfunction canUpdateClipboard(dataTransfer) {\n\t  if (cachedCanUpdateClipboard != null) { return cachedCanUpdateClipboard }\n\t  dataTransfer.setData(\"text/html\", \"<hr>\")\n\t  return cachedCanUpdateClipboard = dataTransfer.getData(\"text/html\") == \"<hr>\"\n\t}\n\texports.canUpdateClipboard = canUpdateClipboard\n\t\n\t// : (EditorView, dom.DataTransfer, ?bool, ResolvedPos) → ?Slice\n\t// Read a slice of content from the clipboard (or drop data).\n\tfunction fromClipboard(view, dataTransfer, plainText, $context) {\n\t  var txt = dataTransfer.getData(\"text/plain\")\n\t  var html = dataTransfer.getData(\"text/html\")\n\t  if (!html && !txt) { return null }\n\t  var dom, inCode = $context.parent.type.spec.code\n\t  if ((plainText || inCode || !html) && txt) {\n\t    view.someProp(\"transformPastedText\", function (f) { return txt = f(txt); })\n\t    if (inCode) { return new Slice(Fragment.from(view.state.schema.text(txt)), 0, 0) }\n\t    dom = document.createElement(\"div\")\n\t    txt.split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n\t      dom.appendChild(document.createElement(\"p\")).textContent = block\n\t    })\n\t  } else {\n\t    view.someProp(\"transformPastedHTML\", function (f) { return html = f(html); })\n\t    dom = readHTML(html)\n\t  }\n\t\n\t  var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n\t  var slice = parser.parseSlice(dom, {preserveWhitespace: true}), context\n\t  if (dom.querySelector(\"[data-pm-node-selection]\"))\n\t    { slice = new Slice(slice.content, 0, 0) }\n\t  else if (context = dom.querySelector(\"[data-pm-context]\"))\n\t    { slice = addContext(slice, context.getAttribute(\"data-pm-context\")) }\n\t  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n\t    { slice = normalizeSiblings(slice, $context) }\n\t  return slice\n\t}\n\texports.fromClipboard = fromClipboard\n\t\n\t// Takes a slice parsed with parseSlice, which means there hasn't been\n\t// any content-expression checking done on the top nodes, tries to\n\t// find a parent node in the current context that might fit the nodes,\n\t// and if successful, rebuilds the slice so that it fits into that parent.\n\t//\n\t// This addresses the problem that Transform.replace expects a\n\t// coherent slice, and will fail to place a set of siblings that don't\n\t// fit anywhere in the schema.\n\tfunction normalizeSiblings(slice, $context) {\n\t  if (slice.content.childCount < 2) { return slice }\n\t  var loop = function ( d ) {\n\t    var parent = $context.node(d)\n\t    var match = parent.contentMatchAt($context.index(d))\n\t    var lastWrap = (void 0), result = []\n\t    slice.content.forEach(function (node) {\n\t      if (!result) { return }\n\t      var wrap = match.findWrappingFor(node), inLast\n\t      if (!wrap) { return result = null }\n\t      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n\t        result[result.length - 1] = inLast\n\t      } else {\n\t        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length) }\n\t        var wrapped = withWrappers(node, wrap)\n\t        result.push(wrapped)\n\t        match = match.matchType(wrapped.type, wrapped.attrs)\n\t        lastWrap = wrap\n\t      }\n\t    })\n\t    if (result) { return { v: Slice.maxOpen(Fragment.from(result)) } }\n\t  };\n\t\n\t  for (var d = $context.depth; d >= 0; d--) {\n\t    var returned = loop( d );\n\t\n\t    if ( returned ) return returned.v;\n\t  }\n\t  return slice\n\t}\n\t\n\tfunction withWrappers(node, wrap, from) {\n\t  if ( from === void 0 ) from = 0;\n\t\n\t  for (var i = wrap.length - 1; i >= from; i--)\n\t    { node = wrap[i].type.create(wrap[i].attrs, Fragment.from(node)) }\n\t  return node\n\t}\n\t\n\t// Used to group adjacent nodes wrapped in similar parents by\n\t// normalizeSiblings into the same parent node\n\tfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n\t  if (depth < wrap.length && depth < lastWrap.length && wrap[depth].type == lastWrap[depth].type) {\n\t    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1)\n\t    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }\n\t    var match = sibling.contentMatchAt(sibling.childCount)\n\t    if (depth == wrap.length - 1 ? match.matchNode(node) : match.matchType(wrap[depth + 1].type, wrap[depth + 1].attrs))\n\t      { return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1)))) }\n\t  }\n\t}\n\t\n\tfunction closeRight(node, depth) {\n\t  if (depth == 0) { return node }\n\t  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1))\n\t  var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)\n\t  return node.copy(fragment.append(fill))\n\t}\n\t\n\t// Trick from jQuery -- some elements must be wrapped in other\n\t// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n\t// \"<td>..</td>\"` the table cells are ignored.\n\tvar wrapMap = {thead: \"table\", colgroup: \"table\", col: \"table colgroup\",\n\t                 tr: \"table tbody\", td: \"table tbody tr\", th: \"table tbody tr\"}\n\tvar detachedDoc = null\n\tfunction readHTML(html) {\n\t  var metas = /(\\s*<meta [^>]*>)*/.exec(html)\n\t  if (metas) { html = html.slice(metas[0].length) }\n\t  var doc = detachedDoc || (detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n\t  var elt = doc.createElement(\"div\")\n\t  var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\\s]+)/i.exec(html), wrap, depth = 0\n\t  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {\n\t    var nodes = wrap.split(\" \")\n\t    html = nodes.map(function (n) { return \"<\" + n + \">\"; }).join(\"\") + html + nodes.map(function (n) { return \"</\" + n + \">\"; }).reverse().join(\"\")\n\t    depth = nodes.length\n\t  }\n\t  elt.innerHTML = html\n\t  for (var i = 0; i < depth; i++) { elt = elt.firstChild }\n\t  return elt\n\t}\n\t\n\tfunction sliceContext(slice, depth) {\n\t  var result = [], content = slice.content\n\t  for (var i = 0; i < depth; i++) {\n\t    var node = content.firstChild\n\t    result.push(node.type.name, node.type.hasRequiredAttrs() ? node.attrs : null)\n\t    content = node.content\n\t  }\n\t  return JSON.stringify(result)\n\t}\n\t\n\tfunction addContext(slice, context) {\n\t  if (!slice.size) { return slice }\n\t  var schema = slice.content.firstChild.type.schema, array\n\t  try { array = JSON.parse(context) }\n\t  catch(e) { return slice }\n\t  var content = slice.content;\n\t  var openLeft = slice.openLeft;\n\t  var openRight = slice.openRight;\n\t  for (var i = array.length - 2; i >= 0; i -= 2) {\n\t    var type = schema.nodes[array[i]]\n\t    if (!type || type.hasRequiredAttrs()) { break }\n\t    content = Fragment.from(type.create(array[i + 1], content))\n\t    openLeft++; openRight++\n\t  }\n\t  return new Slice(content, openLeft, openRight)\n\t}\n\n\n/***/ },\n/* 157 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar Fragment = ref.Fragment;\n\tvar DOMParser = ref.DOMParser;\n\tvar ref$1 = __webpack_require__(2);\n\tvar Selection = ref$1.Selection;\n\t\n\tvar ref$2 = __webpack_require__(60);\n\tvar TrackMappings = ref$2.TrackMappings;\n\t\n\tvar DOMChange = function(view, id, composing) {\n\t  var this$1 = this;\n\t\n\t  this.view = view\n\t  this.id = id\n\t  this.state = view.state\n\t  this.composing = composing\n\t  this.from = this.to = null\n\t  this.timeout = composing ? null : setTimeout(function () { return this$1.finish(); }, 20)\n\t  this.mappings = new TrackMappings(view.state)\n\t};\n\t\n\tDOMChange.prototype.addRange = function (from, to) {\n\t  if (this.from == null) {\n\t    this.from = from\n\t    this.to = to\n\t  } else {\n\t    this.from = Math.min(from, this.from)\n\t    this.to = Math.max(to, this.to)\n\t  }\n\t};\n\t\n\tDOMChange.prototype.changedRange = function () {\n\t  if (this.from == null) { return rangeAroundSelection(this.state.selection) }\n\t  var $from = this.state.doc.resolve(this.from), $to = this.state.doc.resolve(this.to)\n\t  var shared = $from.sharedDepth(this.to)\n\t  return {from: $from.before(shared + 1), to: $to.after(shared + 1)}\n\t};\n\t\n\tDOMChange.prototype.finish = function (force) {\n\t  clearTimeout(this.timeout)\n\t  if (this.composing && !force) { return }\n\t  var range = this.changedRange()\n\t  if (this.from == null) { this.view.docView.markDirty(range.from, range.to) }\n\t  else { this.view.docView.markDirty(this.from, this.to) }\n\t\n\t  // If there have been changes since this DOM update started, we must\n\t  // map our start and end positions, as well as the new selection\n\t  // positions, through them.\n\t  var mapping = this.mappings.getMapping(this.view.state)\n\t  this.destroy()\n\t  if (mapping) { readDOMChange(this.view, mapping, this.state, range) }\n\t\n\t  // If the reading didn't result in a view update, force one by\n\t  // resetting the view to its current state.\n\t  if (this.view.docView.dirty) { this.view.updateState(this.view.state) }\n\t};\n\t\n\tDOMChange.prototype.destroy = function () {\n\t  this.mappings.destroy()\n\t  this.view.inDOMChange = null\n\t};\n\t\n\tDOMChange.prototype.compositionEnd = function () {\n\t    var this$1 = this;\n\t\n\t  if (this.composing) {\n\t    this.composing = false\n\t    this.timeout = setTimeout(function () { return this$1.finish(); }, 50)\n\t  }\n\t};\n\t\n\tDOMChange.start = function (view, composing) {\n\t  if (view.inDOMChange) {\n\t    if (composing) {\n\t      clearTimeout(view.inDOMChange.timeout)\n\t      view.inDOMChange.composing = true\n\t    }\n\t  } else {\n\t    var id = Math.floor(Math.random() * 0xffffffff)\n\t    view.inDOMChange = new DOMChange(view, id, composing)\n\t  }\n\t};\n\texports.DOMChange = DOMChange\n\t\n\t// Note that all referencing and parsing is done with the\n\t// start-of-operation selection and document, since that's the one\n\t// that the DOM represents. If any changes came in in the meantime,\n\t// the modification is mapped over those before it is applied, in\n\t// readDOMChange.\n\t\n\tfunction parseBetween(view, oldState, from, to) {\n\t  var ref = view.docView.domFromPos(from, -1);\n\t  var parent = ref.node;\n\t  var startOff = ref.offset;\n\t  var ref$1 = view.docView.domFromPos(to, 1);\n\t  var parentRight = ref$1.node;\n\t  var endOff = ref$1.offset;\n\t  if (parent != parentRight) { return null }\n\t  // If there's non-view nodes directly after the end of this region,\n\t  // fail and let the caller try again with a wider range.\n\t  if (endOff == parent.childNodes.length) { for (var scan = parent; scan != view.content;) {\n\t    if (scan.nextSibling) {\n\t      if (!scan.nextSibling.pmViewDesc) { return null }\n\t      break\n\t    }\n\t    scan = scan.parentNode\n\t  } }\n\t\n\t  var domSel = view.root.getSelection(), find = null\n\t  if (domSel.anchorNode && view.content.contains(domSel.anchorNode)) {\n\t    find = [{node: domSel.anchorNode, offset: domSel.anchorOffset}]\n\t    if (!domSel.isCollapsed)\n\t      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}) }\n\t  }\n\t  var startDoc = oldState.doc\n\t  var parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n\t  var $from = startDoc.resolve(from)\n\t  var sel = null, doc = parser.parse(parent, {\n\t    topNode: $from.parent.copy(),\n\t    topStart: $from.index(),\n\t    topOpen: true,\n\t    from: startOff,\n\t    to: endOff,\n\t    preserveWhitespace: true,\n\t    editableContent: true,\n\t    findPositions: find,\n\t    ruleFromNode: ruleFromNode\n\t  })\n\t  if (find && find[0].pos != null) {\n\t    var anchor = find[0].pos, head = find[1] && find[1].pos\n\t    if (head == null) { head = anchor }\n\t    sel = {anchor: anchor + from, head: head + from}\n\t  }\n\t  return {doc: doc, sel: sel}\n\t}\n\t\n\tfunction ruleFromNode(dom) {\n\t  var desc = dom.pmViewDesc\n\t  if (desc) { return desc.parseRule() }\n\t  else if (dom.nodeName == \"BR\" && dom.parentNode && dom.parentNode.lastChild == dom) { return {ignore: true} }\n\t}\n\t\n\tfunction isAtEnd($pos, depth) {\n\t  for (var i = depth || 0; i < $pos.depth; i++)\n\t    { if ($pos.index(i) + 1 < $pos.node(i).childCount) { return false } }\n\t  return $pos.parentOffset == $pos.parent.content.size\n\t}\n\tfunction isAtStart($pos, depth) {\n\t  for (var i = depth || 0; i < $pos.depth; i++)\n\t    { if ($pos.index(0) > 0) { return false } }\n\t  return $pos.parentOffset == 0\n\t}\n\t\n\tfunction rangeAroundSelection(selection) {\n\t  var $from = selection.$from;\n\t  var $to = selection.$to;\n\t\n\t  if ($from.sameParent($to) && $from.parent.isTextblock && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {\n\t    var startOff = Math.max(0, $from.parentOffset)\n\t    var size = $from.parent.content.size\n\t    var endOff = Math.min(size, $to.parentOffset)\n\t\n\t    if (startOff > 0)\n\t      { startOff = $from.parent.childBefore(startOff).offset }\n\t    if (endOff < size) {\n\t      var after = $from.parent.childAfter(endOff)\n\t      endOff = after.offset + after.node.nodeSize\n\t    }\n\t    var nodeStart = $from.start()\n\t    return {from: nodeStart + startOff, to: nodeStart + endOff}\n\t  } else {\n\t    for (var depth = 0;; depth++) {\n\t      var fromStart = isAtStart($from, depth + 1), toEnd = isAtEnd($to, depth + 1)\n\t      if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {\n\t        var from = $from.before(depth + 1), to = $to.after(depth + 1)\n\t        if (fromStart && $from.index(depth) > 0)\n\t          { from -= $from.node(depth).child($from.index(depth) - 1).nodeSize }\n\t        if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount)\n\t          { to += $to.node(depth).child($to.index(depth) + 1).nodeSize }\n\t        return {from: from, to: to}\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction keyEvent(keyCode, key) {\n\t  var event = document.createEvent(\"Event\")\n\t  event.initEvent(\"keydown\", true, true)\n\t  event.keyCode = keyCode\n\t  event.key = event.code = key\n\t  return event\n\t}\n\t\n\tfunction readDOMChange(view, mapping, oldState, range) {\n\t  var parseResult, doc = oldState.doc\n\t\n\t  for (;;) {\n\t    parseResult = parseBetween(view, oldState, range.from, range.to)\n\t    if (parseResult) { break }\n\t    var $from$1 = doc.resolve(range.from), $to$1 = doc.resolve(range.to)\n\t    range = {from: $from$1.depth ? $from$1.before() : 0,\n\t             to: $to$1.depth ? $to$1.after() : doc.content.size}\n\t  }\n\t  var parsed = parseResult.doc;\n\t  var parsedSel = parseResult.sel;\n\t\n\t  var compare = doc.slice(range.from, range.to)\n\t  var change = findDiff(compare.content, parsed.content, range.from, oldState.selection.from)\n\t\n\t  if (!change) {\n\t    if (parsedSel) {\n\t      var sel = resolveSelection(view.state.doc, mapping, parsedSel)\n\t      if (!sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)) }\n\t    }\n\t    return\n\t  }\n\t\n\t  var $from = parsed.resolveNoCache(change.start - range.from)\n\t  var $to = parsed.resolveNoCache(change.endB - range.from)\n\t  var nextSel\n\t  // If this looks like the effect of pressing Enter, just dispatch an\n\t  // Enter key instead.\n\t  if (!$from.sameParent($to) && $from.pos < parsed.content.size &&\n\t      (nextSel = Selection.findFrom(parsed.resolve($from.pos + 1), 1, true)) &&\n\t      nextSel.head == $to.pos &&\n\t      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); }))\n\t    { return }\n\t  if (oldState.selection.anchor > change.start &&\n\t      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n\t      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); }))\n\t    { return }\n\t\n\t  var from = mapping.map(change.start), to = mapping.map(change.endA, -1)\n\t\n\t  var tr, storedMarks, markChange, $from1\n\t  if ($from.sameParent($to) && $from.parent.isTextblock) {\n\t    if ($from.pos == $to.pos) { // Deletion\n\t      tr = view.state.tr.delete(from, to)\n\t      var $start = doc.resolve(change.start)\n\t      if ($start.parentOffset < $start.parent.content.size) { storedMarks = $start.marks(true) }\n\t    } else if ( // Adding or removing a mark\n\t      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n\t      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n\t                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n\t    ) {\n\t      tr = view.state.tr\n\t      if (markChange.type == \"add\") { tr.addMark(from, to, markChange.mark) }\n\t      else { tr.removeMark(from, to, markChange.mark) }\n\t    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n\t      // Both positions in the same text node -- simply insert text\n\t      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset)\n\t      if (view.someProp(\"handleTextInput\", function (f) { return f(view, from, to, text); })) { return }\n\t      tr = view.state.tr.insertText(text, from, to)\n\t    }\n\t  }\n\t\n\t  if (!tr)\n\t    { tr = view.state.tr.replace(from, to, parsed.slice(change.start - range.from, change.endB - range.from)) }\n\t  if (parsedSel) { tr.setSelection(resolveSelection(tr.doc, mapping, parsedSel)) }\n\t  if (storedMarks) { tr.setStoredMarks(storedMarks) }\n\t  view.dispatch(tr.scrollIntoView())\n\t}\n\t\n\tfunction resolveSelection(doc, mapping, parsedSel) {\n\t  return Selection.between(doc.resolve(mapping.map(parsedSel.anchor)),\n\t                           doc.resolve(mapping.map(parsedSel.head)))\n\t}\n\t\n\t// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n\t// Given two same-length, non-empty fragments of inline content,\n\t// determine whether the first could be created from the second by\n\t// removing or adding a single mark type.\n\tfunction isMarkChange(cur, prev) {\n\t  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks\n\t  var added = curMarks, removed = prevMarks, type, mark, update\n\t  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added) }\n\t  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed) }\n\t  if (added.length == 1 && removed.length == 0) {\n\t    mark = added[0]\n\t    type = \"add\"\n\t    update = function (node) { return node.mark(mark.addToSet(node.marks)); }\n\t  } else if (added.length == 0 && removed.length == 1) {\n\t    mark = removed[0]\n\t    type = \"remove\"\n\t    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); }\n\t  } else {\n\t    return null\n\t  }\n\t  var updated = []\n\t  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))) }\n\t  if (Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }\n\t}\n\t\n\tfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n\t  if (!$newStart.parent.isTextblock ||\n\t      // The content must have shrunk\n\t      end - start <= $newEnd.pos - $newStart.pos ||\n\t      // newEnd must point directly at or after the end of the block that newStart points into\n\t      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n\t    { return false }\n\t\n\t  var $start = old.resolve(start)\n\t  // Start must be at the end of a block\n\t  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n\t    { return false }\n\t  var $next = old.resolve(skipClosingAndOpening($start, true, true))\n\t  // The next textblock must start before end and end near it\n\t  if (!$next.parent.isTextblock || $next.pos > end ||\n\t      skipClosingAndOpening($next, true, false) < end)\n\t    { return false }\n\t\n\t  // The fragments after the join point must match\n\t  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n\t}\n\t\n\tfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n\t  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos\n\t  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n\t    depth--\n\t    end++\n\t    fromEnd = false\n\t  }\n\t  if (mayOpen) {\n\t    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth))\n\t    while (next && !next.isLeaf) {\n\t      next = next.firstChild\n\t      end++\n\t    }\n\t  }\n\t  return end\n\t}\n\t\n\tfunction findDiff(a, b, pos, preferedStart) {\n\t  var start = a.findDiffStart(b, pos)\n\t  if (!start) { return null }\n\t  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);\n\t  var endA = ref.a;\n\t  var endB = ref.b;\n\t  if (endA < start && a.size < b.size) {\n\t    var move = preferedStart <= start && preferedStart >= endA ? start - preferedStart : 0\n\t    start -= move\n\t    endB = start + (endB - endA)\n\t    endA = start\n\t  } else if (endB < start) {\n\t    var move$1 = preferedStart <= start && preferedStart >= endB ? start - preferedStart : 0\n\t    start -= move$1\n\t    endA = start + (endA - endB)\n\t    endB = start\n\t  }\n\t  return {start: start, endA: endA, endB: endB}\n\t}\n\n\n/***/ },\n/* 158 */\n/***/ function(module, exports) {\n\n\tfunction windowRect() {\n\t  return {left: 0, right: window.innerWidth,\n\t          top: 0, bottom: window.innerHeight}\n\t}\n\t\n\tfunction parentNode(node) {\n\t  var parent = node.parentNode\n\t  return parent.nodeType == 11 ? parent.host : parent\n\t}\n\t\n\tfunction scrollRectIntoView(view, rect) {\n\t  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\")\n\t  if (scrollMargin == null) { scrollMargin = 5 }\n\t  for (var parent = view.content;; parent = parentNode(parent)) {\n\t    var atBody = parent == document.body\n\t    var bounding = atBody ? windowRect() : parent.getBoundingClientRect()\n\t    var moveX = 0, moveY = 0\n\t    if (rect.top < bounding.top + scrollThreshold)\n\t      { moveY = -(bounding.top - rect.top + scrollMargin) }\n\t    else if (rect.bottom > bounding.bottom - scrollThreshold)\n\t      { moveY = rect.bottom - bounding.bottom + scrollMargin }\n\t    if (rect.left < bounding.left + scrollThreshold)\n\t      { moveX = -(bounding.left - rect.left + scrollMargin) }\n\t    else if (rect.right > bounding.right - scrollThreshold)\n\t      { moveX = rect.right - bounding.right + scrollMargin }\n\t    if (moveX || moveY) {\n\t      if (atBody) {\n\t        window.scrollBy(moveX, moveY)\n\t      } else {\n\t        if (moveY) { parent.scrollTop += moveY }\n\t        if (moveX) { parent.scrollLeft += moveX }\n\t      }\n\t    }\n\t    if (atBody) { break }\n\t  }\n\t}\n\texports.scrollRectIntoView = scrollRectIntoView\n\t\n\tfunction findOffsetInNode(node, coords) {\n\t  var closest, dxClosest = 2e8, coordsClosest, offset = 0\n\t  var rowBot = coords.top, rowTop = coords.top\n\t  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n\t    var rects = (void 0)\n\t    if (child.nodeType == 1) { rects = child.getClientRects() }\n\t    else if (child.nodeType == 3) { rects = textRange(child).getClientRects() }\n\t    else { continue }\n\t\n\t    for (var i = 0; i < rects.length; i++) {\n\t      var rect = rects[i]\n\t      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n\t        rowBot = Math.max(rect.bottom, rowBot)\n\t        rowTop = Math.min(rect.top, rowTop)\n\t        var dx = rect.left > coords.left ? rect.left - coords.left\n\t            : rect.right < coords.left ? coords.left - rect.right : 0\n\t        if (dx < dxClosest) {\n\t          closest = child\n\t          dxClosest = dx\n\t          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords\n\t          if (child.nodeType == 1 && dx)\n\t            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) }\n\t          continue\n\t        }\n\t      }\n\t      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n\t                       coords.left >= rect.left && coords.top >= rect.bottom))\n\t        { offset = childIndex + 1 }\n\t    }\n\t  }\n\t  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }\n\t  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }\n\t  return findOffsetInNode(closest, coordsClosest)\n\t}\n\t\n\tfunction findOffsetInText(node, coords) {\n\t  var len = node.nodeValue.length\n\t  var range = document.createRange()\n\t  for (var i = 0; i < len; i++) {\n\t    range.setEnd(node, i + 1)\n\t    range.setStart(node, i)\n\t    var rect = singleRect(range, 1)\n\t    if (rect.top == rect.bottom) { continue }\n\t    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left &&\n\t        rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top)\n\t      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }\n\t  }\n\t  return {node: node, offset: 0}\n\t}\n\t\n\tfunction targetKludge(dom, coords) {\n\t  if (/^[uo]l$/i.test(dom.nodeName)) {\n\t    for (var child = dom.firstChild; child; child = child.nextSibling) {\n\t      if (!child.pmViewDesc || !/^li$/i.test(child.nodeName)) { continue }\n\t      var childBox = child.getBoundingClientRect()\n\t      if (coords.left > childBox.left - 2) { break }\n\t      if (childBox.top <= coords.top && childBox.bottom >= coords.top) { return child }\n\t    }\n\t  }\n\t  return dom\n\t}\n\t\n\t// Given an x,y position on the editor, get the position in the document.\n\tfunction posAtCoords(view, coords) {\n\t  var elt = targetKludge(view.root.elementFromPoint(coords.left, coords.top + 1), coords)\n\t  if (!view.content.contains(elt.nodeType == 3 ? elt.parentNode : elt)) { return null }\n\t\n\t  var ref = findOffsetInNode(elt, coords);\n\t  var node = ref.node;\n\t  var offset = ref.offset;\n\t  var bias = -1\n\t  if (node.nodeType == 1 && !node.firstChild) {\n\t    var rect = node.getBoundingClientRect()\n\t    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1\n\t  }\n\t\n\t  var desc = view.docView.nearestDesc(elt, true)\n\t  return {pos: view.docView.posFromDOM(node, offset, bias),\n\t          inside: desc && (desc.posAtStart - desc.border)}\n\t}\n\texports.posAtCoords = posAtCoords\n\t\n\tfunction textRange(node, from, to) {\n\t  var range = document.createRange()\n\t  range.setEnd(node, to == null ? node.nodeValue.length : to)\n\t  range.setStart(node, from || 0)\n\t  return range\n\t}\n\t\n\tfunction singleRect(object, bias) {\n\t  var rects = object.getClientRects()\n\t  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n\t}\n\t\n\t// : (ProseMirror, number) → {left: number, top: number, right: number, bottom: number}\n\t// Given a position in the document model, get a bounding box of the\n\t// character at that position, relative to the window.\n\tfunction coordsAtPos(view, pos) {\n\t  var ref = view.docView.domFromPos(pos);\n\t  var node = ref.node;\n\t  var offset = ref.offset;\n\t  var side, rect\n\t  if (node.nodeType == 3) {\n\t    if (offset < node.nodeValue.length) {\n\t      rect = singleRect(textRange(node, offset, offset + 1), -1)\n\t      side = \"left\"\n\t    }\n\t    if ((!rect || rect.left == rect.right) && offset) {\n\t      rect = singleRect(textRange(node, offset - 1, offset), 1)\n\t      side = \"right\"\n\t    }\n\t  } else if (node.firstChild) {\n\t    if (offset < node.childNodes.length) {\n\t      var child = node.childNodes[offset]\n\t      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, -1)\n\t      side = \"left\"\n\t    }\n\t    if ((!rect || rect.top == rect.bottom) && offset) {\n\t      var child$1 = node.childNodes[offset - 1]\n\t      rect = singleRect(child$1.nodeType == 3 ? textRange(child$1) : child$1, 1)\n\t      side = \"right\"\n\t    }\n\t  } else {\n\t    rect = node.getBoundingClientRect()\n\t    side = \"left\"\n\t  }\n\t  var x = rect[side]\n\t  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n\t}\n\texports.coordsAtPos = coordsAtPos\n\t\n\tfunction withFlushedState(view, state, f) {\n\t  var viewState = view.state, active = view.root.activeElement\n\t  if (viewState != state || !view.inDOMChange) { view.updateState(state) }\n\t  if (active != view.content) { view.focus() }\n\t  try {\n\t    return f()\n\t  } finally {\n\t    if (viewState != state) { view.updateState(viewState) }\n\t    if (active != view.content) { active.focus() }\n\t  }\n\t}\n\t\n\t// : (ProseMirror, number, number)\n\t// Whether vertical position motion in a given direction\n\t// from a position would leave a text block.\n\tfunction endOfTextblockVertical(view, state, dir) {\n\t  var $pos = dir == \"up\" ? state.selection.$from : state.selection.$to\n\t  if (!$pos.depth) { return false }\n\t  return withFlushedState(view, state, function () {\n\t    var dom = view.docView.domAfterPos($pos.before())\n\t    var coords = coordsAtPos(view, $pos.pos)\n\t    for (var child = dom.firstChild; child; child = child.nextSibling) {\n\t      var boxes = (void 0)\n\t      if (child.nodeType == 1) { boxes = child.getClientRects() }\n\t      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects() }\n\t      else { continue }\n\t      for (var i = 0; i < boxes.length; i++) {\n\t        var box = boxes[i]\n\t        if (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)\n\t          { return false }\n\t      }\n\t    }\n\t    return true\n\t  })\n\t}\n\t\n\tvar maybeRTL = /[\\u0590-\\u08ac]/\n\t\n\tfunction endOfTextblockHorizontal(view, state, dir) {\n\t  var ref = state.selection;\n\t  var $head = ref.$head;\n\t  var empty = ref.empty;\n\t  if (!empty || !$head.parent.isTextblock || !$head.depth) { return false }\n\t  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size\n\t  // If the textblock is all LTR and the cursor isn't at the sides, we don't need to touch the DOM\n\t  if (!atStart && !atEnd && !maybeRTL.test($head.parent.textContent)) { return false }\n\t  var sel = getSelection()\n\t  // Fall back to a primitive approach if the necessary selection method isn't supported (Edge)\n\t  if (!sel.modify) { return dir == \"left\" || dir == \"backward\" ? atStart : atEnd }\n\t\n\t  return withFlushedState(view, state, function () {\n\t    // This is a huge hack, but appears to be the best we can\n\t    // currently do: use `Selection.modify` to move the selection by\n\t    // one character, and see if that moves the cursor out of the\n\t    // textblock (or doesn't move it at all, when at the start/end of\n\t    // the document).\n\t    var oldRange = sel.getRangeAt(0)\n\t    sel.modify(\"move\", dir, \"character\")\n\t    var parentDOM = view.docView.domAfterPos($head.before())\n\t    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n\t        view.docView.posFromDOM(sel.focusNode, sel.focusOffset) == $head.pos\n\t    // Restore the previous selection\n\t    sel.removeAllRanges()\n\t    sel.addRange(oldRange)\n\t    return result\n\t  })\n\t}\n\t\n\tvar cachedState = null, cachedDir = null, cachedResult = false\n\tfunction endOfTextblock(view, state, dir) {\n\t  if (cachedState == state && cachedDir == dir) { return cachedResult }\n\t  cachedState = state; cachedDir = dir\n\t  return cachedResult = dir == \"up\" || dir == \"down\"\n\t    ? endOfTextblockVertical(view, state, dir)\n\t    : endOfTextblockHorizontal(view, state, dir)\n\t}\n\texports.endOfTextblock = endOfTextblock\n\n\n/***/ },\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar Selection = ref.Selection;\n\tvar NodeSelection = ref.NodeSelection;\n\tvar TextSelection = ref.TextSelection;\n\t\n\tvar browser = __webpack_require__(18)\n\tvar ref$1 = __webpack_require__(155);\n\tvar captureKeyDown = ref$1.captureKeyDown;\n\tvar ref$2 = __webpack_require__(157);\n\tvar DOMChange = ref$2.DOMChange;\n\tvar ref$3 = __webpack_require__(156);\n\tvar fromClipboard = ref$3.fromClipboard;\n\tvar toClipboard = ref$3.toClipboard;\n\tvar canUpdateClipboard = ref$3.canUpdateClipboard;\n\tvar ref$4 = __webpack_require__(60);\n\tvar TrackMappings = ref$4.TrackMappings;\n\t\n\t// A collection of DOM events that occur within the editor, and callback functions\n\t// to invoke when the event fires.\n\tvar handlers = {}, editHandlers = {}\n\t\n\tfunction initInput(view) {\n\t  view.shiftKey = false\n\t  view.mouseDown = null\n\t  view.dragging = null\n\t  view.inDOMChange = null\n\t  view.mutationObserver = window.MutationObserver &&\n\t    new window.MutationObserver(function (mutations) { return registerMutations(view, mutations); })\n\t  startObserving(view)\n\t\n\t  var loop = function ( event ) {\n\t    var handler = handlers[event]\n\t    view.content.addEventListener(event, function (event) {\n\t      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n\t          (view.editable || !(event.type in editHandlers)))\n\t        { handler(view, event) }\n\t    })\n\t  };\n\t\n\t  for (var event in handlers) loop( event );\n\t  view.extraHandlers = Object.create(null)\n\t  ensureListeners(view)\n\t}\n\texports.initInput = initInput\n\t\n\tfunction destroyInput(view) {\n\t  stopObserving(view)\n\t  if (view.inDOMChange) { view.inDOMChange.destroy() }\n\t  if (view.dragging) { view.dragging.destroy() }\n\t}\n\texports.destroyInput = destroyInput\n\t\n\tfunction ensureListeners(view) {\n\t  view.someProp(\"handleDOMEvents\", function (handlers) {\n\t    for (var type in handlers) { if (!view.extraHandlers[type] && !handlers.hasOwnProperty(type)) {\n\t      view.extraHandlers[type] = true\n\t      view.content.addEventListener(type, function (event) { return runCustomHandler(view, event); })\n\t    } }\n\t  })\n\t}\n\texports.ensureListeners = ensureListeners\n\t\n\tfunction runCustomHandler(view, event) {\n\t  return view.someProp(\"handleDOMEvents\", function (handlers) {\n\t    var handler = handlers[event.type]\n\t    return handler ? handler(view, event) : false\n\t  })\n\t}\n\t\n\tfunction eventBelongsToView(view, event) {\n\t  if (!event.bubbles) { return true }\n\t  if (event.defaultPrevented) { return false }\n\t  for (var node = event.target; node != view.content; node = node.parentNode)\n\t    { if (!node || node.nodeType == 11 ||\n\t        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n\t      { return false } }\n\t  return true\n\t}\n\t\n\tfunction dispatchEvent(view, event) {\n\t  if (!runCustomHandler(view, event) && handlers[event.type] &&\n\t      (view.editable || !(event.type in editHandlers)))\n\t    { handlers[event.type](view, event) }\n\t}\n\texports.dispatchEvent = dispatchEvent\n\t\n\teditHandlers.keydown = function (view, event) {\n\t  if (event.keyCode == 16) { view.shiftKey = true }\n\t  if (view.inDOMChange) { return }\n\t  if (view.someProp(\"handleKeyDown\", function (f) { return f(view, event); }) || captureKeyDown(view, event))\n\t    { event.preventDefault() }\n\t  else\n\t    { view.selectionReader.poll() }\n\t}\n\t\n\teditHandlers.keyup = function (view, e) {\n\t  if (e.keyCode == 16) { view.shiftKey = false }\n\t}\n\t\n\teditHandlers.keypress = function (view, event) {\n\t  if (view.inDOMChange || !event.charCode ||\n\t      event.ctrlKey && !event.altKey || browser.mac && event.metaKey) { return }\n\t\n\t  if (view.someProp(\"handleKeyPress\", function (f) { return f(view, event); })) {\n\t    event.preventDefault()\n\t    return\n\t  }\n\t\n\t  var ref = view.state.selection;\n\t  var node = ref.node;\n\t  var $from = ref.$from;\n\t  var $to = ref.$to;\n\t  if (node || !$from.sameParent($to)) {\n\t    var text = String.fromCharCode(event.charCode)\n\t    if (!view.someProp(\"handleTextInput\", function (f) { return f(view, $from.pos, $to.pos, text); }))\n\t      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()) }\n\t    event.preventDefault()\n\t  }\n\t}\n\t\n\tfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\t\n\tvar lastClick = {time: 0, x: 0, y: 0}, oneButLastClick = lastClick\n\t\n\tfunction isNear(event, click) {\n\t  var dx = click.x - event.clientX, dy = click.y - event.clientY\n\t  return dx * dx + dy * dy < 100\n\t}\n\t\n\tfunction runHandlerOnContext(view, propName, pos, inside, event) {\n\t  if (inside == -1) { return false }\n\t  var $pos = view.state.doc.resolve(inside)\n\t  var loop = function ( i ) {\n\t    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n\t                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))\n\t      { return { v: true } }\n\t  };\n\t\n\t  for (var i = $pos.depth + 1; i > 0; i--) {\n\t    var returned = loop( i );\n\t\n\t    if ( returned ) return returned.v;\n\t  }\n\t  return false\n\t}\n\t\n\tfunction updateSelection(view, selection, origin) {\n\t  view.focus()\n\t  var tr = view.state.tr.setSelection(selection)\n\t  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true) }\n\t  view.dispatch(tr)\n\t}\n\t\n\tfunction selectClickedLeaf(view, inside) {\n\t  if (inside == -1) { return false }\n\t  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter\n\t  if (node && node.isLeaf && NodeSelection.isSelectable(node)) {\n\t    updateSelection(view, new NodeSelection($pos), \"pointer\")\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tfunction selectClickedNode(view, inside) {\n\t  if (inside == -1) { return false }\n\t  var ref = view.state.selection;\n\t  var selectedNode = ref.node;\n\t  var $from = ref.$from;\n\t  var selectAt\n\t\n\t  var $pos = view.state.doc.resolve(inside)\n\t  for (var i = $pos.depth + 1; i > 0; i--) {\n\t    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n\t    if (NodeSelection.isSelectable(node)) {\n\t     if (selectedNode && $from.depth > 0 &&\n\t          i >= $from.depth && $pos.before($from.depth + 1) == $from.pos)\n\t        { selectAt = $pos.before($from.depth) }\n\t      else\n\t        { selectAt = $pos.before(i) }\n\t      break\n\t    }\n\t  }\n\t\n\t  if (selectAt != null) {\n\t    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\")\n\t    return true\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction handleSingleClick(view, pos, inside, event) {\n\t  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n\t    view.someProp(\"handleClick\", function (f) { return f(view, pos, event); }) ||\n\t    selectClickedLeaf(view, inside)\n\t}\n\t\n\tfunction handleDoubleClick(view, pos, inside, event) {\n\t  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n\t    view.someProp(\"handleDoubleClick\", function (f) { return f(view, pos, event); })\n\t}\n\t\n\tfunction handleTripleClick(view, pos, inside, event) {\n\t  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n\t    view.someProp(\"handleTripleClick\", function (f) { return f(view, pos, event); }) ||\n\t    defaultTripleClick(view, inside)\n\t}\n\t\n\tfunction defaultTripleClick(view, inside) {\n\t  var doc = view.state.doc\n\t  if (inside == -1) {\n\t    if (doc.isTextblock) {\n\t      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\")\n\t      return true\n\t    }\n\t    return false\n\t  }\n\t\n\t  var $pos = doc.resolve(inside)\n\t  for (var i = $pos.depth + 1; i > 0; i--) {\n\t    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n\t    var nodePos = $pos.before(i)\n\t    if (node.isTextblock)\n\t      { updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\") }\n\t    else if (NodeSelection.isSelectable(node))\n\t      { updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\") }\n\t    else\n\t      { continue }\n\t    return true\n\t  }\n\t}\n\t\n\tfunction forceDOMFlush(view) {\n\t  if (!view.inDOMChange) { return false }\n\t  view.inDOMChange.finish(true)\n\t  return true\n\t}\n\t\n\tvar selectNodeModifier = browser.mac ? \"metaKey\" : \"ctrlKey\"\n\t\n\thandlers.mousedown = function (view, event) {\n\t  var flushed = forceDOMFlush(view)\n\t  var now = Date.now(), type\n\t  if (now - lastClick.time >= 500 || !isNear(event, lastClick) || event[selectNodeModifier]) { type = \"singleClick\" }\n\t  else if (now - oneButLastClick.time >= 600 || !isNear(event, oneButLastClick)) { type = \"doubleClick\" }\n\t  else { type = \"tripleClick\" }\n\t  oneButLastClick = lastClick\n\t  lastClick = {time: now, x: event.clientX, y: event.clientY}\n\t\n\t  var pos = view.posAtCoords(eventCoords(event))\n\t  if (!pos) { return }\n\t\n\t  if (type == \"singleClick\")\n\t    { view.mouseDown = new MouseDown(view, pos, event, flushed) }\n\t  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n\t    { event.preventDefault() }\n\t  else\n\t    { view.selectionReader.poll(\"pointer\") }\n\t}\n\t\n\tvar MouseDown = function(view, pos, event, flushed) {\n\t  var this$1 = this;\n\t\n\t  this.view = view\n\t  this.pos = pos\n\t  this.flushed = flushed\n\t  this.selectNode = event[selectNodeModifier]\n\t  this.allowDefault = event.shiftKey\n\t\n\t  var targetNode, targetPos\n\t  if (pos.inside > -1) {\n\t    targetNode = view.state.doc.nodeAt(pos.inside)\n\t    targetPos = pos.inside\n\t  } else {\n\t    var $pos = view.state.doc.resolve(pos.pos)\n\t    targetNode = $pos.parent\n\t    targetPos = $pos.depth ? $pos.before() : 0\n\t  }\n\t\n\t  this.mightDrag = (targetNode.type.spec.draggable || targetNode == view.state.selection.node) ? {node: targetNode, pos: targetPos} : null\n\t  this.target = flushed ? null : event.target\n\t  if (this.target && this.mightDrag) {\n\t    stopObserving(this.view)\n\t    this.target.draggable = true\n\t    if (browser.gecko && (this.setContentEditable = !this.target.hasAttribute(\"contentEditable\")))\n\t      { setTimeout(function () { return this$1.target.setAttribute(\"contentEditable\", \"false\"); }, 20) }\n\t    startObserving(this.view)\n\t  }\n\t\n\t  view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this))\n\t  view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this))\n\t  view.selectionReader.poll(\"pointer\")\n\t};\n\t\n\tMouseDown.prototype.done = function () {\n\t  this.view.root.removeEventListener(\"mouseup\", this.up)\n\t  this.view.root.removeEventListener(\"mousemove\", this.move)\n\t  if (this.mightDrag && this.target) {\n\t    stopObserving(this.view)\n\t    this.target.draggable = false\n\t    if (browser.gecko && this.setContentEditable)\n\t      { this.target.removeAttribute(\"contentEditable\") }\n\t    startObserving(this.view)\n\t  }\n\t};\n\t\n\tMouseDown.prototype.up = function (event) {\n\t  this.done()\n\t\n\t  if (!this.view.content.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n\t    { return }\n\t\n\t  if (this.allowDefault) {\n\t    this.view.selectionReader.poll(\"pointer\")\n\t  } else if (this.selectNode\n\t             ? selectClickedNode(this.view, this.pos.inside)\n\t             : handleSingleClick(this.view, this.pos.pos, this.pos.inside, event)) {\n\t    event.preventDefault()\n\t  } else if (this.flushed) {\n\t    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(this.pos.pos)), \"pointer\")\n\t    event.preventDefault()\n\t  } else {\n\t    this.view.selectionReader.poll(\"pointer\")\n\t  }\n\t};\n\t\n\tMouseDown.prototype.move = function (event) {\n\t  if (!this.allowDefault && (Math.abs(this.x - event.clientX) > 4 ||\n\t                             Math.abs(this.y - event.clientY) > 4))\n\t    { this.allowDefault = true }\n\t  this.view.selectionReader.poll(\"pointer\")\n\t};\n\t\n\thandlers.touchdown = function (view) {\n\t  forceDOMFlush(view)\n\t  view.selectionReader.poll(\"pointer\")\n\t}\n\t\n\thandlers.contextmenu = function (view, e) {\n\t  forceDOMFlush(view)\n\t  var pos = view.posAtCoords(eventCoords(e))\n\t  if (pos && view.someProp(\"handleContextMenu\", function (f) { return f(view, pos.pos, e); }))\n\t    { e.preventDefault() }\n\t}\n\t\n\t// Input compositions are hard. Mostly because the events fired by\n\t// browsers are A) very unpredictable and inconsistent, and B) not\n\t// cancelable.\n\t//\n\t// ProseMirror has the problem that it must not update the DOM during\n\t// a composition, or the browser will cancel it. What it does is keep\n\t// long-running operations (delayed DOM updates) when a composition is\n\t// active.\n\t//\n\t// We _do not_ trust the information in the composition events which,\n\t// apart from being very uninformative to begin with, is often just\n\t// plain wrong. Instead, when a composition ends, we parse the dom\n\t// around the original selection, and derive an update from that.\n\t\n\teditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n\t  DOMChange.start(view, true)\n\t  if (view.state.storedMarks) { view.inDOMChange.finish(true) }\n\t}\n\t\n\teditHandlers.compositionend = function (view, e) {\n\t  if (!view.inDOMChange) {\n\t    // We received a compositionend without having seen any previous\n\t    // events for the composition. If there's data in the event\n\t    // object, we assume that it's a real change, and start a\n\t    // composition. Otherwise, we just ignore it.\n\t    if (e.data) { DOMChange.start(view, true) }\n\t    else { return }\n\t  }\n\t\n\t  view.inDOMChange.compositionEnd()\n\t}\n\t\n\tvar observeOptions = {childList: true, characterData: true, attributes: true, subtree: true}\n\tfunction startObserving(view) {\n\t  if (view.mutationObserver) { view.mutationObserver.observe(view.content, observeOptions) }\n\t}\n\texports.startObserving = startObserving\n\t\n\tfunction stopObserving(view) {\n\t  if (view.mutationObserver) { view.mutationObserver.disconnect() }\n\t}\n\texports.stopObserving = stopObserving\n\t\n\tfunction registerMutations(view, mutations) {\n\t  if (view.editable) { for (var i = 0; i < mutations.length; i++) {\n\t    var mut = mutations[i], desc = view.docView.nearestDesc(mut.target)\n\t    if (mut.type == \"attributes\" &&\n\t        (desc == view.docView || mut.attributeName == \"contenteditable\")) { continue }\n\t    if (!desc || desc.ignoreMutation(mut)) { continue }\n\t\n\t    var from = (void 0), to = (void 0)\n\t    if (mut.type == \"childList\") {\n\t      var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target\n\t          ? Array.prototype.indexOf.call(mut.target.childNodes, desc.previousSibling) + 1 : 0\n\t      from = desc.localPosFromDOM(mut.target, fromOffset, -1)\n\t      var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target\n\t          ? Array.prototype.indexOf.call(mut.target.childNodes, desc.nextSibling) : mut.target.childNodes.length\n\t      to = desc.localPosFromDOM(mut.target, toOffset, 1)\n\t    } else if (mut.type == \"attributes\") {\n\t      from = desc.posAtStart - desc.border\n\t      to = desc.posAtEnd + desc.border\n\t    } else { // \"characterData\"\n\t      from = desc.posAtStart\n\t      to = desc.posAtEnd\n\t    }\n\t\n\t    DOMChange.start(view)\n\t    view.inDOMChange.addRange(from, to)\n\t  } }\n\t}\n\t\n\teditHandlers.input = function (view) { return DOMChange.start(view); }\n\t\n\thandlers.copy = editHandlers.cut = function (view, e) {\n\t  var sel = view.state.selection, cut = e.type == \"cut\"\n\t  if (sel.empty) { return }\n\t  if (!e.clipboardData || !canUpdateClipboard(e.clipboardData)) {\n\t    if (cut && browser.ie && browser.ie_version <= 11) { DOMChange.start(view) }\n\t    return\n\t  }\n\t  toClipboard(view, sel, e.clipboardData)\n\t  e.preventDefault()\n\t  if (cut) { view.dispatch(view.state.tr.deleteRange(sel.from, sel.to).scrollIntoView()) }\n\t}\n\t\n\tfunction sliceSingleNode(slice) {\n\t  return slice.openLeft == 0 && slice.openRight == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n\t}\n\t\n\teditHandlers.paste = function (view, e) {\n\t  if (!e.clipboardData) {\n\t    if (browser.ie && browser.ie_version <= 11) { DOMChange.start(view) }\n\t    return\n\t  }\n\t  var slice = fromClipboard(view, e.clipboardData, view.shiftKey, view.state.selection.$from)\n\t  if (slice) {\n\t    e.preventDefault()\n\t    view.someProp(\"transformPasted\", function (f) { slice = f(slice) })\n\t    var singleNode = sliceSingleNode(slice)\n\t    var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode) : view.state.tr.replaceSelection(slice)\n\t    view.dispatch(tr.scrollIntoView())\n\t  }\n\t}\n\t\n\tvar Dragging = function(state, slice, range, move) {\n\t  this.slice = slice\n\t  this.range = range\n\t  this.move = move && new TrackMappings(state)\n\t};\n\t\n\tDragging.prototype.destroy = function () {\n\t  if (this.move) { this.move.destroy() }\n\t};\n\t\n\tfunction clearDragging(view) {\n\t  if (view.dragging) {\n\t    view.dragging.destroy()\n\t    view.dragging = null\n\t  }\n\t}\n\t\n\tfunction dropPos(slice, $pos) {\n\t  if (!slice || !slice.content.size) { return $pos.pos }\n\t  var content = slice.content\n\t  for (var i = 0; i < slice.openLeft; i++) { content = content.firstChild.content }\n\t  for (var d = $pos.depth; d >= 0; d--) {\n\t    var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n\t    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n\t    if ($pos.node(d).canReplace(insertPos, insertPos, content))\n\t      { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n\t  }\n\t  return $pos.pos\n\t}\n\t\n\thandlers.dragstart = function (view, e) {\n\t  var mouseDown = view.mouseDown\n\t  if (mouseDown) { mouseDown.done() }\n\t  if (!e.dataTransfer) { return }\n\t\n\t  var sel = view.state.selection, draggedRange\n\t  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e))\n\t  if (pos != null && pos.pos >= sel.from && pos.pos <= sel.to)\n\t    { draggedRange = sel }\n\t  else if (mouseDown && mouseDown.mightDrag)\n\t    { draggedRange = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos) }\n\t\n\t  if (draggedRange) {\n\t    var slice = toClipboard(view, draggedRange, e.dataTransfer)\n\t    view.dragging = new Dragging(view.state, slice, draggedRange, !e.ctrlKey)\n\t  }\n\t}\n\t\n\thandlers.dragend = function (view) {\n\t  window.setTimeout(function () { return clearDragging(view); }, 50)\n\t}\n\t\n\teditHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); }\n\t\n\teditHandlers.drop = function (view, e) {\n\t  var dragging = view.dragging\n\t  clearDragging(view)\n\t\n\t  if (!e.dataTransfer) { return }\n\t\n\t  var $mouse = view.state.doc.resolve(view.posAtCoords(eventCoords(e)).pos)\n\t  if (!$mouse) { return }\n\t  var slice = dragging && dragging.slice || fromClipboard(view, e.dataTransfer, false, $mouse)\n\t  if (!slice) { return }\n\t  var insertPos = dropPos(slice, view.state.doc.resolve($mouse.pos))\n\t\n\t  e.preventDefault()\n\t  var tr = view.state.tr\n\t  if (dragging && dragging.move) {\n\t    var ref = dragging.range;\n\t    var from = ref.from;\n\t    var to = ref.to;\n\t    var mapping = dragging.move.getMapping(view.state)\n\t    if (mapping) { tr.deleteRange(mapping.map(from, 1), mapping.map(to, -1)) }\n\t  }\n\t  view.someProp(\"transformPasted\", function (f) { slice = f(slice) })\n\t  var pos = tr.mapping.map(insertPos)\n\t  var isNode = slice.openLeft == 0 && slice.openRight == 0 && slice.content.childCount == 1\n\t  if (isNode)\n\t    { tr.replaceRangeWith(pos, pos, slice.content.firstChild) }\n\t  else\n\t    { tr.replaceRange(pos, pos, slice) }\n\t  var $pos = tr.doc.resolve(pos)\n\t  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n\t      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild))\n\t    { tr.setSelection(new NodeSelection($pos)) }\n\t  else\n\t    { tr.setSelection(Selection.between($pos, tr.doc.resolve(tr.mapping.map(insertPos)))) }\n\t  view.focus()\n\t  view.dispatch(tr)\n\t}\n\t\n\thandlers.focus = function (view, event) {\n\t  if (!view.focused) {\n\t    view.content.classList.add(\"ProseMirror-focused\")\n\t    view.focused = true\n\t  }\n\t  view.someProp(\"onFocus\", function (f) { f(view, event) })\n\t}\n\t\n\thandlers.blur = function (view, event) {\n\t  if (view.focused) {\n\t    view.content.classList.remove(\"ProseMirror-focused\")\n\t    view.focused = false\n\t  }\n\t  view.someProp(\"onBlur\", function (f) { f(view, event) })\n\t}\n\t\n\t// Make sure all handlers get registered\n\tfor (var prop in editHandlers) { handlers[prop] = editHandlers[prop] }\n\n\n/***/ },\n/* 160 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(2);\n\tvar Selection = ref.Selection;\n\tvar NodeSelection = ref.NodeSelection;\n\t\n\tvar browser = __webpack_require__(18)\n\t\n\t// Track the state of the current editor selection. Keeps the editor\n\t// selection in sync with the DOM selection by polling for changes,\n\t// as there is no DOM event for DOM selection changes.\n\tvar SelectionReader = function(view) {\n\t  var this$1 = this;\n\t\n\t  this.view = view\n\t\n\t  // Track the state of the DOM selection.\n\t  this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null\n\t  this.lastSelection = view.state.selection\n\t  this.poller = poller(this)\n\t\n\t  view.content.addEventListener(\"focus\", function () { return this$1.poller.start(); })\n\t  view.content.addEventListener(\"blur\", function () { return this$1.poller.stop(); })\n\t\n\t  if (!view.editable) { this.poller.start() }\n\t};\n\t\n\tSelectionReader.prototype.destroy = function () { this.poller.stop() };\n\t\n\tSelectionReader.prototype.poll = function (origin) { this.poller.poll(origin) };\n\t\n\tSelectionReader.prototype.editableChanged = function () {\n\t  if (!this.view.editable) { this.poller.start() }\n\t  else if (!this.view.hasFocus()) { this.poller.stop() }\n\t};\n\t\n\t// : () → bool\n\t// Whether the DOM selection has changed from the last known state.\n\tSelectionReader.prototype.domChanged = function () {\n\t  var sel = this.view.root.getSelection()\n\t  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t    sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset\n\t};\n\t\n\t// Store the current state of the DOM selection.\n\tSelectionReader.prototype.storeDOMState = function (selection) {\n\t  var sel = this.view.root.getSelection()\n\t  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset\n\t  this.lastHeadNode = sel.focusNode; this.lastHeadOffset = sel.focusOffset\n\t  this.lastSelection = selection\n\t};\n\t\n\t// : (?string) → bool\n\t// When the DOM selection changes in a notable manner, modify the\n\t// current selection state to match.\n\tSelectionReader.prototype.readFromDOM = function (origin) {\n\t  if (!this.view.hasFocus() || this.view.inDOMChange || !this.domChanged()) { return }\n\t\n\t  var domSel = this.view.root.getSelection(), doc = this.view.state.doc\n\t  var nearestDesc = this.view.docView.nearestDesc(domSel.focusNode)\n\t  // If the selection is in a non-document part of the view, ignore it\n\t  if (!nearestDesc.size) {\n\t    this.storeDOMState()\n\t    return\n\t  }\n\t  var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)\n\t  var $head = doc.resolve(head), $anchor, selection\n\t  if (domSel.isCollapsed) {\n\t    $anchor = $head\n\t    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent }\n\t    if (nearestDesc && nearestDesc.node.isLeaf && NodeSelection.isSelectable(nearestDesc.node)) {\n\t      var pos = nearestDesc.posAtStart\n\t      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos))\n\t    }\n\t  } else {\n\t    $anchor = doc.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset))\n\t  }\n\t\n\t  if (!selection) {\n\t    var bias = this.view.state.selection.head != null && this.view.state.selection.head < $head.pos ? 1 : -1\n\t    selection = Selection.between($anchor, $head, bias)\n\t    if (bias == -1 && selection.node)\n\t      { selection = Selection.between($anchor, $head, 1) }\n\t  }\n\t  if ($head.pos == selection.head && $anchor.pos == selection.anchor)\n\t    { this.storeDOMState(selection) }\n\t  var tr = this.view.state.tr.setSelection(selection)\n\t  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true) }\n\t  this.view.dispatch(tr)\n\t};\n\texports.SelectionReader = SelectionReader\n\t\n\t// There's two polling models. On browsers that support the\n\t// selectionchange event (everything except Firefox, basically), we\n\t// register a listener for that whenever the editor is focused.\n\tvar SelectionChangePoller = function(reader) {\n\t  var this$1 = this;\n\t\n\t  this.listening = false\n\t  this.curOrigin = null\n\t  this.originTime = 0\n\t\n\t  this.readFunc = function () { return reader.readFromDOM(this$1.originTime > Date.now() - 50 ? this$1.curOrigin : null); }\n\t};\n\t\n\tSelectionChangePoller.prototype.poll = function (origin) {\n\t  this.curOrigin = origin\n\t  this.originTime = Date.now()\n\t};\n\t\n\tSelectionChangePoller.prototype.start = function () {\n\t  if (!this.listening) {\n\t    document.addEventListener(\"selectionchange\", this.readFunc)\n\t    this.listening = true\n\t  }\n\t};\n\t\n\tSelectionChangePoller.prototype.stop = function () {\n\t  if (this.listening) {\n\t    document.removeEventListener(\"selectionchange\", this.readFunc)\n\t    this.listening = false\n\t  }\n\t};\n\t\n\t// On Firefox, we use timeout-based polling.\n\tvar TimeoutPoller = function(reader) {\n\t  // The timeout ID for the poller when active.\n\t  this.polling = null\n\t  this.reader = reader\n\t  this.pollFunc = this.doPoll.bind(this, null)\n\t};\n\t\n\tTimeoutPoller.prototype.doPoll = function (origin) {\n\t  var view = this.reader.view\n\t  if (view.focused || !view.editable) {\n\t    this.reader.readFromDOM(origin)\n\t    this.polling = setTimeout(this.pollFunc, 100)\n\t  } else {\n\t    this.polling = null\n\t  }\n\t};\n\t\n\tTimeoutPoller.prototype.poll = function (origin) {\n\t  clearTimeout(this.polling)\n\t  this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0)\n\t};\n\t\n\tTimeoutPoller.prototype.start = function () {\n\t  if (this.polling == null) { this.poll() }\n\t};\n\t\n\tTimeoutPoller.prototype.stop = function () {\n\t  clearTimeout(this.polling)\n\t  this.polling = null\n\t};\n\t\n\tfunction poller(reader) {\n\t  return new (\"onselectionchange\" in document ? SelectionChangePoller : TimeoutPoller)(reader)\n\t}\n\t\n\tfunction selectionToDOM(view, sel, takeFocus) {\n\t  syncNodeSelection(view, sel)\n\t\n\t  if (!view.hasFocus()) {\n\t    if (!takeFocus) { return }\n\t    // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n\t    else if (browser.gecko && view.editable) { view.content.focus() }\n\t  }\n\t\n\t  var reader = view.selectionReader\n\t  if (sel == reader.lastSelection && !reader.domChanged()) { return }\n\t  var anchor = sel.anchor;\n\t  var head = sel.head;\n\t  var resetEditable\n\t  if (anchor == null) {\n\t    anchor = sel.from\n\t    head = sel.to\n\t    if (browser.webkit && sel.node.isBlock) {\n\t      var desc = view.docView.descAt(sel.from)\n\t      if (!desc.contentDOM && desc.dom.contentEditable == \"false\") {\n\t        resetEditable = desc.dom\n\t        desc.dom.contentEditable = \"true\"\n\t      }\n\t    }\n\t  }\n\t  view.docView.setSelection(anchor, head, view.root)\n\t  if (resetEditable) { resetEditable.contentEditable = \"false\" }\n\t  reader.storeDOMState(sel)\n\t}\n\texports.selectionToDOM = selectionToDOM\n\t\n\tfunction syncNodeSelection(view, sel) {\n\t  if (sel instanceof NodeSelection) {\n\t    var desc = view.docView.descAt(sel.from)\n\t    if (desc != view.lastSelectedViewDesc) {\n\t      clearNodeSelection(view)\n\t      if (desc) { desc.selectNode() }\n\t      view.lastSelectedViewDesc = desc\n\t    }\n\t  } else {\n\t    clearNodeSelection(view)\n\t  }\n\t}\n\t\n\t// Clear all DOM statefulness of the last node selection.\n\tfunction clearNodeSelection(view) {\n\t  if (view.lastSelectedViewDesc) {\n\t    view.lastSelectedViewDesc.deselectNode()\n\t    view.lastSelectedViewDesc = null\n\t  }\n\t}\n\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ref = __webpack_require__(1);\n\tvar DOMSerializer = ref.DOMSerializer;\n\t\n\tvar browser = __webpack_require__(18)\n\t\n\t// NodeView:: interface\n\t//\n\t// By default, document nodes are rendered using the result of the\n\t// [`toDOM`](#view.NodeSpec.toDOM) method of their spec, and managed\n\t// entirely by the editor. For some use cases, such as embedded\n\t// node-specific editing interfaces, when you need more control over\n\t// the behavior of a node's in-editor representation, and can\n\t// [define](#view.EditorProps.nodeViews) a custom node view.\n\t//\n\t//   dom:: ?dom.Node\n\t//   The outer DOM node that represents the document node. When not\n\t//   given, the default strategy is used to create a DOM node.\n\t//\n\t//   contentDOM:: ?dom.Node\n\t//   The DOM node that should hold the node's content. Only meaningful\n\t//   if the node view also defines a `dom` property and if its node\n\t//   type is not a leaf node type. When this is present, ProseMirror\n\t//   will take care of rendering the node's children into it. When it\n\t//   is not present, the node view itself is responsible for rendering\n\t//   (or deciding not to render) its child nodes.\n\t//\n\t//   update:: ?(node: Node, decorations: [Decoration]) → bool\n\t//   When given, this will be called when the view is updating itself.\n\t//   It will be given a node (possibly of a different type), and an\n\t//   array of active decorations (which are automatically drawn, and\n\t//   the node view may ignore if it isn't interested in them), and\n\t//   should return true if it was able to update to that node, and\n\t//   false otherwise. If the node view has a `contentDOM` property (or\n\t//   no `dom` property), updating its child nodes will be handled by\n\t//   ProseMirror.\n\t//\n\t//   selectNode:: ?()\n\t//   Can be used to override the way the node's selected status (as a\n\t//   node selection) is displayed.\n\t//\n\t//   deselectNode:: ?()\n\t//   When defining a `selectNode` method, you should also provide a\n\t//   `deselectNode` method to disable it again.\n\t//\n\t//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n\t//   This will be called to handle setting the selection inside the\n\t//   node. By default, a DOM selection will be created between the DOM\n\t//   positions corresponding to the given anchor and head positions,\n\t//   but if you override it you can do something else.\n\t//\n\t//   stopEvent:: ?(event: dom.Event) → bool\n\t//   Can be used to prevent the editor view from trying to handle some\n\t//   or all DOM events that bubble up from the node view.\n\t//\n\t//   ignoreMutation:: ?(dom.MutationRecord) → bool\n\t//   Called when a DOM\n\t//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n\t//   happens within the view. Return false if the editor should\n\t//   re-parse the range around the mutation, true if it can safely be\n\t//   ignored.\n\t//\n\t//   destroy:: ?()\n\t//   Called when the node view is removed from the editor or the whole\n\t//   editor is detached.\n\t\n\t// View descriptions are data structures that describe the DOM that is\n\t// used to represent the editor's content. They are used for:\n\t//\n\t// - Incremental redrawing when the document changes\n\t//\n\t// - Figuring out what part of the document a given DOM position\n\t//   corresponds to\n\t//\n\t// - Wiring in custom implementations of the editing interface for a\n\t//   given node\n\t//\n\t// They form a doubly-linked mutable tree, starting at `view.docView`.\n\t\n\tvar NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3\n\t\n\t// Superclass for the various kinds of descriptions. Defines their\n\t// basic structure and shared methods.\n\tvar ViewDesc = function(parent, children, dom, contentDOM) {\n\t  this.parent = parent\n\t  this.children = children\n\t  this.dom = dom\n\t  // An expando property on the DOM node provides a link back to its\n\t  // description.\n\t  dom.pmViewDesc = this\n\t  // This is the node that holds the child views. It may be null for\n\t  // descs that don't have children.\n\t  this.contentDOM = contentDOM\n\t  this.dirty = NOT_DIRTY\n\t};\n\t\n\tvar prototypeAccessors = { size: {},border: {},posAtStart: {},posAtEnd: {} };\n\t\n\t// Used to check whether a given description corresponds to a\n\t// widget/mark/node.\n\tViewDesc.prototype.matchesWidget = function () { return false };\n\tViewDesc.prototype.matchesMark = function () { return false };\n\tViewDesc.prototype.matchesNode = function () { return false };\n\tViewDesc.prototype.matchesHack = function () { return false };\n\t\n\t// : () → ?ParseRule\n\t// When parsing in-editor content (in domchange.js), we allow\n\t// descriptions to determine the parse rules that should be used to\n\t// parse them.\n\tViewDesc.prototype.parseRule = function () { return null };\n\t\n\t// : (dom.Event) → bool\n\t// Used by the editor's event handler to ignore events that come\n\t// from certain descs.\n\tViewDesc.prototype.stopEvent = function () { return false };\n\t\n\t// The size of the content represented by this desc.\n\tprototypeAccessors.size.get = function () {\n\t    var this$1 = this;\n\t\n\t  var size = 0\n\t  for (var i = 0; i < this.children.length; i++) { size += this$1.children[i].size }\n\t  return size\n\t};\n\t\n\t// For block nodes, this represents the space taken up by their\n\t// start/end tokens.\n\tprototypeAccessors.border.get = function () { return 0 };\n\t\n\tViewDesc.prototype.destroy = function () {\n\t    var this$1 = this;\n\t\n\t  this.parent = this.dom.pmViewDesc = null\n\t  for (var i = 0; i < this.children.length; i++)\n\t    { this$1.children[i].destroy() }\n\t};\n\t\n\tViewDesc.prototype.posBeforeChild = function (child) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n\t    var cur = this$1.children[i]\n\t    if (cur == child) { return pos }\n\t    pos += cur.size\n\t  }\n\t};\n\t\n\tprototypeAccessors.posAtStart.get = function () {\n\t  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n\t};\n\t\n\tprototypeAccessors.posAtEnd.get = function () {\n\t  return this.posAtStart + this.size - 2 * this.border\n\t};\n\t\n\t// : (dom.Node, number, ?number) → number\n\tViewDesc.prototype.localPosFromDOM = function (dom, offset, bias) {\n\t    var this$1 = this;\n\t\n\t  // If the DOM position is in the content, use the child desc after\n\t  // it to figure out a position.\n\t  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n\t    if (bias < 0) {\n\t      var domBefore, desc\n\t      if (dom == this.contentDOM) {\n\t        domBefore = dom.childNodes[offset - 1]\n\t      } else {\n\t        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode }\n\t        domBefore = dom.previousSibling\n\t      }\n\t      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling }\n\t      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n\t    } else {\n\t      var domAfter, desc$1\n\t      if (dom == this.contentDOM) {\n\t        domAfter = dom.childNodes[offset]\n\t      } else {\n\t        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode }\n\t        domAfter = dom.nextSibling\n\t      }\n\t      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling }\n\t      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd\n\t    }\n\t  }\n\t  // Otherwise, use various heuristics, falling back on the bias\n\t  // parameter, to determine whether to return the position at the\n\t  // start or at the end of this view desc.\n\t  var atEnd\n\t  if (this.contentDOM) {\n\t    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2\n\t  } else if (this.dom.firstChild) {\n\t    if (offset == 0) { for (var search = dom;; search = search.parentNode) {\n\t      if (search == this$1.dom) { atEnd = false; break }\n\t      if (search.parentNode.firstChild != search) { break }\n\t    } }\n\t    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {\n\t      if (search$1 == this$1.dom) { atEnd = true; break }\n\t      if (search$1.parentNode.lastChild != search$1) { break }\n\t    } }\n\t  }\n\t  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n\t};\n\t\n\t// Scan up the dom finding the first desc that is a descendant of\n\t// this one.\n\tViewDesc.prototype.nearestDesc = function (dom, onlyNodes) {\n\t    var this$1 = this;\n\t\n\t  for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n\t    var desc = this$1.getDesc(cur)\n\t    if (desc && (!onlyNodes || desc.node)) {\n\t      if (first && desc.nodeDOM && !desc.nodeDOM.contains(dom)) { first = false }\n\t      else { return desc }\n\t    }\n\t  }\n\t};\n\t\n\tViewDesc.prototype.getDesc = function (dom) {\n\t    var this$1 = this;\n\t\n\t  var desc = dom.pmViewDesc\n\t  for (var cur = desc; cur; cur = cur.parent) { if (cur == this$1) { return desc } }\n\t};\n\t\n\tViewDesc.prototype.posFromDOM = function (dom, offset, bias) {\n\t    var this$1 = this;\n\t\n\t  for (var scan = dom;; scan = scan.parentNode) {\n\t    var desc = this$1.getDesc(scan)\n\t    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }\n\t  }\n\t};\n\t\n\t// : (number) → ?NodeViewDesc\n\t// Find the desc for the node after the given pos, if any. (When a\n\t// parent node overrode rendering, there might not be one.)\n\tViewDesc.prototype.descAt = function (pos) {\n\t    var this$1 = this;\n\t\n\t  for (var i = 0, offset = 0; i < this.children.length; i++) {\n\t    var child = this$1.children[i], end = offset + child.size\n\t    if (offset == pos && end != offset) {\n\t      while (!child.border && child.children.length) { child = child.children[0] }\n\t      return child\n\t    }\n\t    if (pos < end) { return child.descAt(pos - offset - child.border) }\n\t    offset = end\n\t  }\n\t};\n\t\n\t// : (number, ?bool) → {node: dom.Node, offset: number}\n\tViewDesc.prototype.domFromPos = function (pos, searchDOM) {\n\t    var this$1 = this;\n\t\n\t  if (!this.contentDOM) { return {node: this.dom, offset: 0} }\n\t  for (var offset = 0, i = 0;; i++) {\n\t    if (offset == pos)\n\t      { return {node: this$1.contentDOM,\n\t              offset: searchDOM ? this$1.findDOMOffset(i, searchDOM) : i} }\n\t    if (i == this$1.children.length) { throw new Error(\"Invalid position \" + pos) }\n\t    var child = this$1.children[i], end = offset + child.size\n\t    if (pos < end) { return child.domFromPos(pos - offset - child.border, searchDOM) }\n\t    offset = end\n\t  }\n\t};\n\t\n\t// If the DOM was directly edited, we can't trust the child view\n\t// desc offsets anymore, so we search the actual DOM to figure out\n\t// the offset that corresponds to a given child.\n\tViewDesc.prototype.findDOMOffset = function (i, searchDOM) {\n\t    var this$1 = this;\n\t\n\t  var content = this.contentDOM\n\t  if (searchDOM < 0) {\n\t    for (var j = i - 1; j >= 0; j--) {\n\t      var child = this$1.children[j]\n\t      if (!child.size) { continue }\n\t      var found = Array.prototype.indexOf.call(content.childNodes, child.dom)\n\t      if (found > -1) { return found + 1 }\n\t    }\n\t    return 0\n\t  } else {\n\t    for (var j$1 = i; j$1 < this.children.length; j$1++) {\n\t      var child$1 = this$1.children[j$1]\n\t      if (!child$1.size) { continue }\n\t      var found$1 = Array.prototype.indexOf.call(content.childNodes, child$1.dom)\n\t      if (found$1 > -1) { return found$1 }\n\t    }\n\t    return content.childNodes.length\n\t  }\n\t};\n\t\n\t// : (number) → dom.Node\n\tViewDesc.prototype.domAfterPos = function (pos) {\n\t  var ref = this.domFromPos(pos);\n\t    var node = ref.node;\n\t    var offset = ref.offset;\n\t  if (node.nodeType != 1 || offset == node.childNodes.length)\n\t    { throw new RangeError(\"No node after pos \" + pos) }\n\t  return node.childNodes[offset]\n\t};\n\t\n\t// : (number, number, dom.Document)\n\t// View descs are responsible for setting any selection that falls\n\t// entirely inside of them, so that custom implementations can do\n\t// custom things with the selection. Note that this falls apart when\n\t// a selection starts in such a node and ends in another, in which\n\t// case we just use whatever domFromPos produces as a best effort.\n\tViewDesc.prototype.setSelection = function (anchor, head, root) {\n\t    var this$1 = this;\n\t\n\t  // If the selection falls entirely in a child, give it to that child\n\t  var from = Math.min(anchor, head), to = Math.max(anchor, head)\n\t  for (var i = 0, offset = 0; i < this.children.length; i++) {\n\t    var child = this$1.children[i], end = offset + child.size\n\t    if (from > offset && to < end)\n\t      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root) }\n\t    offset = end\n\t  }\n\t\n\t  var anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head)\n\t  var domSel = root.getSelection(), range = document.createRange()\n\t\n\t  // Selection.extend can be used to create an 'inverted' selection\n\t  // (one where the focus is before the anchor), but not all\n\t  // browsers support it yet.\n\t  if (domSel.extend) {\n\t    range.setEnd(anchorDOM.node, anchorDOM.offset)\n\t    range.collapse(false)\n\t  } else {\n\t    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp }\n\t    range.setEnd(headDOM.node, headDOM.offset)\n\t    range.setStart(anchorDOM.node, anchorDOM.offset)\n\t  }\n\t  domSel.removeAllRanges()\n\t  domSel.addRange(range)\n\t  if (domSel.extend)\n\t    { domSel.extend(headDOM.node, headDOM.offset) }\n\t};\n\t\n\t// : (dom.MutationRecord) → bool\n\tViewDesc.prototype.ignoreMutation = function (_mutation) {\n\t  return !this.contentDOM\n\t};\n\t\n\t// Remove a subtree of the element tree that has been touched\n\t// by a DOM change, so that the next update will redraw it.\n\tViewDesc.prototype.markDirty = function (from, to) {\n\t    var this$1 = this;\n\t\n\t  for (var offset = 0, i = 0; i < this.children.length; i++) {\n\t    var child = this$1.children[i], end = offset + child.size\n\t    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n\t      var startInside = offset + child.border, endInside = end - child.border\n\t      if (from >= startInside && to <= endInside) {\n\t        this$1.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY\n\t        child.markDirty(from - startInside, to - startInside)\n\t        return\n\t      } else {\n\t        child.dirty = NODE_DIRTY\n\t      }\n\t    }\n\t    offset = end\n\t  }\n\t  this.dirty = CONTENT_DIRTY\n\t};\n\t\n\tObject.defineProperties( ViewDesc.prototype, prototypeAccessors );\n\t\n\t// Reused array to avoid allocating fresh arrays for things that will\n\t// stay empty anyway.\n\tvar nothing = []\n\t\n\t// A widget desc represents a widget decoration, which is a DOM node\n\t// drawn between the document nodes.\n\tvar WidgetViewDesc = (function (ViewDesc) {\n\t  function WidgetViewDesc(parent, widget) {\n\t    ViewDesc.call(this, parent, nothing, widget.type.widget, null)\n\t    this.widget = widget\n\t  }\n\t\n\t  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;\n\t  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n\t  WidgetViewDesc.prototype.constructor = WidgetViewDesc;\n\t\n\t  WidgetViewDesc.prototype.matchesWidget = function (widget) { return this.dirty == NOT_DIRTY && widget.type == this.widget.type };\n\t\n\t  WidgetViewDesc.prototype.parseRule = function () { return {ignore: true} };\n\t\n\t  WidgetViewDesc.prototype.stopEvent = function (event) {\n\t    var stop = this.widget.type.options.stopEvent\n\t    return stop ? stop(event) : false\n\t  };\n\t\n\t  return WidgetViewDesc;\n\t}(ViewDesc));\n\t\n\t// A mark desc represents a mark. May have multiple children,\n\t// depending on how the mark is split. Note that marks are drawn using\n\t// a fixed nesting order, for simplicity and predictability, so in\n\t// some cases they will be split more often than would appear\n\t// necessary.\n\tvar MarkViewDesc = (function (ViewDesc) {\n\t  function MarkViewDesc(parent, mark, dom) {\n\t    ViewDesc.call(this, parent, [], dom, dom)\n\t    this.mark = mark\n\t  }\n\t\n\t  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;\n\t  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n\t  MarkViewDesc.prototype.constructor = MarkViewDesc;\n\t\n\t  MarkViewDesc.create = function (parent, mark, view) {\n\t    var custom = customNodeViews(view)[mark.type.name]\n\t    var spec = custom && custom(mark, view)\n\t    var dom = spec && spec.dom || DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark)).dom\n\t    return new MarkViewDesc(parent, mark, dom)\n\t  };\n\t\n\t  MarkViewDesc.prototype.parseRule = function () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };\n\t\n\t  MarkViewDesc.prototype.matchesMark = function (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };\n\t\n\t  return MarkViewDesc;\n\t}(ViewDesc));\n\t\n\t// Node view descs are the main, most common type of view desc, and\n\t// correspond to an actual node in the document. Unlike mark descs,\n\t// they populate their child array themselves.\n\tvar NodeViewDesc = (function (ViewDesc) {\n\t  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view) {\n\t    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM)\n\t    this.nodeDOM = nodeDOM\n\t    this.node = node\n\t    this.outerDeco = outerDeco\n\t    this.innerDeco = innerDeco\n\t    if (contentDOM) { this.updateChildren(view) }\n\t  }\n\t\n\t  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;\n\t  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n\t  NodeViewDesc.prototype.constructor = NodeViewDesc;\n\t\n\t  var prototypeAccessors$1 = { size: {},border: {} };\n\t\n\t  // By default, a node is rendered using the `toDOM` method from the\n\t  // node type spec. But client code can use the `nodeViews` spec to\n\t  // supply a custom node view, which can influence various aspects of\n\t  // the way the node works.\n\t  //\n\t  // (Using subclassing for this was intentionally decided against,\n\t  // since it'd require exposing a whole slew of finnicky\n\t  // implementation details to the user code that they probably will\n\t  // never need.)\n\t  NodeViewDesc.create = function (parent, node, outerDeco, innerDeco, view) {\n\t    var custom = customNodeViews(view)[node.type.name], descObj\n\t    var spec = custom && custom(node, view, function () {\n\t      // (This is a function that allows the custom view to find its\n\t      // own position)\n\t      if (descObj && descObj.parent) { return descObj.parent.posBeforeChild(descObj) }\n\t    }, outerDeco)\n\t\n\t    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM\n\t    if (!dom) { var assign;\n\t      ((assign = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM)) }\n\t    if (!contentDOM && !node.isText) { dom.contentEditable = false }\n\t\n\t    var nodeDOM = dom\n\t    dom = applyOuterDeco(dom, outerDeco, node)\n\t\n\t    if (spec)\n\t      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) }\n\t    else if (node.isText)\n\t      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }\n\t    else\n\t      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view) }\n\t  };\n\t\n\t  NodeViewDesc.prototype.parseRule = function () { return {node: this.node.type.name, attrs: this.node.attrs, contentElement: this.contentDOM} };\n\t\n\t  NodeViewDesc.prototype.matchesNode = function (node, outerDeco, innerDeco) {\n\t    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n\t      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n\t  };\n\t\n\t  prototypeAccessors$1.size.get = function () { return this.node.nodeSize };\n\t\n\t  prototypeAccessors$1.border.get = function () { return this.node.isLeaf ? 0 : 1 };\n\t\n\t  // Syncs `this.children` to match `this.node.content` and the local\n\t  // decorations, possibly introducing nesting for marks. Then, in a\n\t  // separate step, syncs the DOM inside `this.contentDOM` to\n\t  // `this.children`.\n\t  NodeViewDesc.prototype.updateChildren = function (view) {\n\t    var this$1 = this;\n\t\n\t    var updater = new ViewTreeUpdater(this)\n\t    iterDeco(this.node, this.innerDeco, function (widget) {\n\t      // If the next node is a desc matching this widget, reuse it,\n\t      // otherwise insert the widget as a new view desc.\n\t      updater.placeWidget(widget)\n\t    }, function (child, outerDeco, innerDeco, i) {\n\t      // Make sure the wrapping mark descs match the node's marks.\n\t      updater.syncToMarks(child.marks, view)\n\t      // Either find an existing desc that exactly matches this node,\n\t      // and drop the descs before it.\n\t      updater.findNodeMatch(child, outerDeco, innerDeco) ||\n\t        // Or try updating the next desc to reflect this node.\n\t        updater.updateNextNode(child, outerDeco, innerDeco, view, this$1.node.content, i) ||\n\t        // Or just add it as a new desc.\n\t        updater.addNode(child, outerDeco, innerDeco, view)\n\t    })\n\t    // Drop all remaining descs after the current position.\n\t    updater.syncToMarks(nothing, view)\n\t    if (this.node.isTextblock) { updater.addTextblockHacks() }\n\t    updater.destroyRest()\n\t\n\t    // Sync the DOM if anything changed\n\t    if (updater.changed || this.dirty == CONTENT_DIRTY) { this.renderChildren() }\n\t  };\n\t\n\t  NodeViewDesc.prototype.renderChildren = function () {\n\t    renderDescs(this.contentDOM, this.children, NodeViewDesc.is)\n\t    if (browser.ios) { iosHacks(this.dom) }\n\t  };\n\t\n\t  // : (Node, [Decoration], DecorationSet, EditorView) → bool\n\t  // If this desc be updated to match the given node decoration,\n\t  // do so and return true.\n\t  NodeViewDesc.prototype.update = function (node, outerDeco, innerDeco, view) {\n\t    if (this.dirty == NODE_DIRTY ||\n\t        !node.sameMarkup(this.node)) { return false }\n\t    this.updateOuterDeco(outerDeco)\n\t    this.node = node\n\t    this.innerDeco = innerDeco\n\t    if (!node.isLeaf) { this.updateChildren(view) }\n\t    this.dirty = NOT_DIRTY\n\t    return true\n\t  };\n\t\n\t  NodeViewDesc.prototype.updateOuterDeco = function (outerDeco) {\n\t    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }\n\t    var needsWrap = this.nodeDOM.nodeType != 1\n\t    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n\t                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n\t                              computeOuterDeco(outerDeco, this.node, needsWrap))\n\t    this.outerDeco = outerDeco\n\t  };\n\t\n\t  // Mark this node as being the selected node.\n\t  NodeViewDesc.prototype.selectNode = function () {\n\t    this.nodeDOM.classList.add(\"ProseMirror-selectednode\")\n\t  };\n\t\n\t  // Remove selected node marking from this node.\n\t  NodeViewDesc.prototype.deselectNode = function () {\n\t    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\")\n\t  };\n\t\n\t  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$1 );\n\t\n\t  return NodeViewDesc;\n\t}(ViewDesc));\n\t\n\t// Create a view desc for the top-level document node, to be exported\n\t// and used by the view class.\n\tfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n\t  applyOuterDeco(dom, outerDeco, doc, true)\n\t  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view)\n\t}\n\texports.docViewDesc = docViewDesc\n\t\n\tvar TextViewDesc = (function (NodeViewDesc) {\n\t  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n\t    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view)\n\t  }\n\t\n\t  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;\n\t  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n\t  TextViewDesc.prototype.constructor = TextViewDesc;\n\t\n\t  TextViewDesc.prototype.parseRule = function () {\n\t    return {skip: this.nodeDOM.parentNode}\n\t  };\n\t\n\t  TextViewDesc.prototype.update = function (node, outerDeco) {\n\t    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent) ||\n\t        !node.sameMarkup(this.node)) { return false }\n\t    this.updateOuterDeco(outerDeco)\n\t    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue)\n\t      { this.nodeDOM.nodeValue = node.text }\n\t    this.node = node\n\t    this.dirty = NOT_DIRTY\n\t    return true\n\t  };\n\t\n\t  TextViewDesc.prototype.inParent = function () {\n\t    var parentDOM = this.parent.contentDOM\n\t    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }\n\t    return false\n\t  };\n\t\n\t  TextViewDesc.prototype.domFromPos = function (pos, searchDOM) {\n\t    return {node: this.nodeDOM, offset: searchDOM ? Math.max(pos, this.nodeDOM.nodeValue.length) : pos}\n\t  };\n\t\n\t  TextViewDesc.prototype.localPosFromDOM = function (dom, offset, bias) {\n\t    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }\n\t    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)\n\t  };\n\t\n\t  TextViewDesc.prototype.ignoreMutation = function (mutation) {\n\t    return mutation.type != \"characterData\"\n\t  };\n\t\n\t  return TextViewDesc;\n\t}(NodeViewDesc));\n\t\n\t// A dummy desc used to tag trailing BR or span nodes created to work\n\t// around contentEditable terribleness.\n\tvar BRHackViewDesc = (function (ViewDesc) {\n\t  function BRHackViewDesc () {\n\t    ViewDesc.apply(this, arguments);\n\t  }\n\t\n\t  if ( ViewDesc ) BRHackViewDesc.__proto__ = ViewDesc;\n\t  BRHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n\t  BRHackViewDesc.prototype.constructor = BRHackViewDesc;\n\t\n\t  BRHackViewDesc.prototype.parseRule = function () { return {ignore: true} };\n\t  BRHackViewDesc.prototype.matchesHack = function () { return this.dirty == NOT_DIRTY };\n\t\n\t  return BRHackViewDesc;\n\t}(ViewDesc));\n\t\n\t// A separate subclass is used for customized node views, so that the\n\t// extra checks only have to be made for nodes that are actually\n\t// customized.\n\tvar CustomNodeViewDesc = (function (NodeViewDesc) {\n\t  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) {\n\t    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view)\n\t    this.spec = spec\n\t  }\n\t\n\t  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;\n\t  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n\t  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;\n\t\n\t  // A custom `update` method gets to decide whether the update goes\n\t  // through. If it does, and there's a `contentDOM` node, our logic\n\t  // updates the children.\n\t  CustomNodeViewDesc.prototype.update = function (node, outerDeco, innerDeco, view) {\n\t    if (this.spec.update) {\n\t      var result = this.spec.update(node, outerDeco)\n\t      if (result) {\n\t        this.node = node\n\t        if (this.contentDOM) { this.updateChildren(view) }\n\t      }\n\t      return result\n\t    } else if (!this.contentDOM && !node.isLeaf) {\n\t      return false\n\t    } else {\n\t      return NodeViewDesc.prototype.update.call(this, node, outerDeco, this.contentDOM ? this.innerDeco : innerDeco, view)\n\t    }\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.selectNode = function () {\n\t    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this)\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.deselectNode = function () {\n\t    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this)\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.setSelection = function (anchor, head, root) {\n\t    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root)\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.destroy = function () {\n\t    if (this.spec.destroy) { this.spec.destroy() }\n\t    NodeViewDesc.prototype.destroy.call(this)\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.stopEvent = function (event) {\n\t    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n\t  };\n\t\n\t  CustomNodeViewDesc.prototype.ignoreMutation = function (mutation) {\n\t    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)\n\t  };\n\t\n\t  return CustomNodeViewDesc;\n\t}(NodeViewDesc));\n\t\n\t// : (dom.Node, [ViewDesc])\n\t// Sync the content of the given DOM node with the nodes associated\n\t// with the given array of view descs, recursing into mark descs\n\t// because this should sync the subtree for a whole node at a time.\n\tfunction renderDescs(parentDOM, descs) {\n\t  var dom = parentDOM.firstChild\n\t  for (var i = 0; i < descs.length; i++) {\n\t    var desc = descs[i], childDOM = desc.dom\n\t    if (childDOM.parentNode == parentDOM) {\n\t      while (childDOM != dom) { dom = rm(dom) }\n\t      dom = dom.nextSibling\n\t    } else {\n\t      parentDOM.insertBefore(childDOM, dom)\n\t    }\n\t    if (desc instanceof MarkViewDesc)\n\t      { renderDescs(desc.contentDOM, desc.children) }\n\t  }\n\t  while (dom) { dom = rm(dom) }\n\t}\n\t\n\tvar OuterDecoLevel = function(nodeName) {\n\t  if (nodeName) { this.nodeName = nodeName }\n\t};\n\tOuterDecoLevel.prototype = Object.create(null)\n\t\n\tvar noDeco = [new OuterDecoLevel]\n\t\n\tfunction computeOuterDeco(outerDeco, node, needsWrap) {\n\t  if (outerDeco.length == 0) { return noDeco }\n\t\n\t  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top]\n\t\n\t  for (var i = 0; i < outerDeco.length; i++) {\n\t    var attrs = outerDeco[i].type.attrs, cur = top\n\t    if (!attrs) { continue }\n\t    if (attrs.nodeName)\n\t      { result.push(cur = new OuterDecoLevel(attrs.nodeName)) }\n\t\n\t    for (var name in attrs) {\n\t      var val = attrs[name]\n\t      if (val == null) { continue }\n\t      if (needsWrap && result.length == 1)\n\t        { result.push(cur = top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\")) }\n\t      if (name == \"class\") { cur.class = (cur.class ? cur.class + \" \" : \"\") + val }\n\t      else if (name == \"style\") { cur.style = (cur.style ? cur.style + \";\" : \"\") + val }\n\t      else if (name != \"nodeName\") { cur[name] = val }\n\t    }\n\t  }\n\t\n\t  return result\n\t}\n\t\n\tfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n\t  // Shortcut for trivial case\n\t  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }\n\t\n\t  var curDOM = nodeDOM\n\t  for (var i = 0; i < curComputed.length; i++) {\n\t    var deco = curComputed[i], prev = prevComputed[i]\n\t    if (i) {\n\t      var parent = (void 0)\n\t      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n\t          (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n\t        curDOM = parent\n\t      } else {\n\t        parent = document.createElement(deco.nodeName)\n\t        parent.appendChild(curDOM)\n\t        curDOM = parent\n\t      }\n\t    }\n\t    patchAttributes(curDOM, prev || noDeco[0], deco)\n\t  }\n\t  return curDOM\n\t}\n\t\n\tfunction patchAttributes(dom, prev, cur) {\n\t  for (var name in prev)\n\t    { if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n\t      { dom.removeAttribute(name) } }\n\t  for (var name$1 in cur)\n\t    { if (name$1 != \"class\" && name$1 != \"style\" && name$1 != \"nodeName\" && cur[name$1] != prev[name$1])\n\t      { dom.setAttribute(name$1, cur[name$1]) } }\n\t  if (prev.class != cur.class) {\n\t    var prevList = prev.class ? prev.class.split(\" \") : nothing\n\t    var curList = cur.class ? cur.class.split(\" \") : nothing\n\t    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)\n\t      { dom.classList.remove(prevList[i]) } }\n\t    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)\n\t      { dom.classList.add(curList[i$1]) } }\n\t  }\n\t  if (prev.style != cur.style) {\n\t    var text = dom.style.cssText, found\n\t    if (prev.style && (found = text.indexOf(prev.style)) > -1)\n\t      { text = text.slice(0, found) + text.slice(found + prev.style.length) }\n\t    dom.style.cssText = text + (cur.style || \"\")\n\t  }\n\t}\n\t\n\tfunction applyOuterDeco(dom, deco, node) {\n\t  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n\t}\n\t\n\t// : ([Decoration], [Decoration]) → bool\n\tfunction sameOuterDeco(a, b) {\n\t  if (a.length != b.length) { return false }\n\t  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }\n\t  return true\n\t}\n\t\n\t// Remove a DOM node and return its next sibling.\n\tfunction rm(dom) {\n\t  var next = dom.nextSibling\n\t  dom.parentNode.removeChild(dom)\n\t  return next\n\t}\n\t\n\t// Helper class for incrementally updating a tree of mark descs and\n\t// the widget and node descs inside of them.\n\tvar ViewTreeUpdater = function(top) {\n\t  this.top = top\n\t  // Index into `this.top`'s child array, represents the current\n\t  // update position.\n\t  this.index = 0\n\t  // When entering a mark, the current top and index are pushed\n\t  // onto this.\n\t  this.stack = []\n\t  // Tracks whether anything was changed\n\t  this.changed = false\n\t};\n\t\n\t// Destroy and remove the children between the given indices in\n\t// `this.top`.\n\tViewTreeUpdater.prototype.destroyBetween = function (start, end) {\n\t    var this$1 = this;\n\t\n\t  if (start == end) { return }\n\t  for (var i = start; i < end; i++) { this$1.top.children[i].destroy() }\n\t  this.top.children.splice(start, end - start)\n\t  this.changed = true\n\t};\n\t\n\t// Destroy all remaining children in `this.top`.\n\tViewTreeUpdater.prototype.destroyRest = function () {\n\t  this.destroyBetween(this.index, this.top.children.length)\n\t};\n\t\n\t// : ([Mark], EditorView)\n\t// Sync the current stack of mark descs with the given array of\n\t// marks, reusing existing mark descs when possible.\n\tViewTreeUpdater.prototype.syncToMarks = function (marks, view) {\n\t    var this$1 = this;\n\t\n\t  var keep = 0, depth = this.stack.length >> 1\n\t  var maxKeep = Math.min(depth, marks.length), next\n\t  while (keep < maxKeep &&\n\t         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]))\n\t    { keep++ }\n\t\n\t  while (keep < depth) {\n\t    this$1.destroyRest()\n\t    this$1.top.dirty = NOT_DIRTY\n\t    this$1.index = this$1.stack.pop()\n\t    this$1.top = this$1.stack.pop()\n\t    depth--\n\t  }\n\t  while (depth < marks.length) {\n\t    this$1.stack.push(this$1.top, this$1.index + 1)\n\t    if (this$1.index < this$1.top.children.length &&\n\t        (next = this$1.top.children[this$1.index]).matchesMark(marks[depth])) {\n\t      this$1.top = next\n\t    } else {\n\t      var markDesc = MarkViewDesc.create(this$1.top, marks[depth], view)\n\t      this$1.top.children.splice(this$1.index, 0, markDesc)\n\t      this$1.top = markDesc\n\t      this$1.changed = true\n\t    }\n\t    this$1.index = 0\n\t    depth++\n\t  }\n\t};\n\t\n\t// : (Node, [Decoration], DecorationSet) → bool\n\t// Try to find a node desc matching the given data. Skip over it and\n\t// return true when successful.\n\tViewTreeUpdater.prototype.findNodeMatch = function (node, outerDeco, innerDeco) {\n\t    var this$1 = this;\n\t\n\t  for (var i = this.index, children = this.top.children, e = Math.min(children.length, i + 5); i < e; i++) {\n\t    if (children[i].matchesNode(node, outerDeco, innerDeco)) {\n\t      this$1.destroyBetween(this$1.index, i)\n\t      this$1.index++\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t};\n\t\n\t// : (Node, [Decoration], DecorationSet, EditorView, Fragment, number) → bool\n\t// Try to update the next node, if any, to the given data. First\n\t// tries scanning ahead in the siblings fragment to see if the next\n\t// node matches any of those, and if so, doesn't touch it, to avoid\n\t// overwriting nodes that could still be used.\n\tViewTreeUpdater.prototype.updateNextNode = function (node, outerDeco, innerDeco, view, siblings, index) {\n\t  if (this.index == this.top.children.length) { return false }\n\t  var next = this.top.children[this.index]\n\t  if (next instanceof NodeViewDesc) {\n\t    for (var i = index + 1, e = Math.min(siblings.childCount, i + 5); i < e; i++)\n\t      { if (next.node == siblings.child(i)) { return false } }\n\t    var nextDOM = next.dom\n\t    if (next.update(node, outerDeco, innerDeco, view)) {\n\t      if (next.dom != nextDOM) { this.changed = true }\n\t      this.index++\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t};\n\t\n\t// : (Node, [Decoration], DecorationSet, EditorView)\n\t// Insert the node as a newly created node desc.\n\tViewTreeUpdater.prototype.addNode = function (node, outerDeco, innerDeco, view) {\n\t  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view))\n\t  this.changed = true\n\t};\n\t\n\tViewTreeUpdater.prototype.placeWidget = function (widget) {\n\t  if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget)) {\n\t    this.index++\n\t  } else {\n\t    this.top.children.splice(this.index++, 0, new WidgetViewDesc(this.top, widget))\n\t    this.changed = true\n\t  }\n\t};\n\t\n\t// Make sure a textblock looks and behaves correctly in\n\t// contentEditable.\n\tViewTreeUpdater.prototype.addTextblockHacks = function () {\n\t  var lastChild = this.top.children[this.index - 1]\n\t  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1] }\n\t\n\t  if (!lastChild || // Empty textblock\n\t      !(lastChild instanceof TextViewDesc) ||\n\t      /\\n$/.test(lastChild.node.text)) {\n\t    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n\t      this.index++\n\t    } else {\n\t      var dom = document.createElement(\"br\")\n\t      this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null))\n\t      this.changed = true\n\t    }\n\t  }\n\t};\n\t\n\t// : (ViewDesc, DecorationSet, (Decoration), (Node, [Decoration], DecorationSet))\n\t// This function abstracts iterating over the nodes and decorations in\n\t// a fragment. Calls `onNode` for each node, with its local and child\n\t// decorations. Splits text nodes when there is a decoration starting\n\t// or ending inside of them. Calls `onWidget` for each widget.\n\tfunction iterDeco(parent, deco, onWidget, onNode) {\n\t  var locals = deco.locals(parent), offset = 0\n\t  // Simple, cheap variant for when there are no local decorations\n\t  if (locals.length == 0) {\n\t    for (var i = 0; i < parent.childCount; i++) {\n\t      var child = parent.child(i)\n\t      onNode(child, locals, deco.forChild(offset, child), i)\n\t      offset += child.nodeSize\n\t    }\n\t    return\n\t  }\n\t\n\t  var decoIndex = 0, active = [], restNode = null\n\t  for (var parentIndex = 0;;) {\n\t    while (decoIndex < locals.length && locals[decoIndex].to == offset)\n\t      { onWidget(locals[decoIndex++]) }\n\t\n\t    var child$1 = (void 0)\n\t    if (restNode) {\n\t      child$1 = restNode\n\t      restNode = null\n\t    } else if (parentIndex < parent.childCount) {\n\t      child$1 = parent.child(parentIndex++)\n\t    } else {\n\t      break\n\t    }\n\t\n\t    for (var i$1 = 0; i$1 < active.length; i$1++) { if (active[i$1].to <= offset) { active.splice(i$1--, 1) } }\n\t    while (decoIndex < locals.length && locals[decoIndex].from == offset) { active.push(locals[decoIndex++]) }\n\t\n\t    var end = offset + child$1.nodeSize\n\t    if (child$1.isText) {\n\t      var cutAt = end\n\t      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from }\n\t      for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to < cutAt) { cutAt = active[i$2].to } }\n\t      if (cutAt < end) {\n\t        restNode = child$1.cut(cutAt - offset)\n\t        child$1 = child$1.cut(0, cutAt - offset)\n\t        end = cutAt\n\t      }\n\t    }\n\t\n\t    onNode(child$1, active.length ? active.slice() : nothing, deco.forChild(offset, child$1), parentIndex - 1)\n\t    offset = end\n\t  }\n\t}\n\t\n\t// Pre-calculate and cache the set of custom view specs for a given\n\t// prop object.\n\tvar cachedCustomViews, cachedCustomFor\n\tfunction customNodeViews(view) {\n\t  if (cachedCustomFor == view.props) { return cachedCustomViews }\n\t  cachedCustomFor = view.props\n\t  return cachedCustomViews = buildCustomViews(view)\n\t}\n\tfunction buildCustomViews(view) {\n\t  var result = {}\n\t  view.someProp(\"nodeViews\", function (obj) {\n\t    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))\n\t      { result[prop] = obj[prop] } }\n\t  })\n\t  return result\n\t}\n\t\n\t// List markers in Mobile Safari will mysteriously disappear\n\t// sometimes. This works around that.\n\tfunction iosHacks(dom) {\n\t  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n\t    var oldCSS = dom.style.cssText\n\t    dom.style.cssText = oldCSS + \"; list-style: square !important\"\n\t    window.getComputedStyle(dom).listStyle\n\t    dom.style.cssText = oldCSS\n\t  }\n\t}\n\n\n/***/ },\n/* 162 */\n/***/ function(module, exports) {\n\n\tvar GOOD_LEAF_SIZE = 200\n\t\n\t// :: class<T> A rope sequence is a persistent sequence data structure\n\t// that supports appending, prepending, and slicing without doing a\n\t// full copy. It is represented as a mostly-balanced tree.\n\tvar RopeSequence = function RopeSequence () {};\n\t\n\tRopeSequence.prototype.append = function append (other) {\n\t  if (!other.length) { return this }\n\t  other = RopeSequence.from(other)\n\t\n\t  return (!this.length && other) ||\n\t    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n\t    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n\t    this.appendInner(other)\n\t};\n\t\n\t// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n\t// Prepend an array or other rope to this one, returning a new rope.\n\tRopeSequence.prototype.prepend = function prepend (other) {\n\t  if (!other.length) { return this }\n\t  return RopeSequence.from(other).append(this)\n\t};\n\t\n\tRopeSequence.prototype.appendInner = function appendInner (other) {\n\t  return new Append(this, other)\n\t};\n\t\n\t// :: (?number, ?number) → RopeSequence<T>\n\t// Create a rope repesenting a sub-sequence of this rope.\n\tRopeSequence.prototype.slice = function slice (from, to) {\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = this.length;\n\t\n\t  if (from >= to) { return RopeSequence.empty }\n\t  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n\t};\n\t\n\t// :: (number) → T\n\t// Retrieve the element at the given position from this rope.\n\tRopeSequence.prototype.get = function get (i) {\n\t  if (i < 0 || i >= this.length) { return undefined }\n\t  return this.getInner(i)\n\t};\n\t\n\t// :: ((element: T, index: number) → ?bool, ?number, ?number)\n\t// Call the given function for each element between the given\n\t// indices. This tends to be more efficient than looping over the\n\t// indices and calling `get`, because it doesn't have to descend the\n\t// tree for every element.\n\tRopeSequence.prototype.forEach = function forEach (f, from, to) {\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = this.length;\n\t\n\t  if (from <= to)\n\t    { this.forEachInner(f, from, to, 0) }\n\t  else\n\t    { this.forEachInvertedInner(f, from, to, 0) }\n\t};\n\t\n\t// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n\t// Map the given functions over the elements of the rope, producing\n\t// a flat array.\n\tRopeSequence.prototype.map = function map (f, from, to) {\n\t    if ( from === void 0 ) from = 0;\n\t    if ( to === void 0 ) to = this.length;\n\t\n\t  var result = []\n\t  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to)\n\t  return result\n\t};\n\t\n\t// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n\t// Create a rope representing the given array, or return the rope\n\t// itself if a rope was given.\n\tRopeSequence.from = function from (values) {\n\t  if (values instanceof RopeSequence) { return values }\n\t  return values && values.length ? new Leaf(values) : RopeSequence.empty\n\t};\n\t\n\tvar Leaf = (function (RopeSequence) {\n\t  function Leaf(values) {\n\t    RopeSequence.call(this)\n\t    this.values = values\n\t  }\n\t\n\t  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n\t  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n\t  Leaf.prototype.constructor = Leaf;\n\t\n\t  var prototypeAccessors = { length: {},depth: {} };\n\t\n\t  Leaf.prototype.flatten = function flatten () {\n\t    return this.values\n\t  };\n\t\n\t  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n\t    if (from == 0 && to == this.length) { return this }\n\t    return new Leaf(this.values.slice(from, to))\n\t  };\n\t\n\t  Leaf.prototype.getInner = function getInner (i) {\n\t    return this.values[i]\n\t  };\n\t\n\t  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n\t    var this$1 = this;\n\t\n\t    for (var i = from; i < to; i++)\n\t      { if (f(this$1.values[i], start + i) === false) { return false } }\n\t  };\n\t\n\t  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n\t    var this$1 = this;\n\t\n\t    for (var i = from - 1; i >= to; i--)\n\t      { if (f(this$1.values[i], start + i) === false) { return false } }\n\t  };\n\t\n\t  Leaf.prototype.leafAppend = function leafAppend (other) {\n\t    if (this.length + other.length <= GOOD_LEAF_SIZE)\n\t      { return new Leaf(this.values.concat(other.flatten())) }\n\t  };\n\t\n\t  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n\t    if (this.length + other.length <= GOOD_LEAF_SIZE)\n\t      { return new Leaf(other.flatten().concat(this.values)) }\n\t  };\n\t\n\t  prototypeAccessors.length.get = function () { return this.values.length };\n\t\n\t  prototypeAccessors.depth.get = function () { return 0 };\n\t\n\t  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\t\n\t  return Leaf;\n\t}(RopeSequence));\n\t\n\t// :: RopeSequence\n\t// The empty rope sequence.\n\tRopeSequence.empty = new Leaf([])\n\t\n\tvar Append = (function (RopeSequence) {\n\t  function Append(left, right) {\n\t    RopeSequence.call(this)\n\t    this.left = left\n\t    this.right = right\n\t    this.length = left.length + right.length\n\t    this.depth = Math.max(left.depth, right.depth) + 1\n\t  }\n\t\n\t  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n\t  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n\t  Append.prototype.constructor = Append;\n\t\n\t  Append.prototype.flatten = function flatten () {\n\t    return this.left.flatten().concat(this.right.flatten())\n\t  };\n\t\n\t  Append.prototype.getInner = function getInner (i) {\n\t    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n\t  };\n\t\n\t  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n\t    var leftLen = this.left.length\n\t    if (from < leftLen &&\n\t        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n\t      { return false }\n\t    if (to > leftLen &&\n\t        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n\t      { return false }\n\t  };\n\t\n\t  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n\t    var leftLen = this.left.length\n\t    if (from > leftLen &&\n\t        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n\t      { return false }\n\t    if (to < leftLen &&\n\t        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n\t      { return false }\n\t  };\n\t\n\t  Append.prototype.sliceInner = function sliceInner (from, to) {\n\t    if (from == 0 && to == this.length) { return this }\n\t    var leftLen = this.left.length\n\t    if (to <= leftLen) { return this.left.slice(from, to) }\n\t    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n\t    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n\t  };\n\t\n\t  Append.prototype.leafAppend = function leafAppend (other) {\n\t    var inner = this.right.leafAppend(other)\n\t    if (inner) { return new Append(this.left, inner) }\n\t  };\n\t\n\t  Append.prototype.leafPrepend = function leafPrepend (other) {\n\t    var inner = this.left.leafPrepend(other)\n\t    if (inner) { return new Append(inner, this.right) }\n\t  };\n\t\n\t  Append.prototype.appendInner = function appendInner (other) {\n\t    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n\t      { return new Append(this.left, new Append(this.right, other)) }\n\t    return new Append(this, other)\n\t  };\n\t\n\t  return Append;\n\t}(RopeSequence));\n\t\n\tmodule.exports = RopeSequence\n\n\n/***/ },\n/* 163 */,\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */,\n/* 175 */,\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */,\n/* 182 */,\n/* 183 */,\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * vue-resource v1.0.3\n\t * https://github.com/vuejs/vue-resource\n\t * Released under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n\t */\n\t\n\tvar RESOLVED = 0;\n\tvar REJECTED = 1;\n\tvar PENDING = 2;\n\t\n\tfunction Promise$1(executor) {\n\t\n\t    this.state = PENDING;\n\t    this.value = undefined;\n\t    this.deferred = [];\n\t\n\t    var promise = this;\n\t\n\t    try {\n\t        executor(function (x) {\n\t            promise.resolve(x);\n\t        }, function (r) {\n\t            promise.reject(r);\n\t        });\n\t    } catch (e) {\n\t        promise.reject(e);\n\t    }\n\t}\n\t\n\tPromise$1.reject = function (r) {\n\t    return new Promise$1(function (resolve, reject) {\n\t        reject(r);\n\t    });\n\t};\n\t\n\tPromise$1.resolve = function (x) {\n\t    return new Promise$1(function (resolve, reject) {\n\t        resolve(x);\n\t    });\n\t};\n\t\n\tPromise$1.all = function all(iterable) {\n\t    return new Promise$1(function (resolve, reject) {\n\t        var count = 0,\n\t            result = [];\n\t\n\t        if (iterable.length === 0) {\n\t            resolve(result);\n\t        }\n\t\n\t        function resolver(i) {\n\t            return function (x) {\n\t                result[i] = x;\n\t                count += 1;\n\t\n\t                if (count === iterable.length) {\n\t                    resolve(result);\n\t                }\n\t            };\n\t        }\n\t\n\t        for (var i = 0; i < iterable.length; i += 1) {\n\t            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\n\t        }\n\t    });\n\t};\n\t\n\tPromise$1.race = function race(iterable) {\n\t    return new Promise$1(function (resolve, reject) {\n\t        for (var i = 0; i < iterable.length; i += 1) {\n\t            Promise$1.resolve(iterable[i]).then(resolve, reject);\n\t        }\n\t    });\n\t};\n\t\n\tvar p$1 = Promise$1.prototype;\n\t\n\tp$1.resolve = function resolve(x) {\n\t    var promise = this;\n\t\n\t    if (promise.state === PENDING) {\n\t        if (x === promise) {\n\t            throw new TypeError('Promise settled with itself.');\n\t        }\n\t\n\t        var called = false;\n\t\n\t        try {\n\t            var then = x && x['then'];\n\t\n\t            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n\t                then.call(x, function (x) {\n\t                    if (!called) {\n\t                        promise.resolve(x);\n\t                    }\n\t                    called = true;\n\t                }, function (r) {\n\t                    if (!called) {\n\t                        promise.reject(r);\n\t                    }\n\t                    called = true;\n\t                });\n\t                return;\n\t            }\n\t        } catch (e) {\n\t            if (!called) {\n\t                promise.reject(e);\n\t            }\n\t            return;\n\t        }\n\t\n\t        promise.state = RESOLVED;\n\t        promise.value = x;\n\t        promise.notify();\n\t    }\n\t};\n\t\n\tp$1.reject = function reject(reason) {\n\t    var promise = this;\n\t\n\t    if (promise.state === PENDING) {\n\t        if (reason === promise) {\n\t            throw new TypeError('Promise settled with itself.');\n\t        }\n\t\n\t        promise.state = REJECTED;\n\t        promise.value = reason;\n\t        promise.notify();\n\t    }\n\t};\n\t\n\tp$1.notify = function notify() {\n\t    var promise = this;\n\t\n\t    nextTick(function () {\n\t        if (promise.state !== PENDING) {\n\t            while (promise.deferred.length) {\n\t                var deferred = promise.deferred.shift(),\n\t                    onResolved = deferred[0],\n\t                    onRejected = deferred[1],\n\t                    resolve = deferred[2],\n\t                    reject = deferred[3];\n\t\n\t                try {\n\t                    if (promise.state === RESOLVED) {\n\t                        if (typeof onResolved === 'function') {\n\t                            resolve(onResolved.call(undefined, promise.value));\n\t                        } else {\n\t                            resolve(promise.value);\n\t                        }\n\t                    } else if (promise.state === REJECTED) {\n\t                        if (typeof onRejected === 'function') {\n\t                            resolve(onRejected.call(undefined, promise.value));\n\t                        } else {\n\t                            reject(promise.value);\n\t                        }\n\t                    }\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            }\n\t        }\n\t    });\n\t};\n\t\n\tp$1.then = function then(onResolved, onRejected) {\n\t    var promise = this;\n\t\n\t    return new Promise$1(function (resolve, reject) {\n\t        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n\t        promise.notify();\n\t    });\n\t};\n\t\n\tp$1.catch = function (onRejected) {\n\t    return this.then(undefined, onRejected);\n\t};\n\t\n\t/**\n\t * Promise adapter.\n\t */\n\t\n\tif (typeof Promise === 'undefined') {\n\t    window.Promise = Promise$1;\n\t}\n\t\n\tfunction PromiseObj(executor, context) {\n\t\n\t    if (executor instanceof Promise) {\n\t        this.promise = executor;\n\t    } else {\n\t        this.promise = new Promise(executor.bind(context));\n\t    }\n\t\n\t    this.context = context;\n\t}\n\t\n\tPromiseObj.all = function (iterable, context) {\n\t    return new PromiseObj(Promise.all(iterable), context);\n\t};\n\t\n\tPromiseObj.resolve = function (value, context) {\n\t    return new PromiseObj(Promise.resolve(value), context);\n\t};\n\t\n\tPromiseObj.reject = function (reason, context) {\n\t    return new PromiseObj(Promise.reject(reason), context);\n\t};\n\t\n\tPromiseObj.race = function (iterable, context) {\n\t    return new PromiseObj(Promise.race(iterable), context);\n\t};\n\t\n\tvar p = PromiseObj.prototype;\n\t\n\tp.bind = function (context) {\n\t    this.context = context;\n\t    return this;\n\t};\n\t\n\tp.then = function (fulfilled, rejected) {\n\t\n\t    if (fulfilled && fulfilled.bind && this.context) {\n\t        fulfilled = fulfilled.bind(this.context);\n\t    }\n\t\n\t    if (rejected && rejected.bind && this.context) {\n\t        rejected = rejected.bind(this.context);\n\t    }\n\t\n\t    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\n\t};\n\t\n\tp.catch = function (rejected) {\n\t\n\t    if (rejected && rejected.bind && this.context) {\n\t        rejected = rejected.bind(this.context);\n\t    }\n\t\n\t    return new PromiseObj(this.promise.catch(rejected), this.context);\n\t};\n\t\n\tp.finally = function (callback) {\n\t\n\t    return this.then(function (value) {\n\t        callback.call(this);\n\t        return value;\n\t    }, function (reason) {\n\t        callback.call(this);\n\t        return Promise.reject(reason);\n\t    });\n\t};\n\t\n\t/**\n\t * Utility functions.\n\t */\n\t\n\tvar debug = false;var util = {};var slice = [].slice;\n\t\n\t\n\tfunction Util (Vue) {\n\t    util = Vue.util;\n\t    debug = Vue.config.debug || !Vue.config.silent;\n\t}\n\t\n\tfunction warn(msg) {\n\t    if (typeof console !== 'undefined' && debug) {\n\t        console.warn('[VueResource warn]: ' + msg);\n\t    }\n\t}\n\t\n\tfunction error(msg) {\n\t    if (typeof console !== 'undefined') {\n\t        console.error(msg);\n\t    }\n\t}\n\t\n\tfunction nextTick(cb, ctx) {\n\t    return util.nextTick(cb, ctx);\n\t}\n\t\n\tfunction trim(str) {\n\t    return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\t\n\tfunction toLower(str) {\n\t    return str ? str.toLowerCase() : '';\n\t}\n\t\n\tfunction toUpper(str) {\n\t    return str ? str.toUpperCase() : '';\n\t}\n\t\n\tvar isArray = Array.isArray;\n\t\n\tfunction isString(val) {\n\t    return typeof val === 'string';\n\t}\n\t\n\tfunction isBoolean(val) {\n\t    return val === true || val === false;\n\t}\n\t\n\tfunction isFunction(val) {\n\t    return typeof val === 'function';\n\t}\n\t\n\tfunction isObject(obj) {\n\t    return obj !== null && typeof obj === 'object';\n\t}\n\t\n\tfunction isPlainObject(obj) {\n\t    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n\t}\n\t\n\tfunction isBlob(obj) {\n\t    return typeof Blob !== 'undefined' && obj instanceof Blob;\n\t}\n\t\n\tfunction isFormData(obj) {\n\t    return typeof FormData !== 'undefined' && obj instanceof FormData;\n\t}\n\t\n\tfunction when(value, fulfilled, rejected) {\n\t\n\t    var promise = PromiseObj.resolve(value);\n\t\n\t    if (arguments.length < 2) {\n\t        return promise;\n\t    }\n\t\n\t    return promise.then(fulfilled, rejected);\n\t}\n\t\n\tfunction options(fn, obj, opts) {\n\t\n\t    opts = opts || {};\n\t\n\t    if (isFunction(opts)) {\n\t        opts = opts.call(obj);\n\t    }\n\t\n\t    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\n\t}\n\t\n\tfunction each(obj, iterator) {\n\t\n\t    var i, key;\n\t\n\t    if (obj && typeof obj.length == 'number') {\n\t        for (i = 0; i < obj.length; i++) {\n\t            iterator.call(obj[i], obj[i], i);\n\t        }\n\t    } else if (isObject(obj)) {\n\t        for (key in obj) {\n\t            if (obj.hasOwnProperty(key)) {\n\t                iterator.call(obj[key], obj[key], key);\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t}\n\t\n\tvar assign = Object.assign || _assign;\n\t\n\tfunction merge(target) {\n\t\n\t    var args = slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t        _merge(target, source, true);\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction defaults(target) {\n\t\n\t    var args = slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t\n\t        for (var key in source) {\n\t            if (target[key] === undefined) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction _assign(target) {\n\t\n\t    var args = slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t        _merge(target, source);\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction _merge(target, source, deep) {\n\t    for (var key in source) {\n\t        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n\t            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n\t                target[key] = {};\n\t            }\n\t            if (isArray(source[key]) && !isArray(target[key])) {\n\t                target[key] = [];\n\t            }\n\t            _merge(target[key], source[key], deep);\n\t        } else if (source[key] !== undefined) {\n\t            target[key] = source[key];\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * Root Prefix Transform.\n\t */\n\t\n\tfunction root (options, next) {\n\t\n\t    var url = next(options);\n\t\n\t    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\n\t        url = options.root + '/' + url;\n\t    }\n\t\n\t    return url;\n\t}\n\t\n\t/**\n\t * Query Parameter Transform.\n\t */\n\t\n\tfunction query (options, next) {\n\t\n\t    var urlParams = Object.keys(Url.options.params),\n\t        query = {},\n\t        url = next(options);\n\t\n\t    each(options.params, function (value, key) {\n\t        if (urlParams.indexOf(key) === -1) {\n\t            query[key] = value;\n\t        }\n\t    });\n\t\n\t    query = Url.params(query);\n\t\n\t    if (query) {\n\t        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n\t    }\n\t\n\t    return url;\n\t}\n\t\n\t/**\n\t * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n\t */\n\t\n\tfunction expand(url, params, variables) {\n\t\n\t    var tmpl = parse(url),\n\t        expanded = tmpl.expand(params);\n\t\n\t    if (variables) {\n\t        variables.push.apply(variables, tmpl.vars);\n\t    }\n\t\n\t    return expanded;\n\t}\n\t\n\tfunction parse(template) {\n\t\n\t    var operators = ['+', '#', '.', '/', ';', '?', '&'],\n\t        variables = [];\n\t\n\t    return {\n\t        vars: variables,\n\t        expand: function (context) {\n\t            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n\t                if (expression) {\n\t\n\t                    var operator = null,\n\t                        values = [];\n\t\n\t                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n\t                        operator = expression.charAt(0);\n\t                        expression = expression.substr(1);\n\t                    }\n\t\n\t                    expression.split(/,/g).forEach(function (variable) {\n\t                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n\t                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n\t                        variables.push(tmp[1]);\n\t                    });\n\t\n\t                    if (operator && operator !== '+') {\n\t\n\t                        var separator = ',';\n\t\n\t                        if (operator === '?') {\n\t                            separator = '&';\n\t                        } else if (operator !== '#') {\n\t                            separator = operator;\n\t                        }\n\t\n\t                        return (values.length !== 0 ? operator : '') + values.join(separator);\n\t                    } else {\n\t                        return values.join(',');\n\t                    }\n\t                } else {\n\t                    return encodeReserved(literal);\n\t                }\n\t            });\n\t        }\n\t    };\n\t}\n\t\n\tfunction getValues(context, operator, key, modifier) {\n\t\n\t    var value = context[key],\n\t        result = [];\n\t\n\t    if (isDefined(value) && value !== '') {\n\t        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n\t            value = value.toString();\n\t\n\t            if (modifier && modifier !== '*') {\n\t                value = value.substring(0, parseInt(modifier, 10));\n\t            }\n\t\n\t            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n\t        } else {\n\t            if (modifier === '*') {\n\t                if (Array.isArray(value)) {\n\t                    value.filter(isDefined).forEach(function (value) {\n\t                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n\t                    });\n\t                } else {\n\t                    Object.keys(value).forEach(function (k) {\n\t                        if (isDefined(value[k])) {\n\t                            result.push(encodeValue(operator, value[k], k));\n\t                        }\n\t                    });\n\t                }\n\t            } else {\n\t                var tmp = [];\n\t\n\t                if (Array.isArray(value)) {\n\t                    value.filter(isDefined).forEach(function (value) {\n\t                        tmp.push(encodeValue(operator, value));\n\t                    });\n\t                } else {\n\t                    Object.keys(value).forEach(function (k) {\n\t                        if (isDefined(value[k])) {\n\t                            tmp.push(encodeURIComponent(k));\n\t                            tmp.push(encodeValue(operator, value[k].toString()));\n\t                        }\n\t                    });\n\t                }\n\t\n\t                if (isKeyOperator(operator)) {\n\t                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n\t                } else if (tmp.length !== 0) {\n\t                    result.push(tmp.join(','));\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        if (operator === ';') {\n\t            result.push(encodeURIComponent(key));\n\t        } else if (value === '' && (operator === '&' || operator === '?')) {\n\t            result.push(encodeURIComponent(key) + '=');\n\t        } else if (value === '') {\n\t            result.push('');\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return value !== undefined && value !== null;\n\t}\n\t\n\tfunction isKeyOperator(operator) {\n\t    return operator === ';' || operator === '&' || operator === '?';\n\t}\n\t\n\tfunction encodeValue(operator, value, key) {\n\t\n\t    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\n\t\n\t    if (key) {\n\t        return encodeURIComponent(key) + '=' + value;\n\t    } else {\n\t        return value;\n\t    }\n\t}\n\t\n\tfunction encodeReserved(str) {\n\t    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n\t        if (!/%[0-9A-Fa-f]/.test(part)) {\n\t            part = encodeURI(part);\n\t        }\n\t        return part;\n\t    }).join('');\n\t}\n\t\n\t/**\n\t * URL Template (RFC 6570) Transform.\n\t */\n\t\n\tfunction template (options) {\n\t\n\t    var variables = [],\n\t        url = expand(options.url, options.params, variables);\n\t\n\t    variables.forEach(function (key) {\n\t        delete options.params[key];\n\t    });\n\t\n\t    return url;\n\t}\n\t\n\t/**\n\t * Service for URL templating.\n\t */\n\t\n\tvar ie = document.documentMode;\n\tvar el = document.createElement('a');\n\t\n\tfunction Url(url, params) {\n\t\n\t    var self = this || {},\n\t        options = url,\n\t        transform;\n\t\n\t    if (isString(url)) {\n\t        options = { url: url, params: params };\n\t    }\n\t\n\t    options = merge({}, Url.options, self.$options, options);\n\t\n\t    Url.transforms.forEach(function (handler) {\n\t        transform = factory(handler, transform, self.$vm);\n\t    });\n\t\n\t    return transform(options);\n\t}\n\t\n\t/**\n\t * Url options.\n\t */\n\t\n\tUrl.options = {\n\t    url: '',\n\t    root: null,\n\t    params: {}\n\t};\n\t\n\t/**\n\t * Url transforms.\n\t */\n\t\n\tUrl.transforms = [template, query, root];\n\t\n\t/**\n\t * Encodes a Url parameter string.\n\t *\n\t * @param {Object} obj\n\t */\n\t\n\tUrl.params = function (obj) {\n\t\n\t    var params = [],\n\t        escape = encodeURIComponent;\n\t\n\t    params.add = function (key, value) {\n\t\n\t        if (isFunction(value)) {\n\t            value = value();\n\t        }\n\t\n\t        if (value === null) {\n\t            value = '';\n\t        }\n\t\n\t        this.push(escape(key) + '=' + escape(value));\n\t    };\n\t\n\t    serialize(params, obj);\n\t\n\t    return params.join('&').replace(/%20/g, '+');\n\t};\n\t\n\t/**\n\t * Parse a URL and return its components.\n\t *\n\t * @param {String} url\n\t */\n\t\n\tUrl.parse = function (url) {\n\t\n\t    if (ie) {\n\t        el.href = url;\n\t        url = el.href;\n\t    }\n\t\n\t    el.href = url;\n\t\n\t    return {\n\t        href: el.href,\n\t        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n\t        port: el.port,\n\t        host: el.host,\n\t        hostname: el.hostname,\n\t        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n\t        search: el.search ? el.search.replace(/^\\?/, '') : '',\n\t        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n\t    };\n\t};\n\t\n\tfunction factory(handler, next, vm) {\n\t    return function (options) {\n\t        return handler.call(vm, options, next);\n\t    };\n\t}\n\t\n\tfunction serialize(params, obj, scope) {\n\t\n\t    var array = isArray(obj),\n\t        plain = isPlainObject(obj),\n\t        hash;\n\t\n\t    each(obj, function (value, key) {\n\t\n\t        hash = isObject(value) || isArray(value);\n\t\n\t        if (scope) {\n\t            key = scope + '[' + (plain || hash ? key : '') + ']';\n\t        }\n\t\n\t        if (!scope && array) {\n\t            params.add(value.name, value.value);\n\t        } else if (hash) {\n\t            serialize(params, value, key);\n\t        } else {\n\t            params.add(key, value);\n\t        }\n\t    });\n\t}\n\t\n\t/**\n\t * XDomain client (Internet Explorer).\n\t */\n\t\n\tfunction xdrClient (request) {\n\t    return new PromiseObj(function (resolve) {\n\t\n\t        var xdr = new XDomainRequest(),\n\t            handler = function (_ref) {\n\t            var type = _ref.type;\n\t\n\t\n\t            var status = 0;\n\t\n\t            if (type === 'load') {\n\t                status = 200;\n\t            } else if (type === 'error') {\n\t                status = 500;\n\t            }\n\t\n\t            resolve(request.respondWith(xdr.responseText, { status: status }));\n\t        };\n\t\n\t        request.abort = function () {\n\t            return xdr.abort();\n\t        };\n\t\n\t        xdr.open(request.method, request.getUrl());\n\t        xdr.timeout = 0;\n\t        xdr.onload = handler;\n\t        xdr.onerror = handler;\n\t        xdr.ontimeout = handler;\n\t        xdr.onprogress = function () {};\n\t        xdr.send(request.getBody());\n\t    });\n\t}\n\t\n\t/**\n\t * CORS Interceptor.\n\t */\n\t\n\tvar ORIGIN_URL = Url.parse(location.href);\n\tvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\n\t\n\tfunction cors (request, next) {\n\t\n\t    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\n\t        request.crossOrigin = true;\n\t    }\n\t\n\t    if (request.crossOrigin) {\n\t\n\t        if (!SUPPORTS_CORS) {\n\t            request.client = xdrClient;\n\t        }\n\t\n\t        delete request.emulateHTTP;\n\t    }\n\t\n\t    next();\n\t}\n\t\n\tfunction crossOrigin(request) {\n\t\n\t    var requestUrl = Url.parse(Url(request));\n\t\n\t    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\n\t}\n\t\n\t/**\n\t * Body Interceptor.\n\t */\n\t\n\tfunction body (request, next) {\n\t\n\t    if (isFormData(request.body)) {\n\t\n\t        request.headers.delete('Content-Type');\n\t    } else if (isObject(request.body) || isArray(request.body)) {\n\t\n\t        if (request.emulateJSON) {\n\t            request.body = Url.params(request.body);\n\t            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');\n\t        } else {\n\t            request.body = JSON.stringify(request.body);\n\t        }\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        Object.defineProperty(response, 'data', {\n\t            get: function () {\n\t                return this.body;\n\t            },\n\t            set: function (body) {\n\t                this.body = body;\n\t            }\n\t        });\n\t\n\t        return response.bodyText ? when(response.text(), function (text) {\n\t\n\t            var type = response.headers.get('Content-Type');\n\t\n\t            if (isString(type) && type.indexOf('application/json') === 0) {\n\t\n\t                try {\n\t                    response.body = JSON.parse(text);\n\t                } catch (e) {\n\t                    response.body = null;\n\t                }\n\t            } else {\n\t                response.body = text;\n\t            }\n\t\n\t            return response;\n\t        }) : response;\n\t    });\n\t}\n\t\n\t/**\n\t * JSONP client.\n\t */\n\t\n\tfunction jsonpClient (request) {\n\t    return new PromiseObj(function (resolve) {\n\t\n\t        var name = request.jsonp || 'callback',\n\t            callback = '_jsonp' + Math.random().toString(36).substr(2),\n\t            body = null,\n\t            handler,\n\t            script;\n\t\n\t        handler = function (_ref) {\n\t            var type = _ref.type;\n\t\n\t\n\t            var status = 0;\n\t\n\t            if (type === 'load' && body !== null) {\n\t                status = 200;\n\t            } else if (type === 'error') {\n\t                status = 500;\n\t            }\n\t\n\t            resolve(request.respondWith(body, { status: status }));\n\t\n\t            delete window[callback];\n\t            document.body.removeChild(script);\n\t        };\n\t\n\t        request.params[name] = callback;\n\t\n\t        window[callback] = function (result) {\n\t            body = JSON.stringify(result);\n\t        };\n\t\n\t        script = document.createElement('script');\n\t        script.src = request.getUrl();\n\t        script.type = 'text/javascript';\n\t        script.async = true;\n\t        script.onload = handler;\n\t        script.onerror = handler;\n\t\n\t        document.body.appendChild(script);\n\t    });\n\t}\n\t\n\t/**\n\t * JSONP Interceptor.\n\t */\n\t\n\tfunction jsonp (request, next) {\n\t\n\t    if (request.method == 'JSONP') {\n\t        request.client = jsonpClient;\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        if (request.method == 'JSONP') {\n\t\n\t            return when(response.json(), function (json) {\n\t\n\t                response.body = json;\n\t\n\t                return response;\n\t            });\n\t        }\n\t    });\n\t}\n\t\n\t/**\n\t * Before Interceptor.\n\t */\n\t\n\tfunction before (request, next) {\n\t\n\t    if (isFunction(request.before)) {\n\t        request.before.call(this, request);\n\t    }\n\t\n\t    next();\n\t}\n\t\n\t/**\n\t * HTTP method override Interceptor.\n\t */\n\t\n\tfunction method (request, next) {\n\t\n\t    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n\t        request.headers.set('X-HTTP-Method-Override', request.method);\n\t        request.method = 'POST';\n\t    }\n\t\n\t    next();\n\t}\n\t\n\t/**\n\t * Header Interceptor.\n\t */\n\t\n\tfunction header (request, next) {\n\t\n\t    var headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[toLower(request.method)]);\n\t\n\t    each(headers, function (value, name) {\n\t        if (!request.headers.has(name)) {\n\t            request.headers.set(name, value);\n\t        }\n\t    });\n\t\n\t    next();\n\t}\n\t\n\t/**\n\t * Timeout Interceptor.\n\t */\n\t\n\tfunction timeout (request, next) {\n\t\n\t    var timeout;\n\t\n\t    if (request.timeout) {\n\t        timeout = setTimeout(function () {\n\t            request.abort();\n\t        }, request.timeout);\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        clearTimeout(timeout);\n\t    });\n\t}\n\t\n\t/**\n\t * XMLHttp client.\n\t */\n\t\n\tfunction xhrClient (request) {\n\t    return new PromiseObj(function (resolve) {\n\t\n\t        var xhr = new XMLHttpRequest(),\n\t            handler = function (event) {\n\t\n\t            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\n\t                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n\t                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\n\t            });\n\t\n\t            each(trim(xhr.getAllResponseHeaders()).split('\\n'), function (row) {\n\t                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\n\t            });\n\t\n\t            resolve(response);\n\t        };\n\t\n\t        request.abort = function () {\n\t            return xhr.abort();\n\t        };\n\t\n\t        if (request.progress) {\n\t            if (request.method === 'GET') {\n\t                xhr.addEventListener('progress', request.progress);\n\t            } else if (/^(POST|PUT)$/i.test(request.method)) {\n\t                xhr.upload.addEventListener('progress', request.progress);\n\t            }\n\t        }\n\t\n\t        xhr.open(request.method, request.getUrl(), true);\n\t\n\t        if ('responseType' in xhr) {\n\t            xhr.responseType = 'blob';\n\t        }\n\t\n\t        if (request.credentials === true) {\n\t            xhr.withCredentials = true;\n\t        }\n\t\n\t        request.headers.forEach(function (value, name) {\n\t            xhr.setRequestHeader(name, value);\n\t        });\n\t\n\t        xhr.timeout = 0;\n\t        xhr.onload = handler;\n\t        xhr.onerror = handler;\n\t        xhr.send(request.getBody());\n\t    });\n\t}\n\t\n\t/**\n\t * Base client.\n\t */\n\t\n\tfunction Client (context) {\n\t\n\t    var reqHandlers = [sendRequest],\n\t        resHandlers = [],\n\t        handler;\n\t\n\t    if (!isObject(context)) {\n\t        context = null;\n\t    }\n\t\n\t    function Client(request) {\n\t        return new PromiseObj(function (resolve) {\n\t\n\t            function exec() {\n\t\n\t                handler = reqHandlers.pop();\n\t\n\t                if (isFunction(handler)) {\n\t                    handler.call(context, request, next);\n\t                } else {\n\t                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\n\t                    next();\n\t                }\n\t            }\n\t\n\t            function next(response) {\n\t\n\t                if (isFunction(response)) {\n\t\n\t                    resHandlers.unshift(response);\n\t                } else if (isObject(response)) {\n\t\n\t                    resHandlers.forEach(function (handler) {\n\t                        response = when(response, function (response) {\n\t                            return handler.call(context, response) || response;\n\t                        });\n\t                    });\n\t\n\t                    when(response, resolve);\n\t\n\t                    return;\n\t                }\n\t\n\t                exec();\n\t            }\n\t\n\t            exec();\n\t        }, context);\n\t    }\n\t\n\t    Client.use = function (handler) {\n\t        reqHandlers.push(handler);\n\t    };\n\t\n\t    return Client;\n\t}\n\t\n\tfunction sendRequest(request, resolve) {\n\t\n\t    var client = request.client || xhrClient;\n\t\n\t    resolve(client(request));\n\t}\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\t/**\n\t * HTTP Headers.\n\t */\n\t\n\tvar Headers = function () {\n\t    function Headers(headers) {\n\t        var _this = this;\n\t\n\t        classCallCheck(this, Headers);\n\t\n\t\n\t        this.map = {};\n\t\n\t        each(headers, function (value, name) {\n\t            return _this.append(name, value);\n\t        });\n\t    }\n\t\n\t    Headers.prototype.has = function has(name) {\n\t        return getName(this.map, name) !== null;\n\t    };\n\t\n\t    Headers.prototype.get = function get(name) {\n\t\n\t        var list = this.map[getName(this.map, name)];\n\t\n\t        return list ? list[0] : null;\n\t    };\n\t\n\t    Headers.prototype.getAll = function getAll(name) {\n\t        return this.map[getName(this.map, name)] || [];\n\t    };\n\t\n\t    Headers.prototype.set = function set(name, value) {\n\t        this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\n\t    };\n\t\n\t    Headers.prototype.append = function append(name, value) {\n\t\n\t        var list = this.getAll(name);\n\t\n\t        if (list.length) {\n\t            list.push(trim(value));\n\t        } else {\n\t            this.set(name, value);\n\t        }\n\t    };\n\t\n\t    Headers.prototype.delete = function _delete(name) {\n\t        delete this.map[getName(this.map, name)];\n\t    };\n\t\n\t    Headers.prototype.forEach = function forEach(callback, thisArg) {\n\t        var _this2 = this;\n\t\n\t        each(this.map, function (list, name) {\n\t            each(list, function (value) {\n\t                return callback.call(thisArg, value, name, _this2);\n\t            });\n\t        });\n\t    };\n\t\n\t    return Headers;\n\t}();\n\t\n\tfunction getName(map, name) {\n\t    return Object.keys(map).reduce(function (prev, curr) {\n\t        return toLower(name) === toLower(curr) ? curr : prev;\n\t    }, null);\n\t}\n\t\n\tfunction normalizeName(name) {\n\t\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t        throw new TypeError('Invalid character in header field name');\n\t    }\n\t\n\t    return trim(name);\n\t}\n\t\n\t/**\n\t * HTTP Response.\n\t */\n\t\n\tvar Response = function () {\n\t    function Response(body, _ref) {\n\t        var url = _ref.url;\n\t        var headers = _ref.headers;\n\t        var status = _ref.status;\n\t        var statusText = _ref.statusText;\n\t        classCallCheck(this, Response);\n\t\n\t\n\t        this.url = url;\n\t        this.ok = status >= 200 && status < 300;\n\t        this.status = status || 0;\n\t        this.statusText = statusText || '';\n\t        this.headers = new Headers(headers);\n\t        this.body = body;\n\t\n\t        if (isString(body)) {\n\t\n\t            this.bodyText = body;\n\t        } else if (isBlob(body)) {\n\t\n\t            this.bodyBlob = body;\n\t\n\t            if (isBlobText(body)) {\n\t                this.bodyText = blobText(body);\n\t            }\n\t        }\n\t    }\n\t\n\t    Response.prototype.blob = function blob() {\n\t        return when(this.bodyBlob);\n\t    };\n\t\n\t    Response.prototype.text = function text() {\n\t        return when(this.bodyText);\n\t    };\n\t\n\t    Response.prototype.json = function json() {\n\t        return when(this.text(), function (text) {\n\t            return JSON.parse(text);\n\t        });\n\t    };\n\t\n\t    return Response;\n\t}();\n\t\n\tfunction blobText(body) {\n\t    return new PromiseObj(function (resolve) {\n\t\n\t        var reader = new FileReader();\n\t\n\t        reader.readAsText(body);\n\t        reader.onload = function () {\n\t            resolve(reader.result);\n\t        };\n\t    });\n\t}\n\t\n\tfunction isBlobText(body) {\n\t    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\n\t}\n\t\n\t/**\n\t * HTTP Request.\n\t */\n\t\n\tvar Request = function () {\n\t    function Request(options) {\n\t        classCallCheck(this, Request);\n\t\n\t\n\t        this.body = null;\n\t        this.params = {};\n\t\n\t        assign(this, options, {\n\t            method: toUpper(options.method || 'GET')\n\t        });\n\t\n\t        if (!(this.headers instanceof Headers)) {\n\t            this.headers = new Headers(this.headers);\n\t        }\n\t    }\n\t\n\t    Request.prototype.getUrl = function getUrl() {\n\t        return Url(this);\n\t    };\n\t\n\t    Request.prototype.getBody = function getBody() {\n\t        return this.body;\n\t    };\n\t\n\t    Request.prototype.respondWith = function respondWith(body, options) {\n\t        return new Response(body, assign(options || {}, { url: this.getUrl() }));\n\t    };\n\t\n\t    return Request;\n\t}();\n\t\n\t/**\n\t * Service for sending network requests.\n\t */\n\t\n\tvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\n\tvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\n\tvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\n\t\n\tfunction Http(options) {\n\t\n\t    var self = this || {},\n\t        client = Client(self.$vm);\n\t\n\t    defaults(options || {}, self.$options, Http.options);\n\t\n\t    Http.interceptors.forEach(function (handler) {\n\t        client.use(handler);\n\t    });\n\t\n\t    return client(new Request(options)).then(function (response) {\n\t\n\t        return response.ok ? response : PromiseObj.reject(response);\n\t    }, function (response) {\n\t\n\t        if (response instanceof Error) {\n\t            error(response);\n\t        }\n\t\n\t        return PromiseObj.reject(response);\n\t    });\n\t}\n\t\n\tHttp.options = {};\n\t\n\tHttp.headers = {\n\t    put: JSON_CONTENT_TYPE,\n\t    post: JSON_CONTENT_TYPE,\n\t    patch: JSON_CONTENT_TYPE,\n\t    delete: JSON_CONTENT_TYPE,\n\t    custom: CUSTOM_HEADERS,\n\t    common: COMMON_HEADERS\n\t};\n\t\n\tHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\n\t\n\t['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\n\t\n\t    Http[method] = function (url, options) {\n\t        return this(assign(options || {}, { url: url, method: method }));\n\t    };\n\t});\n\t\n\t['post', 'put', 'patch'].forEach(function (method) {\n\t\n\t    Http[method] = function (url, body, options) {\n\t        return this(assign(options || {}, { url: url, method: method, body: body }));\n\t    };\n\t});\n\t\n\t/**\n\t * Service for interacting with RESTful services.\n\t */\n\t\n\tfunction Resource(url, params, actions, options) {\n\t\n\t    var self = this || {},\n\t        resource = {};\n\t\n\t    actions = assign({}, Resource.actions, actions);\n\t\n\t    each(actions, function (action, name) {\n\t\n\t        action = merge({ url: url, params: assign({}, params) }, options, action);\n\t\n\t        resource[name] = function () {\n\t            return (self.$http || Http)(opts(action, arguments));\n\t        };\n\t    });\n\t\n\t    return resource;\n\t}\n\t\n\tfunction opts(action, args) {\n\t\n\t    var options = assign({}, action),\n\t        params = {},\n\t        body;\n\t\n\t    switch (args.length) {\n\t\n\t        case 2:\n\t\n\t            params = args[0];\n\t            body = args[1];\n\t\n\t            break;\n\t\n\t        case 1:\n\t\n\t            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n\t                body = args[0];\n\t            } else {\n\t                params = args[0];\n\t            }\n\t\n\t            break;\n\t\n\t        case 0:\n\t\n\t            break;\n\t\n\t        default:\n\t\n\t            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\n\t    }\n\t\n\t    options.body = body;\n\t    options.params = assign({}, options.params, params);\n\t\n\t    return options;\n\t}\n\t\n\tResource.actions = {\n\t\n\t    get: { method: 'GET' },\n\t    save: { method: 'POST' },\n\t    query: { method: 'GET' },\n\t    update: { method: 'PUT' },\n\t    remove: { method: 'DELETE' },\n\t    delete: { method: 'DELETE' }\n\t\n\t};\n\t\n\t/**\n\t * Install plugin.\n\t */\n\t\n\tfunction plugin(Vue) {\n\t\n\t    if (plugin.installed) {\n\t        return;\n\t    }\n\t\n\t    Util(Vue);\n\t\n\t    Vue.url = Url;\n\t    Vue.http = Http;\n\t    Vue.resource = Resource;\n\t    Vue.Promise = PromiseObj;\n\t\n\t    Object.defineProperties(Vue.prototype, {\n\t\n\t        $url: {\n\t            get: function () {\n\t                return options(Vue.url, this, this.$options.url);\n\t            }\n\t        },\n\t\n\t        $http: {\n\t            get: function () {\n\t                return options(Vue.http, this, this.$options.http);\n\t            }\n\t        },\n\t\n\t        $resource: {\n\t            get: function () {\n\t                return Vue.resource.bind(this);\n\t            }\n\t        },\n\t\n\t        $promise: {\n\t            get: function () {\n\t                var _this = this;\n\t\n\t                return function (executor) {\n\t                    return new Vue.Promise(executor, _this);\n\t                };\n\t            }\n\t        }\n\t\n\t    });\n\t}\n\t\n\tif (typeof window !== 'undefined' && window.Vue) {\n\t    window.Vue.use(plugin);\n\t}\n\t\n\tmodule.exports = plugin;\n\n/***/ },\n/* 199 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t  * vue-router v2.1.1\n\t  * (c) 2016 Evan You\n\t  * @license MIT\n\t  */\n\t'use strict';\n\t\n\tvar View = {\n\t  name: 'router-view',\n\t  functional: true,\n\t  props: {\n\t    name: {\n\t      type: String,\n\t      default: 'default'\n\t    }\n\t  },\n\t  render: function render (h, ref) {\n\t    var props = ref.props;\n\t    var children = ref.children;\n\t    var parent = ref.parent;\n\t    var data = ref.data;\n\t\n\t    data.routerView = true\n\t\n\t    var route = parent.$route\n\t    var cache = parent._routerViewCache || (parent._routerViewCache = {})\n\t    var depth = 0\n\t    var inactive = false\n\t\n\t    while (parent) {\n\t      if (parent.$vnode && parent.$vnode.data.routerView) {\n\t        depth++\n\t      }\n\t      if (parent._inactive) {\n\t        inactive = true\n\t      }\n\t      parent = parent.$parent\n\t    }\n\t\n\t    data.routerViewDepth = depth\n\t    var matched = route.matched[depth]\n\t    if (!matched) {\n\t      return h()\n\t    }\n\t\n\t    var name = props.name\n\t    var component = inactive\n\t      ? cache[name]\n\t      : (cache[name] = matched.components[name])\n\t\n\t    if (!inactive) {\n\t      var hooks = data.hook || (data.hook = {})\n\t      hooks.init = function (vnode) {\n\t        matched.instances[name] = vnode.child\n\t      }\n\t      hooks.prepatch = function (oldVnode, vnode) {\n\t        matched.instances[name] = vnode.child\n\t      }\n\t      hooks.destroy = function (vnode) {\n\t        if (matched.instances[name] === vnode.child) {\n\t          matched.instances[name] = undefined\n\t        }\n\t      }\n\t    }\n\t\n\t    return h(component, data, children)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction assert (condition, message) {\n\t  if (!condition) {\n\t    throw new Error((\"[vue-router] \" + message))\n\t  }\n\t}\n\t\n\tfunction warn (condition, message) {\n\t  if (!condition) {\n\t    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message))\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar encode = encodeURIComponent\n\tvar decode = decodeURIComponent\n\t\n\tfunction resolveQuery (\n\t  query,\n\t  extraQuery\n\t) {\n\t  if ( extraQuery === void 0 ) extraQuery = {};\n\t\n\t  if (query) {\n\t    var parsedQuery\n\t    try {\n\t      parsedQuery = parseQuery(query)\n\t    } catch (e) {\n\t      (\"production\") !== 'production' && warn(false, e.message)\n\t      parsedQuery = {}\n\t    }\n\t    for (var key in extraQuery) {\n\t      parsedQuery[key] = extraQuery[key]\n\t    }\n\t    return parsedQuery\n\t  } else {\n\t    return extraQuery\n\t  }\n\t}\n\t\n\tfunction parseQuery (query) {\n\t  var res = {}\n\t\n\t  query = query.trim().replace(/^(\\?|#|&)/, '')\n\t\n\t  if (!query) {\n\t    return res\n\t  }\n\t\n\t  query.split('&').forEach(function (param) {\n\t    var parts = param.replace(/\\+/g, ' ').split('=')\n\t    var key = decode(parts.shift())\n\t    var val = parts.length > 0\n\t      ? decode(parts.join('='))\n\t      : null\n\t\n\t    if (res[key] === undefined) {\n\t      res[key] = val\n\t    } else if (Array.isArray(res[key])) {\n\t      res[key].push(val)\n\t    } else {\n\t      res[key] = [res[key], val]\n\t    }\n\t  })\n\t\n\t  return res\n\t}\n\t\n\tfunction stringifyQuery (obj) {\n\t  var res = obj ? Object.keys(obj).map(function (key) {\n\t    var val = obj[key]\n\t\n\t    if (val === undefined) {\n\t      return ''\n\t    }\n\t\n\t    if (val === null) {\n\t      return encode(key)\n\t    }\n\t\n\t    if (Array.isArray(val)) {\n\t      var result = []\n\t      val.slice().forEach(function (val2) {\n\t        if (val2 === undefined) {\n\t          return\n\t        }\n\t        if (val2 === null) {\n\t          result.push(encode(key))\n\t        } else {\n\t          result.push(encode(key) + '=' + encode(val2))\n\t        }\n\t      })\n\t      return result.join('&')\n\t    }\n\t\n\t    return encode(key) + '=' + encode(val)\n\t  }).filter(function (x) { return x.length > 0; }).join('&') : null\n\t  return res ? (\"?\" + res) : ''\n\t}\n\t\n\t/*  */\n\t\n\tfunction createRoute (\n\t  record,\n\t  location,\n\t  redirectedFrom\n\t) {\n\t  var route = {\n\t    name: location.name || (record && record.name),\n\t    meta: (record && record.meta) || {},\n\t    path: location.path || '/',\n\t    hash: location.hash || '',\n\t    query: location.query || {},\n\t    params: location.params || {},\n\t    fullPath: getFullPath(location),\n\t    matched: record ? formatMatch(record) : []\n\t  }\n\t  if (redirectedFrom) {\n\t    route.redirectedFrom = getFullPath(redirectedFrom)\n\t  }\n\t  return Object.freeze(route)\n\t}\n\t\n\t// the starting route that represents the initial state\n\tvar START = createRoute(null, {\n\t  path: '/'\n\t})\n\t\n\tfunction formatMatch (record) {\n\t  var res = []\n\t  while (record) {\n\t    res.unshift(record)\n\t    record = record.parent\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getFullPath (ref) {\n\t  var path = ref.path;\n\t  var query = ref.query; if ( query === void 0 ) query = {};\n\t  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\t\n\t  return (path || '/') + stringifyQuery(query) + hash\n\t}\n\t\n\tvar trailingSlashRE = /\\/$/\n\tfunction isSameRoute (a, b) {\n\t  if (b === START) {\n\t    return a === b\n\t  } else if (!b) {\n\t    return false\n\t  } else if (a.path && b.path) {\n\t    return (\n\t      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query)\n\t    )\n\t  } else if (a.name && b.name) {\n\t    return (\n\t      a.name === b.name &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query) &&\n\t      isObjectEqual(a.params, b.params)\n\t    )\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction isObjectEqual (a, b) {\n\t  if ( a === void 0 ) a = {};\n\t  if ( b === void 0 ) b = {};\n\t\n\t  var aKeys = Object.keys(a)\n\t  var bKeys = Object.keys(b)\n\t  if (aKeys.length !== bKeys.length) {\n\t    return false\n\t  }\n\t  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n\t}\n\t\n\tfunction isIncludedRoute (current, target) {\n\t  return (\n\t    current.path.indexOf(target.path.replace(/\\/$/, '')) === 0 &&\n\t    (!target.hash || current.hash === target.hash) &&\n\t    queryIncludes(current.query, target.query)\n\t  )\n\t}\n\t\n\tfunction queryIncludes (current, target) {\n\t  for (var key in target) {\n\t    if (!(key in current)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\t/*  */\n\t\n\t// work around weird flow bug\n\tvar toTypes = [String, Object]\n\t\n\tvar Link = {\n\t  name: 'router-link',\n\t  props: {\n\t    to: {\n\t      type: toTypes,\n\t      required: true\n\t    },\n\t    tag: {\n\t      type: String,\n\t      default: 'a'\n\t    },\n\t    exact: Boolean,\n\t    append: Boolean,\n\t    replace: Boolean,\n\t    activeClass: String,\n\t    event: {\n\t      type: [String, Array],\n\t      default: 'click'\n\t    }\n\t  },\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var router = this.$router\n\t    var current = this.$route\n\t    var ref = router.resolve(this.to, current, this.append);\n\t    var normalizedTo = ref.normalizedTo;\n\t    var resolved = ref.resolved;\n\t    var href = ref.href;\n\t    var classes = {}\n\t    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active'\n\t    var compareTarget = normalizedTo.path ? createRoute(null, normalizedTo) : resolved\n\t    classes[activeClass] = this.exact\n\t      ? isSameRoute(current, compareTarget)\n\t      : isIncludedRoute(current, compareTarget)\n\t\n\t    var handler = function (e) {\n\t      if (guardEvent(e)) {\n\t        if (this$1.replace) {\n\t          router.replace(normalizedTo)\n\t        } else {\n\t          router.push(normalizedTo)\n\t        }\n\t      }\n\t    }\n\t\n\t    var on = { click: guardEvent }\n\t    if (Array.isArray(this.event)) {\n\t      this.event.forEach(function (e) { on[e] = handler })\n\t    } else {\n\t      on[this.event] = handler\n\t    }\n\t\n\t    var data = {\n\t      class: classes\n\t    }\n\t\n\t    if (this.tag === 'a') {\n\t      data.on = on\n\t      data.attrs = { href: href }\n\t    } else {\n\t      // find the first <a> child and apply listener and href\n\t      var a = findAnchor(this.$slots.default)\n\t      if (a) {\n\t        // in case the <a> is a static node\n\t        a.isStatic = false\n\t        var extend = _Vue.util.extend\n\t        var aData = a.data = extend({}, a.data)\n\t        aData.on = on\n\t        var aAttrs = a.data.attrs = extend({}, a.data.attrs)\n\t        aAttrs.href = href\n\t      } else {\n\t        // doesn't have <a> child, apply listener to self\n\t        data.on = on\n\t      }\n\t    }\n\t\n\t    return h(this.tag, data, this.$slots.default)\n\t  }\n\t}\n\t\n\tfunction guardEvent (e) {\n\t  // don't redirect with control keys\n\t  /* istanbul ignore if */\n\t  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n\t  // don't redirect when preventDefault called\n\t  /* istanbul ignore if */\n\t  if (e.defaultPrevented) { return }\n\t  // don't redirect on right click\n\t  /* istanbul ignore if */\n\t  if (e.button !== 0) { return }\n\t  // don't redirect if `target=\"_blank\"`\n\t  /* istanbul ignore if */\n\t  var target = e.target.getAttribute('target')\n\t  if (/\\b_blank\\b/i.test(target)) { return }\n\t\n\t  e.preventDefault()\n\t  return true\n\t}\n\t\n\tfunction findAnchor (children) {\n\t  if (children) {\n\t    var child\n\t    for (var i = 0; i < children.length; i++) {\n\t      child = children[i]\n\t      if (child.tag === 'a') {\n\t        return child\n\t      }\n\t      if (child.children && (child = findAnchor(child.children))) {\n\t        return child\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar _Vue\n\t\n\tfunction install (Vue) {\n\t  if (install.installed) { return }\n\t  install.installed = true\n\t\n\t  _Vue = Vue\n\t\n\t  Object.defineProperty(Vue.prototype, '$router', {\n\t    get: function get () { return this.$root._router }\n\t  })\n\t\n\t  Object.defineProperty(Vue.prototype, '$route', {\n\t    get: function get$1 () { return this.$root._route }\n\t  })\n\t\n\t  Vue.mixin({\n\t    beforeCreate: function beforeCreate () {\n\t      if (this.$options.router) {\n\t        this._router = this.$options.router\n\t        this._router.init(this)\n\t        Vue.util.defineReactive(this, '_route', this._router.history.current)\n\t      }\n\t    }\n\t  })\n\t\n\t  Vue.component('router-view', View)\n\t  Vue.component('router-link', Link)\n\t\n\t  var strats = Vue.config.optionMergeStrategies\n\t  // use the same hook merging strategy for route hooks\n\t  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created\n\t}\n\t\n\t/*  */\n\t\n\tfunction resolvePath (\n\t  relative,\n\t  base,\n\t  append\n\t) {\n\t  if (relative.charAt(0) === '/') {\n\t    return relative\n\t  }\n\t\n\t  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n\t    return base + relative\n\t  }\n\t\n\t  var stack = base.split('/')\n\t\n\t  // remove trailing segment if:\n\t  // - not appending\n\t  // - appending to trailing slash (last segment is empty)\n\t  if (!append || !stack[stack.length - 1]) {\n\t    stack.pop()\n\t  }\n\t\n\t  // resolve relative path\n\t  var segments = relative.replace(/^\\//, '').split('/')\n\t  for (var i = 0; i < segments.length; i++) {\n\t    var segment = segments[i]\n\t    if (segment === '.') {\n\t      continue\n\t    } else if (segment === '..') {\n\t      stack.pop()\n\t    } else {\n\t      stack.push(segment)\n\t    }\n\t  }\n\t\n\t  // ensure leading slash\n\t  if (stack[0] !== '') {\n\t    stack.unshift('')\n\t  }\n\t\n\t  return stack.join('/')\n\t}\n\t\n\tfunction parsePath (path) {\n\t  var hash = ''\n\t  var query = ''\n\t\n\t  var hashIndex = path.indexOf('#')\n\t  if (hashIndex >= 0) {\n\t    hash = path.slice(hashIndex)\n\t    path = path.slice(0, hashIndex)\n\t  }\n\t\n\t  var queryIndex = path.indexOf('?')\n\t  if (queryIndex >= 0) {\n\t    query = path.slice(queryIndex + 1)\n\t    path = path.slice(0, queryIndex)\n\t  }\n\t\n\t  return {\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\t\n\tfunction cleanPath (path) {\n\t  return path.replace(/\\/\\//g, '/')\n\t}\n\t\n\t/*  */\n\t\n\tfunction createRouteMap (routes) {\n\t  var pathMap = Object.create(null)\n\t  var nameMap = Object.create(null)\n\t\n\t  routes.forEach(function (route) {\n\t    addRouteRecord(pathMap, nameMap, route)\n\t  })\n\t\n\t  return {\n\t    pathMap: pathMap,\n\t    nameMap: nameMap\n\t  }\n\t}\n\t\n\tfunction addRouteRecord (\n\t  pathMap,\n\t  nameMap,\n\t  route,\n\t  parent,\n\t  matchAs\n\t) {\n\t  var path = route.path;\n\t  var name = route.name;\n\t  if (false) {\n\t    assert(path != null, \"\\\"path\\\" is required in a route configuration.\")\n\t    assert(\n\t      typeof route.component !== 'string',\n\t      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n\t      \"string id. Use an actual component instead.\"\n\t    )\n\t  }\n\t\n\t  var record = {\n\t    path: normalizePath(path, parent),\n\t    components: route.components || { default: route.component },\n\t    instances: {},\n\t    name: name,\n\t    parent: parent,\n\t    matchAs: matchAs,\n\t    redirect: route.redirect,\n\t    beforeEnter: route.beforeEnter,\n\t    meta: route.meta || {}\n\t  }\n\t\n\t  if (route.children) {\n\t    // Warn if route is named and has a default child route.\n\t    // If users navigate to this route by name, the default child will\n\t    // not be rendered (GH Issue #629)\n\t    if (false) {\n\t      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n\t        warn(false, (\"Named Route '\" + (route.name) + \"' has a default child route.\\n          When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), the default child route will not be rendered.\\n          Remove the name from this route and use the name of the default child route for named links instead.\")\n\t        )\n\t      }\n\t    }\n\t    route.children.forEach(function (child) {\n\t      addRouteRecord(pathMap, nameMap, child, record)\n\t    })\n\t  }\n\t\n\t  if (route.alias !== undefined) {\n\t    if (Array.isArray(route.alias)) {\n\t      route.alias.forEach(function (alias) {\n\t        addRouteRecord(pathMap, nameMap, { path: alias }, parent, record.path)\n\t      })\n\t    } else {\n\t      addRouteRecord(pathMap, nameMap, { path: route.alias }, parent, record.path)\n\t    }\n\t  }\n\t\n\t  if (!pathMap[record.path]) {\n\t    pathMap[record.path] = record\n\t  }\n\t  if (name) {\n\t    if (!nameMap[name]) {\n\t      nameMap[name] = record\n\t    } else if (false) {\n\t      warn(false, (\"Duplicate named routes definition: { name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"))\n\t    }\n\t  }\n\t}\n\t\n\tfunction normalizePath (path, parent) {\n\t  path = path.replace(/\\/$/, '')\n\t  if (path[0] === '/') { return path }\n\t  if (parent == null) { return path }\n\t  return cleanPath(((parent.path) + \"/\" + path))\n\t}\n\t\n\tvar __moduleExports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\t\n\tvar isarray = __moduleExports\n\t\n\t/**\n\t * Expose `pathToRegexp`.\n\t */\n\tvar index = pathToRegexp\n\tvar parse_1 = parse\n\tvar compile_1 = compile\n\tvar tokensToFunction_1 = tokensToFunction\n\tvar tokensToRegExp_1 = tokensToRegExp\n\t\n\t/**\n\t * The main path matching regexp utility.\n\t *\n\t * @type {RegExp}\n\t */\n\tvar PATH_REGEXP = new RegExp([\n\t  // Match escaped characters that would otherwise appear in future matches.\n\t  // This allows the user to escape special characters that won't transform.\n\t  '(\\\\\\\\.)',\n\t  // Match Express-style parameters and un-named parameters with a prefix\n\t  // and optional suffixes. Matches appear as:\n\t  //\n\t  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n\t  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n\t  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n\t  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n\t].join('|'), 'g')\n\t\n\t/**\n\t * Parse a string for the raw tokens.\n\t *\n\t * @param  {string}  str\n\t * @param  {Object=} options\n\t * @return {!Array}\n\t */\n\tfunction parse (str, options) {\n\t  var tokens = []\n\t  var key = 0\n\t  var index = 0\n\t  var path = ''\n\t  var defaultDelimiter = options && options.delimiter || '/'\n\t  var res\n\t\n\t  while ((res = PATH_REGEXP.exec(str)) != null) {\n\t    var m = res[0]\n\t    var escaped = res[1]\n\t    var offset = res.index\n\t    path += str.slice(index, offset)\n\t    index = offset + m.length\n\t\n\t    // Ignore already escaped sequences.\n\t    if (escaped) {\n\t      path += escaped[1]\n\t      continue\n\t    }\n\t\n\t    var next = str[index]\n\t    var prefix = res[2]\n\t    var name = res[3]\n\t    var capture = res[4]\n\t    var group = res[5]\n\t    var modifier = res[6]\n\t    var asterisk = res[7]\n\t\n\t    // Push the current path onto the tokens.\n\t    if (path) {\n\t      tokens.push(path)\n\t      path = ''\n\t    }\n\t\n\t    var partial = prefix != null && next != null && next !== prefix\n\t    var repeat = modifier === '+' || modifier === '*'\n\t    var optional = modifier === '?' || modifier === '*'\n\t    var delimiter = res[2] || defaultDelimiter\n\t    var pattern = capture || group\n\t\n\t    tokens.push({\n\t      name: name || key++,\n\t      prefix: prefix || '',\n\t      delimiter: delimiter,\n\t      optional: optional,\n\t      repeat: repeat,\n\t      partial: partial,\n\t      asterisk: !!asterisk,\n\t      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n\t    })\n\t  }\n\t\n\t  // Match any characters still remaining.\n\t  if (index < str.length) {\n\t    path += str.substr(index)\n\t  }\n\t\n\t  // If the path exists, push it onto the end.\n\t  if (path) {\n\t    tokens.push(path)\n\t  }\n\t\n\t  return tokens\n\t}\n\t\n\t/**\n\t * Compile a string to a template function for the path.\n\t *\n\t * @param  {string}             str\n\t * @param  {Object=}            options\n\t * @return {!function(Object=, Object=)}\n\t */\n\tfunction compile (str, options) {\n\t  return tokensToFunction(parse(str, options))\n\t}\n\t\n\t/**\n\t * Prettier encoding of URI path segments.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeURIComponentPretty (str) {\n\t  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeAsterisk (str) {\n\t  return encodeURI(str).replace(/[?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Expose a method for transforming tokens into the path function.\n\t */\n\tfunction tokensToFunction (tokens) {\n\t  // Compile all the tokens into regexps.\n\t  var matches = new Array(tokens.length)\n\t\n\t  // Compile all the patterns before compilation.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] === 'object') {\n\t      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n\t    }\n\t  }\n\t\n\t  return function (obj, opts) {\n\t    var path = ''\n\t    var data = obj || {}\n\t    var options = opts || {}\n\t    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\t\n\t    for (var i = 0; i < tokens.length; i++) {\n\t      var token = tokens[i]\n\t\n\t      if (typeof token === 'string') {\n\t        path += token\n\t\n\t        continue\n\t      }\n\t\n\t      var value = data[token.name]\n\t      var segment\n\t\n\t      if (value == null) {\n\t        if (token.optional) {\n\t          // Prepend partial segment prefixes.\n\t          if (token.partial) {\n\t            path += token.prefix\n\t          }\n\t\n\t          continue\n\t        } else {\n\t          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n\t        }\n\t      }\n\t\n\t      if (isarray(value)) {\n\t        if (!token.repeat) {\n\t          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n\t        }\n\t\n\t        if (value.length === 0) {\n\t          if (token.optional) {\n\t            continue\n\t          } else {\n\t            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n\t          }\n\t        }\n\t\n\t        for (var j = 0; j < value.length; j++) {\n\t          segment = encode(value[j])\n\t\n\t          if (!matches[i].test(segment)) {\n\t            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n\t          }\n\t\n\t          path += (j === 0 ? token.prefix : token.delimiter) + segment\n\t        }\n\t\n\t        continue\n\t      }\n\t\n\t      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\t\n\t      if (!matches[i].test(segment)) {\n\t        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n\t      }\n\t\n\t      path += token.prefix + segment\n\t    }\n\t\n\t    return path\n\t  }\n\t}\n\t\n\t/**\n\t * Escape a regular expression string.\n\t *\n\t * @param  {string} str\n\t * @return {string}\n\t */\n\tfunction escapeString (str) {\n\t  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Escape the capturing group by escaping special characters and meaning.\n\t *\n\t * @param  {string} group\n\t * @return {string}\n\t */\n\tfunction escapeGroup (group) {\n\t  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Attach the keys as a property of the regexp.\n\t *\n\t * @param  {!RegExp} re\n\t * @param  {Array}   keys\n\t * @return {!RegExp}\n\t */\n\tfunction attachKeys (re, keys) {\n\t  re.keys = keys\n\t  return re\n\t}\n\t\n\t/**\n\t * Get the flags for a regexp from the options.\n\t *\n\t * @param  {Object} options\n\t * @return {string}\n\t */\n\tfunction flags (options) {\n\t  return options.sensitive ? '' : 'i'\n\t}\n\t\n\t/**\n\t * Pull out keys from a regexp.\n\t *\n\t * @param  {!RegExp} path\n\t * @param  {!Array}  keys\n\t * @return {!RegExp}\n\t */\n\tfunction regexpToRegexp (path, keys) {\n\t  // Use a negative lookahead to match only capturing groups.\n\t  var groups = path.source.match(/\\((?!\\?)/g)\n\t\n\t  if (groups) {\n\t    for (var i = 0; i < groups.length; i++) {\n\t      keys.push({\n\t        name: i,\n\t        prefix: null,\n\t        delimiter: null,\n\t        optional: false,\n\t        repeat: false,\n\t        partial: false,\n\t        asterisk: false,\n\t        pattern: null\n\t      })\n\t    }\n\t  }\n\t\n\t  return attachKeys(path, keys)\n\t}\n\t\n\t/**\n\t * Transform an array into a regexp.\n\t *\n\t * @param  {!Array}  path\n\t * @param  {Array}   keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction arrayToRegexp (path, keys, options) {\n\t  var parts = []\n\t\n\t  for (var i = 0; i < path.length; i++) {\n\t    parts.push(pathToRegexp(path[i], keys, options).source)\n\t  }\n\t\n\t  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\t\n\t  return attachKeys(regexp, keys)\n\t}\n\t\n\t/**\n\t * Create a path regexp from string input.\n\t *\n\t * @param  {string}  path\n\t * @param  {!Array}  keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction stringToRegexp (path, keys, options) {\n\t  return tokensToRegExp(parse(path, options), keys, options)\n\t}\n\t\n\t/**\n\t * Expose a function for taking tokens and returning a RegExp.\n\t *\n\t * @param  {!Array}          tokens\n\t * @param  {(Array|Object)=} keys\n\t * @param  {Object=}         options\n\t * @return {!RegExp}\n\t */\n\tfunction tokensToRegExp (tokens, keys, options) {\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys || options)\n\t    keys = []\n\t  }\n\t\n\t  options = options || {}\n\t\n\t  var strict = options.strict\n\t  var end = options.end !== false\n\t  var route = ''\n\t\n\t  // Iterate over the tokens and create our regexp string.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    var token = tokens[i]\n\t\n\t    if (typeof token === 'string') {\n\t      route += escapeString(token)\n\t    } else {\n\t      var prefix = escapeString(token.prefix)\n\t      var capture = '(?:' + token.pattern + ')'\n\t\n\t      keys.push(token)\n\t\n\t      if (token.repeat) {\n\t        capture += '(?:' + prefix + capture + ')*'\n\t      }\n\t\n\t      if (token.optional) {\n\t        if (!token.partial) {\n\t          capture = '(?:' + prefix + '(' + capture + '))?'\n\t        } else {\n\t          capture = prefix + '(' + capture + ')?'\n\t        }\n\t      } else {\n\t        capture = prefix + '(' + capture + ')'\n\t      }\n\t\n\t      route += capture\n\t    }\n\t  }\n\t\n\t  var delimiter = escapeString(options.delimiter || '/')\n\t  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\t\n\t  // In non-strict mode we allow a slash at the end of match. If the path to\n\t  // match already ends with a slash, we remove it for consistency. The slash\n\t  // is valid at the end of a path match, not in the middle. This is important\n\t  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\t  if (!strict) {\n\t    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n\t  }\n\t\n\t  if (end) {\n\t    route += '$'\n\t  } else {\n\t    // In non-ending mode, we need the capturing groups to match as much as\n\t    // possible by using a positive lookahead to the end or next path segment.\n\t    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n\t  }\n\t\n\t  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n\t}\n\t\n\t/**\n\t * Normalize the given path string, returning a regular expression.\n\t *\n\t * An empty array can be passed in for the keys, which will hold the\n\t * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n\t * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n\t *\n\t * @param  {(string|RegExp|Array)} path\n\t * @param  {(Array|Object)=}       keys\n\t * @param  {Object=}               options\n\t * @return {!RegExp}\n\t */\n\tfunction pathToRegexp (path, keys, options) {\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys || options)\n\t    keys = []\n\t  }\n\t\n\t  options = options || {}\n\t\n\t  if (path instanceof RegExp) {\n\t    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n\t  }\n\t\n\t  if (isarray(path)) {\n\t    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n\t  }\n\t\n\t  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n\t}\n\t\n\tindex.parse = parse_1;\n\tindex.compile = compile_1;\n\tindex.tokensToFunction = tokensToFunction_1;\n\tindex.tokensToRegExp = tokensToRegExp_1;\n\t\n\t/*  */\n\t\n\tvar regexpCache = Object.create(null)\n\t\n\tfunction getRouteRegex (path) {\n\t  var hit = regexpCache[path]\n\t  var keys, regexp\n\t\n\t  if (hit) {\n\t    keys = hit.keys\n\t    regexp = hit.regexp\n\t  } else {\n\t    keys = []\n\t    regexp = index(path, keys)\n\t    regexpCache[path] = { keys: keys, regexp: regexp }\n\t  }\n\t\n\t  return { keys: keys, regexp: regexp }\n\t}\n\t\n\tvar regexpCompileCache = Object.create(null)\n\t\n\tfunction fillParams (\n\t  path,\n\t  params,\n\t  routeMsg\n\t) {\n\t  try {\n\t    var filler =\n\t      regexpCompileCache[path] ||\n\t      (regexpCompileCache[path] = index.compile(path))\n\t    return filler(params || {}, { pretty: true })\n\t  } catch (e) {\n\t    if (false) {\n\t      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)))\n\t    }\n\t    return ''\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction normalizeLocation (\n\t  raw,\n\t  current,\n\t  append\n\t) {\n\t  var next = typeof raw === 'string' ? { path: raw } : raw\n\t  // named target\n\t  if (next.name || next._normalized) {\n\t    return next\n\t  }\n\t\n\t  // relative params\n\t  if (!next.path && next.params && current) {\n\t    next = assign({}, next)\n\t    next._normalized = true\n\t    var params = assign(assign({}, current.params), next.params)\n\t    if (current.name) {\n\t      next.name = current.name\n\t      next.params = params\n\t    } else if (current.matched) {\n\t      var rawPath = current.matched[current.matched.length - 1].path\n\t      next.path = fillParams(rawPath, params, (\"path \" + (current.path)))\n\t    } else if (false) {\n\t      warn(false, \"relative params navigation requires a current route.\")\n\t    }\n\t    return next\n\t  }\n\t\n\t  var parsedPath = parsePath(next.path || '')\n\t  var basePath = (current && current.path) || '/'\n\t  var path = parsedPath.path\n\t    ? resolvePath(parsedPath.path, basePath, append || next.append)\n\t    : (current && current.path) || '/'\n\t  var query = resolveQuery(parsedPath.query, next.query)\n\t  var hash = next.hash || parsedPath.hash\n\t  if (hash && hash.charAt(0) !== '#') {\n\t    hash = \"#\" + hash\n\t  }\n\t\n\t  return {\n\t    _normalized: true,\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\t\n\tfunction assign (a, b) {\n\t  for (var key in b) {\n\t    a[key] = b[key]\n\t  }\n\t  return a\n\t}\n\t\n\t/*  */\n\t\n\tfunction createMatcher (routes) {\n\t  var ref = createRouteMap(routes);\n\t  var pathMap = ref.pathMap;\n\t  var nameMap = ref.nameMap;\n\t\n\t  function match (\n\t    raw,\n\t    currentRoute,\n\t    redirectedFrom\n\t  ) {\n\t    var location = normalizeLocation(raw, currentRoute)\n\t    var name = location.name;\n\t\n\t    if (name) {\n\t      var record = nameMap[name]\n\t      var paramNames = getRouteRegex(record.path).keys\n\t        .filter(function (key) { return !key.optional; })\n\t        .map(function (key) { return key.name; })\n\t\n\t      if (typeof location.params !== 'object') {\n\t        location.params = {}\n\t      }\n\t\n\t      if (currentRoute && typeof currentRoute.params === 'object') {\n\t        for (var key in currentRoute.params) {\n\t          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n\t            location.params[key] = currentRoute.params[key]\n\t          }\n\t        }\n\t      }\n\t\n\t      if (record) {\n\t        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"))\n\t        return _createRoute(record, location, redirectedFrom)\n\t      }\n\t    } else if (location.path) {\n\t      location.params = {}\n\t      for (var path in pathMap) {\n\t        if (matchRoute(path, location.params, location.path)) {\n\t          return _createRoute(pathMap[path], location, redirectedFrom)\n\t        }\n\t      }\n\t    }\n\t    // no match\n\t    return _createRoute(null, location)\n\t  }\n\t\n\t  function redirect (\n\t    record,\n\t    location\n\t  ) {\n\t    var originalRedirect = record.redirect\n\t    var redirect = typeof originalRedirect === 'function'\n\t        ? originalRedirect(createRoute(record, location))\n\t        : originalRedirect\n\t\n\t    if (typeof redirect === 'string') {\n\t      redirect = { path: redirect }\n\t    }\n\t\n\t    if (!redirect || typeof redirect !== 'object') {\n\t      (\"production\") !== 'production' && warn(\n\t        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n\t      )\n\t      return _createRoute(null, location)\n\t    }\n\t\n\t    var re = redirect\n\t    var name = re.name;\n\t    var path = re.path;\n\t    var query = location.query;\n\t    var hash = location.hash;\n\t    var params = location.params;\n\t    query = re.hasOwnProperty('query') ? re.query : query\n\t    hash = re.hasOwnProperty('hash') ? re.hash : hash\n\t    params = re.hasOwnProperty('params') ? re.params : params\n\t\n\t    if (name) {\n\t      // resolved named direct\n\t      var targetRecord = nameMap[name]\n\t      if (false) {\n\t        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"))\n\t      }\n\t      return match({\n\t        _normalized: true,\n\t        name: name,\n\t        query: query,\n\t        hash: hash,\n\t        params: params\n\t      }, undefined, location)\n\t    } else if (path) {\n\t      // 1. resolve relative redirect\n\t      var rawPath = resolveRecordPath(path, record)\n\t      // 2. resolve params\n\t      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"))\n\t      // 3. rematch with existing query and hash\n\t      return match({\n\t        _normalized: true,\n\t        path: resolvedPath,\n\t        query: query,\n\t        hash: hash\n\t      }, undefined, location)\n\t    } else {\n\t      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))))\n\t      return _createRoute(null, location)\n\t    }\n\t  }\n\t\n\t  function alias (\n\t    record,\n\t    location,\n\t    matchAs\n\t  ) {\n\t    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"))\n\t    var aliasedMatch = match({\n\t      _normalized: true,\n\t      path: aliasedPath\n\t    })\n\t    if (aliasedMatch) {\n\t      var matched = aliasedMatch.matched\n\t      var aliasedRecord = matched[matched.length - 1]\n\t      location.params = aliasedMatch.params\n\t      return _createRoute(aliasedRecord, location)\n\t    }\n\t    return _createRoute(null, location)\n\t  }\n\t\n\t  function _createRoute (\n\t    record,\n\t    location,\n\t    redirectedFrom\n\t  ) {\n\t    if (record && record.redirect) {\n\t      return redirect(record, redirectedFrom || location)\n\t    }\n\t    if (record && record.matchAs) {\n\t      return alias(record, location, record.matchAs)\n\t    }\n\t    return createRoute(record, location, redirectedFrom)\n\t  }\n\t\n\t  return match\n\t}\n\t\n\tfunction matchRoute (\n\t  path,\n\t  params,\n\t  pathname\n\t) {\n\t  var ref = getRouteRegex(path);\n\t  var regexp = ref.regexp;\n\t  var keys = ref.keys;\n\t  var m = pathname.match(regexp)\n\t\n\t  if (!m) {\n\t    return false\n\t  } else if (!params) {\n\t    return true\n\t  }\n\t\n\t  for (var i = 1, len = m.length; i < len; ++i) {\n\t    var key = keys[i - 1]\n\t    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]\n\t    if (key) { params[key.name] = val }\n\t  }\n\t\n\t  return true\n\t}\n\t\n\tfunction resolveRecordPath (path, record) {\n\t  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n\t}\n\t\n\t/*  */\n\t\n\tvar inBrowser = typeof window !== 'undefined'\n\t\n\tvar supportsHistory = inBrowser && (function () {\n\t  var ua = window.navigator.userAgent\n\t\n\t  if (\n\t    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n\t    ua.indexOf('Mobile Safari') !== -1 &&\n\t    ua.indexOf('Chrome') === -1 &&\n\t    ua.indexOf('Windows Phone') === -1\n\t  ) {\n\t    return false\n\t  }\n\t\n\t  return window.history && 'pushState' in window.history\n\t})()\n\t\n\t/*  */\n\t\n\tfunction runQueue (queue, fn, cb) {\n\t  var step = function (index) {\n\t    if (index >= queue.length) {\n\t      cb()\n\t    } else {\n\t      if (queue[index]) {\n\t        fn(queue[index], function () {\n\t          step(index + 1)\n\t        })\n\t      } else {\n\t        step(index + 1)\n\t      }\n\t    }\n\t  }\n\t  step(0)\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar History = function History (router, base) {\n\t  this.router = router\n\t  this.base = normalizeBase(base)\n\t  // start with a route object that stands for \"nowhere\"\n\t  this.current = START\n\t  this.pending = null\n\t};\n\t\n\tHistory.prototype.listen = function listen (cb) {\n\t  this.cb = cb\n\t};\n\t\n\tHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t  var route = this.router.match(location, this.current)\n\t  this.confirmTransition(route, function () {\n\t    this$1.updateRoute(route)\n\t    onComplete && onComplete(route)\n\t    this$1.ensureURL()\n\t  }, onAbort)\n\t};\n\t\n\tHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t  var current = this.current\n\t  var abort = function () { onAbort && onAbort() }\n\t  if (isSameRoute(route, current)) {\n\t    this.ensureURL()\n\t    return abort()\n\t  }\n\t\n\t  var ref = resolveQueue(this.current.matched, route.matched);\n\t    var deactivated = ref.deactivated;\n\t    var activated = ref.activated;\n\t\n\t  var queue = [].concat(\n\t    // in-component leave guards\n\t    extractLeaveGuards(deactivated),\n\t    // global before hooks\n\t    this.router.beforeHooks,\n\t    // enter guards\n\t    activated.map(function (m) { return m.beforeEnter; }),\n\t    // async components\n\t    resolveAsyncComponents(activated)\n\t  )\n\t\n\t  this.pending = route\n\t  var iterator = function (hook, next) {\n\t    if (this$1.pending !== route) {\n\t      return abort()\n\t    }\n\t    hook(route, current, function (to) {\n\t      if (to === false) {\n\t        // next(false) -> abort navigation, ensure current URL\n\t        this$1.ensureURL(true)\n\t        abort()\n\t      } else if (typeof to === 'string' || typeof to === 'object') {\n\t        // next('/') or next({ path: '/' }) -> redirect\n\t        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to)\n\t        abort()\n\t      } else {\n\t        // confirm transition and pass on the value\n\t        next(to)\n\t      }\n\t    })\n\t  }\n\t\n\t  runQueue(queue, iterator, function () {\n\t    var postEnterCbs = []\n\t    var enterGuards = extractEnterGuards(activated, postEnterCbs, function () {\n\t      return this$1.current === route\n\t    })\n\t    // wait until async components are resolved before\n\t    // extracting in-component enter guards\n\t    runQueue(enterGuards, iterator, function () {\n\t      if (this$1.pending !== route) {\n\t        return abort()\n\t      }\n\t      this$1.pending = null\n\t      onComplete(route)\n\t      if (this$1.router.app) {\n\t        this$1.router.app.$nextTick(function () {\n\t          postEnterCbs.forEach(function (cb) { return cb(); })\n\t        })\n\t      }\n\t    })\n\t  })\n\t};\n\t\n\tHistory.prototype.updateRoute = function updateRoute (route) {\n\t  var prev = this.current\n\t  this.current = route\n\t  this.cb && this.cb(route)\n\t  this.router.afterHooks.forEach(function (hook) {\n\t    hook && hook(route, prev)\n\t  })\n\t};\n\t\n\tfunction normalizeBase (base) {\n\t  if (!base) {\n\t    if (inBrowser) {\n\t      // respect <base> tag\n\t      var baseEl = document.querySelector('base')\n\t      base = baseEl ? baseEl.getAttribute('href') : '/'\n\t    } else {\n\t      base = '/'\n\t    }\n\t  }\n\t  // make sure there's the starting slash\n\t  if (base.charAt(0) !== '/') {\n\t    base = '/' + base\n\t  }\n\t  // remove trailing slash\n\t  return base.replace(/\\/$/, '')\n\t}\n\t\n\tfunction resolveQueue (\n\t  current,\n\t  next\n\t) {\n\t  var i\n\t  var max = Math.max(current.length, next.length)\n\t  for (i = 0; i < max; i++) {\n\t    if (current[i] !== next[i]) {\n\t      break\n\t    }\n\t  }\n\t  return {\n\t    activated: next.slice(i),\n\t    deactivated: current.slice(i)\n\t  }\n\t}\n\t\n\tfunction extractGuard (\n\t  def,\n\t  key\n\t) {\n\t  if (typeof def !== 'function') {\n\t    // extend now so that global mixins are applied.\n\t    def = _Vue.extend(def)\n\t  }\n\t  return def.options[key]\n\t}\n\t\n\tfunction extractLeaveGuards (matched) {\n\t  return flatten(flatMapComponents(matched, function (def, instance) {\n\t    var guard = extractGuard(def, 'beforeRouteLeave')\n\t    if (guard) {\n\t      return Array.isArray(guard)\n\t        ? guard.map(function (guard) { return wrapLeaveGuard(guard, instance); })\n\t        : wrapLeaveGuard(guard, instance)\n\t    }\n\t  }).reverse())\n\t}\n\t\n\tfunction wrapLeaveGuard (\n\t  guard,\n\t  instance\n\t) {\n\t  return function routeLeaveGuard () {\n\t    return guard.apply(instance, arguments)\n\t  }\n\t}\n\t\n\tfunction extractEnterGuards (\n\t  matched,\n\t  cbs,\n\t  isValid\n\t) {\n\t  return flatten(flatMapComponents(matched, function (def, _, match, key) {\n\t    var guard = extractGuard(def, 'beforeRouteEnter')\n\t    if (guard) {\n\t      return Array.isArray(guard)\n\t        ? guard.map(function (guard) { return wrapEnterGuard(guard, cbs, match, key, isValid); })\n\t        : wrapEnterGuard(guard, cbs, match, key, isValid)\n\t    }\n\t  }))\n\t}\n\t\n\tfunction wrapEnterGuard (\n\t  guard,\n\t  cbs,\n\t  match,\n\t  key,\n\t  isValid\n\t) {\n\t  return function routeEnterGuard (to, from, next) {\n\t    return guard(to, from, function (cb) {\n\t      next(cb)\n\t      if (typeof cb === 'function') {\n\t        cbs.push(function () {\n\t          // #750\n\t          // if a router-view is wrapped with an out-in transition,\n\t          // the instance may not have been registered at this time.\n\t          // we will need to poll for registration until current route\n\t          // is no longer valid.\n\t          poll(cb, match.instances, key, isValid)\n\t        })\n\t      }\n\t    })\n\t  }\n\t}\n\t\n\tfunction poll (\n\t  cb, // somehow flow cannot infer this is a function\n\t  instances,\n\t  key,\n\t  isValid\n\t) {\n\t  if (instances[key]) {\n\t    cb(instances[key])\n\t  } else if (isValid()) {\n\t    setTimeout(function () {\n\t      poll(cb, instances, key, isValid)\n\t    }, 16)\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponents (matched) {\n\t  return flatMapComponents(matched, function (def, _, match, key) {\n\t    // if it's a function and doesn't have Vue options attached,\n\t    // assume it's an async component resolve function.\n\t    // we are not using Vue's default async resolving mechanism because\n\t    // we want to halt the navigation until the incoming component has been\n\t    // resolved.\n\t    if (typeof def === 'function' && !def.options) {\n\t      return function (to, from, next) {\n\t        var resolve = function (resolvedDef) {\n\t          match.components[key] = resolvedDef\n\t          next()\n\t        }\n\t\n\t        var reject = function (reason) {\n\t          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason))\n\t          next(false)\n\t        }\n\t\n\t        var res = def(resolve, reject)\n\t        if (res && typeof res.then === 'function') {\n\t          res.then(resolve, reject)\n\t        }\n\t      }\n\t    }\n\t  })\n\t}\n\t\n\tfunction flatMapComponents (\n\t  matched,\n\t  fn\n\t) {\n\t  return flatten(matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) { return fn(\n\t      m.components[key],\n\t      m.instances[key],\n\t      m, key\n\t    ); })\n\t  }))\n\t}\n\t\n\tfunction flatten (arr) {\n\t  return Array.prototype.concat.apply([], arr)\n\t}\n\t\n\t/*  */\n\t\n\tvar positionStore = Object.create(null)\n\t\n\tfunction saveScrollPosition (key) {\n\t  if (!key) { return }\n\t  positionStore[key] = {\n\t    x: window.pageXOffset,\n\t    y: window.pageYOffset\n\t  }\n\t}\n\t\n\tfunction getScrollPosition (key) {\n\t  if (!key) { return }\n\t  return positionStore[key]\n\t}\n\t\n\tfunction getElementPosition (el) {\n\t  var docRect = document.documentElement.getBoundingClientRect()\n\t  var elRect = el.getBoundingClientRect()\n\t  return {\n\t    x: elRect.left - docRect.left,\n\t    y: elRect.top - docRect.top\n\t  }\n\t}\n\t\n\tfunction isValidPosition (obj) {\n\t  return isNumber(obj.x) || isNumber(obj.y)\n\t}\n\t\n\tfunction normalizePosition (obj) {\n\t  return {\n\t    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n\t    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n\t  }\n\t}\n\t\n\tfunction isNumber (v) {\n\t  return typeof v === 'number'\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar genKey = function () { return String(Date.now()); }\n\tvar _key = genKey()\n\t\n\tvar HTML5History = (function (History) {\n\t  function HTML5History (router, base) {\n\t    var this$1 = this;\n\t\n\t    History.call(this, router, base)\n\t\n\t    var expectScroll = router.options.scrollBehavior\n\t    window.addEventListener('popstate', function (e) {\n\t      _key = e.state && e.state.key\n\t      var current = this$1.current\n\t      this$1.transitionTo(getLocation(this$1.base), function (next) {\n\t        if (expectScroll) {\n\t          this$1.handleScroll(next, current, true)\n\t        }\n\t      })\n\t    })\n\t\n\t    if (expectScroll) {\n\t      window.addEventListener('scroll', function () {\n\t        saveScrollPosition(_key)\n\t      })\n\t    }\n\t  }\n\t\n\t  if ( History ) HTML5History.__proto__ = History;\n\t  HTML5History.prototype = Object.create( History && History.prototype );\n\t  HTML5History.prototype.constructor = HTML5History;\n\t\n\t  HTML5History.prototype.go = function go (n) {\n\t    window.history.go(n)\n\t  };\n\t\n\t  HTML5History.prototype.push = function push (location) {\n\t    var this$1 = this;\n\t\n\t    var current = this.current\n\t    this.transitionTo(location, function (route) {\n\t      pushState(cleanPath(this$1.base + route.fullPath))\n\t      this$1.handleScroll(route, current, false)\n\t    })\n\t  };\n\t\n\t  HTML5History.prototype.replace = function replace (location) {\n\t    var this$1 = this;\n\t\n\t    var current = this.current\n\t    this.transitionTo(location, function (route) {\n\t      replaceState(cleanPath(this$1.base + route.fullPath))\n\t      this$1.handleScroll(route, current, false)\n\t    })\n\t  };\n\t\n\t  HTML5History.prototype.ensureURL = function ensureURL (push) {\n\t    if (getLocation(this.base) !== this.current.fullPath) {\n\t      var current = cleanPath(this.base + this.current.fullPath)\n\t      push ? pushState(current) : replaceState(current)\n\t    }\n\t  };\n\t\n\t  HTML5History.prototype.handleScroll = function handleScroll (to, from, isPop) {\n\t    var router = this.router\n\t    if (!router.app) {\n\t      return\n\t    }\n\t\n\t    var behavior = router.options.scrollBehavior\n\t    if (!behavior) {\n\t      return\n\t    }\n\t    if (false) {\n\t      assert(typeof behavior === 'function', \"scrollBehavior must be a function\")\n\t    }\n\t\n\t    // wait until re-render finishes before scrolling\n\t    router.app.$nextTick(function () {\n\t      var position = getScrollPosition(_key)\n\t      var shouldScroll = behavior(to, from, isPop ? position : null)\n\t      if (!shouldScroll) {\n\t        return\n\t      }\n\t      var isObject = typeof shouldScroll === 'object'\n\t      if (isObject && typeof shouldScroll.selector === 'string') {\n\t        var el = document.querySelector(shouldScroll.selector)\n\t        if (el) {\n\t          position = getElementPosition(el)\n\t        } else if (isValidPosition(shouldScroll)) {\n\t          position = normalizePosition(shouldScroll)\n\t        }\n\t      } else if (isObject && isValidPosition(shouldScroll)) {\n\t        position = normalizePosition(shouldScroll)\n\t      }\n\t\n\t      if (position) {\n\t        window.scrollTo(position.x, position.y)\n\t      }\n\t    })\n\t  };\n\t\n\t  return HTML5History;\n\t}(History));\n\t\n\tfunction getLocation (base) {\n\t  var path = window.location.pathname\n\t  if (base && path.indexOf(base) === 0) {\n\t    path = path.slice(base.length)\n\t  }\n\t  return (path || '/') + window.location.search + window.location.hash\n\t}\n\t\n\tfunction pushState (url, replace) {\n\t  // try...catch the pushState call to get around Safari\n\t  // DOM Exception 18 where it limits to 100 pushState calls\n\t  var history = window.history\n\t  try {\n\t    if (replace) {\n\t      history.replaceState({ key: _key }, '', url)\n\t    } else {\n\t      _key = genKey()\n\t      history.pushState({ key: _key }, '', url)\n\t    }\n\t    saveScrollPosition(_key)\n\t  } catch (e) {\n\t    window.location[replace ? 'assign' : 'replace'](url)\n\t  }\n\t}\n\t\n\tfunction replaceState (url) {\n\t  pushState(url, true)\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar HashHistory = (function (History) {\n\t  function HashHistory (router, base, fallback) {\n\t    History.call(this, router, base)\n\t    // check history fallback deeplinking\n\t    if (fallback && this.checkFallback()) {\n\t      return\n\t    }\n\t    ensureSlash()\n\t  }\n\t\n\t  if ( History ) HashHistory.__proto__ = History;\n\t  HashHistory.prototype = Object.create( History && History.prototype );\n\t  HashHistory.prototype.constructor = HashHistory;\n\t\n\t  HashHistory.prototype.checkFallback = function checkFallback () {\n\t    var location = getLocation(this.base)\n\t    if (!/^\\/#/.test(location)) {\n\t      window.location.replace(\n\t        cleanPath(this.base + '/#' + location)\n\t      )\n\t      return true\n\t    }\n\t  };\n\t\n\t  HashHistory.prototype.onHashChange = function onHashChange () {\n\t    if (!ensureSlash()) {\n\t      return\n\t    }\n\t    this.transitionTo(getHash(), function (route) {\n\t      replaceHash(route.fullPath)\n\t    })\n\t  };\n\t\n\t  HashHistory.prototype.push = function push (location) {\n\t    this.transitionTo(location, function (route) {\n\t      pushHash(route.fullPath)\n\t    })\n\t  };\n\t\n\t  HashHistory.prototype.replace = function replace (location) {\n\t    this.transitionTo(location, function (route) {\n\t      replaceHash(route.fullPath)\n\t    })\n\t  };\n\t\n\t  HashHistory.prototype.go = function go (n) {\n\t    window.history.go(n)\n\t  };\n\t\n\t  HashHistory.prototype.ensureURL = function ensureURL (push) {\n\t    var current = this.current.fullPath\n\t    if (getHash() !== current) {\n\t      push ? pushHash(current) : replaceHash(current)\n\t    }\n\t  };\n\t\n\t  return HashHistory;\n\t}(History));\n\t\n\tfunction ensureSlash () {\n\t  var path = getHash()\n\t  if (path.charAt(0) === '/') {\n\t    return true\n\t  }\n\t  replaceHash('/' + path)\n\t  return false\n\t}\n\t\n\tfunction getHash () {\n\t  // We can't use window.location.hash here because it's not\n\t  // consistent across browsers - Firefox will pre-decode it!\n\t  var href = window.location.href\n\t  var index = href.indexOf('#')\n\t  return index === -1 ? '' : href.slice(index + 1)\n\t}\n\t\n\tfunction pushHash (path) {\n\t  window.location.hash = path\n\t}\n\t\n\tfunction replaceHash (path) {\n\t  var i = window.location.href.indexOf('#')\n\t  window.location.replace(\n\t    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n\t  )\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar AbstractHistory = (function (History) {\n\t  function AbstractHistory (router) {\n\t    History.call(this, router)\n\t    this.stack = []\n\t    this.index = -1\n\t  }\n\t\n\t  if ( History ) AbstractHistory.__proto__ = History;\n\t  AbstractHistory.prototype = Object.create( History && History.prototype );\n\t  AbstractHistory.prototype.constructor = AbstractHistory;\n\t\n\t  AbstractHistory.prototype.push = function push (location) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route)\n\t      this$1.index++\n\t    })\n\t  };\n\t\n\t  AbstractHistory.prototype.replace = function replace (location) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route)\n\t    })\n\t  };\n\t\n\t  AbstractHistory.prototype.go = function go (n) {\n\t    var this$1 = this;\n\t\n\t    var targetIndex = this.index + n\n\t    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n\t      return\n\t    }\n\t    var route = this.stack[targetIndex]\n\t    this.confirmTransition(route, function () {\n\t      this$1.index = targetIndex\n\t      this$1.updateRoute(route)\n\t    })\n\t  };\n\t\n\t  AbstractHistory.prototype.ensureURL = function ensureURL () {\n\t    // noop\n\t  };\n\t\n\t  return AbstractHistory;\n\t}(History));\n\t\n\t/*  */\n\t\n\tvar VueRouter = function VueRouter (options) {\n\t  if ( options === void 0 ) options = {};\n\t\n\t  this.app = null\n\t  this.options = options\n\t  this.beforeHooks = []\n\t  this.afterHooks = []\n\t  this.match = createMatcher(options.routes || [])\n\t\n\t  var mode = options.mode || 'hash'\n\t  this.fallback = mode === 'history' && !supportsHistory\n\t  if (this.fallback) {\n\t    mode = 'hash'\n\t  }\n\t  if (!inBrowser) {\n\t    mode = 'abstract'\n\t  }\n\t  this.mode = mode\n\t\n\t  switch (mode) {\n\t    case 'history':\n\t      this.history = new HTML5History(this, options.base)\n\t      break\n\t    case 'hash':\n\t      this.history = new HashHistory(this, options.base, this.fallback)\n\t      break\n\t    case 'abstract':\n\t      this.history = new AbstractHistory(this)\n\t      break\n\t    default:\n\t      (\"production\") !== 'production' && assert(false, (\"invalid mode: \" + mode))\n\t  }\n\t};\n\t\n\tvar prototypeAccessors = { currentRoute: {} };\n\t\n\tprototypeAccessors.currentRoute.get = function () {\n\t  return this.history && this.history.current\n\t};\n\t\n\tVueRouter.prototype.init = function init (app /* Vue component instance */) {\n\t    var this$1 = this;\n\t\n\t  (\"production\") !== 'production' && assert(\n\t    install.installed,\n\t    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n\t    \"before creating root instance.\"\n\t  )\n\t\n\t  this.app = app\n\t\n\t  var history = this.history\n\t\n\t  if (history instanceof HTML5History) {\n\t    history.transitionTo(getLocation(history.base))\n\t  } else if (history instanceof HashHistory) {\n\t    var setupHashListener = function () {\n\t      window.addEventListener('hashchange', function () {\n\t        history.onHashChange()\n\t      })\n\t    }\n\t    history.transitionTo(getHash(), setupHashListener, setupHashListener)\n\t  }\n\t\n\t  history.listen(function (route) {\n\t    this$1.app._route = route\n\t  })\n\t};\n\t\n\tVueRouter.prototype.beforeEach = function beforeEach (fn) {\n\t  this.beforeHooks.push(fn)\n\t};\n\t\n\tVueRouter.prototype.afterEach = function afterEach (fn) {\n\t  this.afterHooks.push(fn)\n\t};\n\t\n\tVueRouter.prototype.push = function push (location) {\n\t  this.history.push(location)\n\t};\n\t\n\tVueRouter.prototype.replace = function replace (location) {\n\t  this.history.replace(location)\n\t};\n\t\n\tVueRouter.prototype.go = function go (n) {\n\t  this.history.go(n)\n\t};\n\t\n\tVueRouter.prototype.back = function back () {\n\t  this.go(-1)\n\t};\n\t\n\tVueRouter.prototype.forward = function forward () {\n\t  this.go(1)\n\t};\n\t\n\tVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n\t  var route = to\n\t    ? this.resolve(to).resolved\n\t    : this.currentRoute\n\t  if (!route) {\n\t    return []\n\t  }\n\t  return [].concat.apply([], route.matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) {\n\t      return m.components[key]\n\t    })\n\t  }))\n\t};\n\t\n\tVueRouter.prototype.resolve = function resolve (\n\t  to,\n\t  current,\n\t  append\n\t) {\n\t  var normalizedTo = normalizeLocation(to, current || this.history.current, append)\n\t  var resolved = this.match(normalizedTo, current)\n\t  var fullPath = resolved.redirectedFrom || resolved.fullPath\n\t  var base = this.history.base\n\t  var href = createHref(base, fullPath, this.mode)\n\t  return {\n\t    normalizedTo: normalizedTo,\n\t    resolved: resolved,\n\t    href: href\n\t  }\n\t};\n\t\n\tObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\t\n\tfunction createHref (base, fullPath, mode) {\n\t  var path = mode === 'hash' ? '#' + fullPath : fullPath\n\t  return base ? cleanPath(base + '/' + path) : path\n\t}\n\t\n\tVueRouter.install = install\n\t\n\tif (inBrowser && window.Vue) {\n\t  window.Vue.use(VueRouter)\n\t}\n\t\n\tmodule.exports = VueRouter;\n\n/***/ },\n/* 200 */\n/***/ function(module, exports) {\n\n\tvar base = {\n\t  8: \"Backspace\",\n\t  9: \"Tab\",\n\t  10: \"Enter\",\n\t  12: \"NumLock\",\n\t  13: \"Enter\",\n\t  16: \"Shift\",\n\t  17: \"Control\",\n\t  18: \"Alt\",\n\t  20: \"CapsLock\",\n\t  27: \"Escape\",\n\t  32: \" \",\n\t  33: \"PageUp\",\n\t  34: \"PageDown\",\n\t  35: \"End\",\n\t  36: \"Home\",\n\t  37: \"ArrowLeft\",\n\t  38: \"ArrowUp\",\n\t  39: \"ArrowRight\",\n\t  40: \"ArrowDown\",\n\t  44: \"PrintScreen\",\n\t  45: \"Insert\",\n\t  46: \"Delete\",\n\t  59: \";\",\n\t  61: \"=\",\n\t  91: \"Meta\",\n\t  92: \"Meta\",\n\t  106: \"*\",\n\t  107: \"+\",\n\t  108: \",\",\n\t  109: \"-\",\n\t  110: \".\",\n\t  111: \"/\",\n\t  144: \"NumLock\",\n\t  145: \"ScrollLock\",\n\t  160: \"Shift\",\n\t  161: \"Shift\",\n\t  162: \"Control\",\n\t  163: \"Control\",\n\t  164: \"Alt\",\n\t  165: \"Alt\",\n\t  173: \"-\",\n\t  186: \";\",\n\t  187: \"=\",\n\t  188: \",\",\n\t  189: \"-\",\n\t  190: \".\",\n\t  191: \"/\",\n\t  192: \"`\",\n\t  219: \"[\",\n\t  220: \"\\\\\",\n\t  221: \"]\",\n\t  222: \"'\",\n\t  229: \"q\"\n\t}\n\tvar shift = {\n\t  48: \")\",\n\t  49: \"!\",\n\t  50: \"@\",\n\t  51: \"#\",\n\t  52: \"$\",\n\t  53: \"%\",\n\t  54: \"^\",\n\t  55: \"&\",\n\t  56: \"*\",\n\t  57: \"(\",\n\t  59: \";\",\n\t  61: \"+\",\n\t  173: \"_\",\n\t  186: \":\",\n\t  187: \"+\",\n\t  188: \"<\",\n\t  189: \"_\",\n\t  190: \">\",\n\t  191: \"?\",\n\t  192: \"~\",\n\t  219: \"{\",\n\t  220: \"|\",\n\t  221: \"}\",\n\t  222: \"\\\"\",\n\t  229: \"Q\"\n\t}\n\t\n\tvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\n\tvar brokenModifierNames = chrome && +chrome[1] < 57\n\t\n\t// Fill in the digit keys\n\tfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\t\n\t// The function keys\n\tfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\t\n\t// And the alphabetic keys\n\tfor (var i = 65; i <= 90; i++) {\n\t  base[i] = String.fromCharCode(i + 32)\n\t  shift[i] = String.fromCharCode(i)\n\t}\n\t\n\t// For each code that doesn't have a shift-equivalent, copy the base name\n\tfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\t\n\tfunction keyName(event) {\n\t  // Don't trust event.key in Chrome when there are modifiers until\n\t  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n\t  var name = ((!brokenModifierNames || !event.ctrlKey && !event.altKey && !event.metaKey) && event.key) ||\n\t    (event.shiftKey ? shift : base)[event.keyCode] ||\n\t    event.key || \"Unidentified\"\n\t  // Edge sometimes produces wrong names (Issue #3)\n\t  if (name == \"Esc\") name = \"Escape\"\n\t  if (name == \"Del\") name = \"Delete\"\n\t  return name\n\t}\n\t\n\tmodule.exports = keyName\n\tkeyName.base = base\n\tkeyName.shift = shift\n\n\n/***/ },\n/* 201 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 202 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/vendor.62133dbcf281a58ed4c6.js","exports.Node = require(\"./node\").Node\n;var assign;\n((assign = require(\"./resolvedpos\"), exports.ResolvedPos = assign.ResolvedPos, exports.NodeRange = assign.NodeRange))\nexports.Fragment = require(\"./fragment\").Fragment\n;var assign$1;\n((assign$1 = require(\"./replace\"), exports.Slice = assign$1.Slice, exports.ReplaceError = assign$1.ReplaceError))\nexports.Mark = require(\"./mark\").Mark\n\n;var assign$2;\n((assign$2 = require(\"./schema\"), exports.Schema = assign$2.Schema, exports.NodeType = assign$2.NodeType, exports.MarkType = assign$2.MarkType))\n;var assign$3;\n((assign$3 = require(\"./content\"), exports.ContentMatch = assign$3.ContentMatch))\n\nexports.DOMParser = require(\"./from_dom\").DOMParser\nexports.DOMSerializer =  require(\"./to_dom\").DOMSerializer\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/index.js\n// module id = 1\n// module chunks = 1",";var assign;\n((assign = require(\"./selection\"), exports.Selection = assign.Selection, exports.TextSelection = assign.TextSelection, exports.NodeSelection = assign.NodeSelection))\n\nexports.Transaction = require(\"./transaction\").Transaction\n\nexports.EditorState = require(\"./state\").EditorState\n\n;var assign$1;\n((assign$1 = require(\"./plugin\"), exports.Plugin = assign$1.Plugin, exports.PluginKey = assign$1.PluginKey))\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-state/dist/index.js\n// module id = 2\n// module chunks = 1","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks.js\n// module id = 3\n// module chunks = 1",";var assign;\n((assign = require(\"./transform\"), exports.Transform = assign.Transform, exports.TransformError = assign.TransformError))\n;var assign$1;\n((assign$1 = require(\"./step\"), exports.Step = assign$1.Step, exports.StepResult = assign$1.StepResult))\n;var assign$2;\n((assign$2 = require(\"./structure\"), exports.joinPoint = assign$2.joinPoint, exports.canJoin = assign$2.canJoin, exports.canSplit = assign$2.canSplit, exports.insertPoint = assign$2.insertPoint, exports.liftTarget = assign$2.liftTarget, exports.findWrapping = assign$2.findWrapping))\n;var assign$3;\n((assign$3 = require(\"./map\"), exports.StepMap = assign$3.StepMap, exports.MapResult = assign$3.MapResult, exports.Mapping = assign$3.Mapping))\n;var assign$4;\n((assign$4 = require(\"./mark_step\"), exports.AddMarkStep = assign$4.AddMarkStep, exports.RemoveMarkStep = assign$4.RemoveMarkStep))\n;var assign$5;\n((assign$5 = require(\"./replace_step\"), exports.ReplaceStep = assign$5.ReplaceStep, exports.ReplaceAroundStep = assign$5.ReplaceAroundStep))\nrequire(\"./mark\")\n;var assign$6;\n((assign$6 = require(\"./replace\"), exports.replaceStep = assign$6.replaceStep))\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/index.js\n// module id = 4\n// module chunks = 1","var ref = require(\"./diff\");\nvar findDiffStart = ref.findDiffStart;\nvar findDiffEnd = ref.findDiffEnd;\n\n// ::- Fragment is the type used to represent a node's collection of\n// child nodes.\n//\n// Fragments are persistent data structures. That means you should\n// _not_ mutate them or their content, but create new instances\n// whenever needed. The API tries to make this easy.\nvar Fragment = function(content, size) {\n  var this$1 = this;\n\n  this.content = content\n  this.size = size || 0\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this$1.size += content[i].nodeSize } }\n};\n\nvar prototypeAccessors = { firstChild: {},lastChild: {},childCount: {} };\n\nFragment.prototype.nodesBetween = function (from, to, f, nodeStart, parent) {\n    var this$1 = this;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this$1.content[i], end = pos + child.nodeSize\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start)\n    }\n    pos = end\n  }\n};\n\n// : (number, number, ?string, ?string) → string\nFragment.prototype.textBetween = function (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n      separated = !blockSeparator\n    } else if (node.isLeaf && leafText) {\n      text += leafText\n      separated = !blockSeparator\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator\n      separated = true\n    }\n  }, 0)\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the content of this fragment and\n// `other`.\nFragment.prototype.append = function (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text)\n    i = 1\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]) }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function (from, to) {\n    var this$1 = this;\n\n  if (to == null) { to = this.size }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this$1.content[i], end = pos + child.nodeSize\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)) }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)) }\n      }\n      result.push(child)\n      size += child.nodeSize\n    }\n    pos = end\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function (index, node) {\n  var current = this.content[index]\n  if (current == node) { return this }\n  var copy = this.content.slice()\n  var size = this.size + node.nodeSize - current.nodeSize\n  copy[index] = node\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function (other) {\n    var this$1 = this;\n\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this$1.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function (index) {\n  var found = this.content[index]\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → number\n// Get the offset at (size of children before) the given index.\nFragment.prototype.offsetAt = function (index) {\n    var this$1 = this;\n\n  var offset = 0\n  for (var i = 0; i < index; i++) { offset += this$1.content[i].nodeSize }\n  return offset\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function (f) {\n    var this$1 = this;\n\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this$1.content[i]\n    f(child, p, i)\n    p += child.nodeSize\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Node) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function (pos, round) {\n    var this$1 = this;\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this$1.child(i), end = curPos + cur.nodeSize\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function (schema, value) {\n  return value ? new Fragment(value.map(schema.nodeFromJSON)) : Fragment.empty\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same style are joined together.\nFragment.fromArray = function (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i]\n    size += node.nodeSize\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i) }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n    } else if (joined) {\n      joined.push(node)\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  return new Fragment([nodes], nodes.nodeSize)\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\nexports.Fragment = Fragment\n\nvar found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/fragment.js\n// module id = 5\n// module chunks = 1","var ref = require(\"./comparedeep\");\nvar compareDeep = ref.compareDeep;\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If a mark of this type with different\n// attributes is already in the set, a set in which it is replaced\n// by this one is returned.\nMark.prototype.addToSet = function (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i]\n    if (other.type == this$1.type) {\n      if (this$1.eq(other)) { return set }\n      var copy = set.slice()\n      copy[i] = this$1\n      return copy\n    }\n    if (other.type.rank > this$1.type.rank)\n      { return set.slice(0, i).concat(this$1).concat(set.slice(i)) }\n  }\n  return set.concat(this)\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (this$1.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (this$1.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function (other) {\n  if (this == other) { return true }\n  if (this.type != other.type) { return false }\n  if (!compareDeep(other.attrs, this.attrs)) { return false }\n  return true\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function () {\n    var this$1 = this;\n\n  var obj = {type: this.type.name}\n  for (var _ in this$1.attrs) {\n    obj.attrs = this$1.attrs\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function (schema, json) {\n  return schema.marks[json.type].create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice()\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; })\n  return copy\n};\nexports.Mark = Mark\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/mark.js\n// module id = 6\n// module chunks = 1","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 7\n// module chunks = 1","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 8\n// module chunks = 1","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 9\n// module chunks = 1","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 10\n// module chunks = 1","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 11\n// module chunks = 1","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 12\n// module chunks = 1","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 13\n// module chunks = 1","var ref = require(\"prosemirror-transform\");\nvar joinPoint = ref.joinPoint;\nvar canJoin = ref.canJoin;\nvar findWrapping = ref.findWrapping;\nvar liftTarget = ref.liftTarget;\nvar canSplit = ref.canSplit;\nvar ReplaceAroundStep = ref.ReplaceAroundStep;\nvar ref$1 = require(\"prosemirror-model\");\nvar Slice = ref$1.Slice;\nvar Fragment = ref$1.Fragment;\nvar ref$2 = require(\"prosemirror-state\");\nvar Selection = ref$2.Selection;\nvar TextSelection = ref$2.TextSelection;\nvar NodeSelection = ref$2.NodeSelection;\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) { return false }\n  if (dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var tr = state.tr.deleteSelection().scrollIntoView()\n    if ($from.sameParent($to) && $from.parent.isTextblock)\n      { tr.setStoredMarks($from.marks(true)) }\n    dispatch(tr)\n  }\n  return true\n}\nexports.deleteSelection = deleteSelection\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, move\n// that block closer to the block before it, by lifting it out of its\n// parent or, if it has no parent it doesn't share with the node\n// before it, moving it into a parent of that node, or joining it with\n// that. Will use the view for accurate start-of-textblock detection\n// if given.\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  if (!empty || (view ? !view.endOfTextblock(\"backward\", state)\n                      : $head.parentOffset > 0))\n    { return false }\n\n  // Find the node before this one\n  var before, cut\n  for (var i = $head.depth - 1; !before && i >= 0; i--) { if ($head.index(i) > 0) {\n    cut = $head.before(i + 1)\n    before = $head.node(i).child($head.index(i) - 1)\n  } }\n\n  // If there is no node before this, try to lift\n  if (!before) {\n    var range = $head.blockRange(), target = range && liftTarget(range)\n    if (target == null) { return false }\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n    return true\n  }\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if (before.isLeaf && NodeSelection.isSelectable(before) && $head.parent.content.size == 0) {\n    if (dispatch) {\n      var tr = state.tr.delete(cut, cut + $head.parent.nodeSize)\n      tr.setSelection(NodeSelection.create(tr.doc, cut - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node doesn't allow children, delete it\n  if (before.isLeaf) {\n    if (dispatch) { dispatch(state.tr.delete(cut - before.nodeSize, cut).scrollIntoView()) }\n    return true\n  }\n\n  // Apply the joining algorithm\n  return deleteBarrier(state, cut, dispatch) || selectNextNode(state, cut, -1, dispatch)\n}\nexports.joinBackward = joinBackward\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, move the node after it closer to the node with the\n// cursor (lifting it out of parents that aren't shared, moving it\n// into parents of the cursor block, or joining the two when they are\n// siblings). Will use the view for accurate start-of-textblock\n// detection if given.\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  if (!empty || (view ? !view.endOfTextblock(\"forward\", state)\n                      : $head.parentOffset < $head.parent.content.size))\n    { return false }\n\n  // Find the node after this one\n  var after, cut\n  for (var i = $head.depth - 1; !after && i >= 0; i--) {\n    var parent = $head.node(i)\n    if ($head.index(i) + 1 < parent.childCount) {\n      after = parent.child($head.index(i) + 1)\n      cut = $head.after(i + 1)\n    }\n  }\n\n  // If there is no node after this, there's nothing to do\n  if (!after) { return false }\n\n  // If the node doesn't allow children, delete it\n  if (after.isLeaf) {\n    if (dispatch) { dispatch(state.tr.delete(cut, cut + after.nodeSize).scrollIntoView()) }\n    return true\n  }\n  // Apply the joining algorithm\n  return deleteBarrier(state, cut, dispatch) || selectNextNode(state, cut, 1, dispatch)\n}\nexports.joinForward = joinForward\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nfunction joinUp(state, dispatch) {\n  var ref = state.selection;\n  var node = ref.node;\n  var from = ref.from;\n  var point\n  if (node) {\n    if (node.isTextblock || !canJoin(state.doc, from)) { return false }\n    point = from\n  } else {\n    point = joinPoint(state.doc, from, -1)\n    if (point == null) { return false }\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point)\n    if (state.selection.node) { tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)) }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\nexports.joinUp = joinUp\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nfunction joinDown(state, dispatch) {\n  var node = state.selection.node, nodeAt = state.selection.from\n  var point = joinPointBelow(state)\n  if (!point) { return false }\n  if (dispatch) {\n    var tr = state.tr.join(point)\n    if (node) { tr.setSelection(NodeSelection.create(tr.doc, nodeAt)) }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\nexports.joinDown = joinDown\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n  return true\n}\nexports.lift = lift\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var anchor = ref.anchor;\n  if (!$head || !$head.parent.type.spec.code || $head.sharedDepth(anchor) != $head.depth) { return false }\n  if (dispatch) { dispatch(state.tr.insertText(\"\\n\").scrollIntoView()) }\n  return true\n}\nexports.newlineInCode = newlineInCode\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var anchor = ref.anchor;\n  if (!$head || !$head.parent.type.spec.code || $head.sharedDepth(anchor) != $head.depth) { return false }\n  var above = $head.node(-1), after = $head.indexAfter(-1), type = above.defaultContentType(after)\n  if (!above.canReplaceWith(after, after, type)) { return false }\n  if (dispatch) {\n    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\nexports.exitCode = exitCode\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nfunction createParagraphNear(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var node = ref.node;\n  if (!node || !node.isBlock) { return false }\n  var type = $from.parent.defaultContentType($to.indexAfter())\n  if (!type || !type.isTextblock) { return false }\n  if (dispatch) {\n    var side = ($from.parentOffset ? $to : $from).pos\n    var tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\nexports.createParagraphNear = createParagraphNear\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  if (!empty || $head.parent.content.size) { return false }\n  if ($head.depth > 1 && $head.after() != $head.end(-1)) {\n    var before = $head.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()) }\n      return true\n    }\n  }\n  var range = $head.blockRange(), target = range && liftTarget(range)\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n  return true\n}\nexports.liftEmptyBlock = liftEmptyBlock\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var node = ref.node;\n  if (node && node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) { return false }\n    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()) }\n    return true\n  }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size\n    var tr = state.tr.delete($from.pos, $to.pos)\n    var deflt = $from.depth == 0 ? null : $from.node(-1).defaultContentType($from.indexAfter(-1))\n    var types = atEnd ? [{type: deflt}] : null\n    var can = canSplit(tr.doc, $from.pos, 1, types)\n    if (!types && !can && canSplit(tr.doc, $from.pos, 1, [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split($from.pos, 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent)))\n        { tr.setNodeType($from.before(), deflt) }\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\nexports.splitBlock = splitBlock\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nfunction selectParentNode(state, dispatch) {\n  var sel = state.selection, pos\n  if (sel.node) {\n    if (!sel.$from.depth) { return false }\n    pos = sel.$from.before()\n  } else {\n    var same = sel.$head.sharedDepth(sel.anchor)\n    if (same == 0) { return false }\n    pos = sel.$head.before(same)\n  }\n  if (dispatch) { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos))) }\n  return true\n}\nexports.selectParentNode = selectParentNode\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()) }\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1)) { return false }\n  if (dispatch)\n    { dispatch(state.tr\n             .clearNonMatching($pos.pos, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView()) }\n  return true\n}\n\nfunction deleteBarrier(state, cut, dispatch) {\n  var $cut = state.doc.resolve(cut), before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (joinMaybeClear(state, $cut, dispatch)) {\n    return true\n  } else if (after.isTextblock && $cut.parent.canReplace($cut.index(), $cut.index() + 1) &&\n             (conn = (match = before.contentMatchAt(before.childCount)).findWrappingFor(after)) &&\n             match.matchType((conn[0] || after).type, (conn[0] || after).attrs).validEnd()) {\n    if (dispatch) {\n      var end = cut + after.nodeSize, wrap = Fragment.empty\n      for (var i = conn.length - 1; i >= 0; i--)\n        { wrap = Fragment.from(conn[i].type.create(conn[i].attrs, wrap)) }\n      wrap = Fragment.from(before.copy(wrap))\n      var tr = state.tr.step(new ReplaceAroundStep(cut - 1, end, cut, end, new Slice(wrap, 1, 0), conn.length, true))\n      var joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) { tr.join(joinAt) }\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  } else {\n    var selAfter = Selection.findFrom($cut, 1)\n    var range = selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n    if (target == null) { return false }\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()) }\n    return true\n  }\n}\n\nfunction selectNextNode(state, cut, dir, dispatch) {\n  var $cut = state.doc.resolve(cut)\n  var node = dir > 0 ? $cut.nodeAfter : $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, cut - (dir > 0 ? 0 : node.nodeSize))).scrollIntoView()) }\n  return true\n}\n\n// Parameterized commands\n\nfunction joinPointBelow(state) {\n  var ref = state.selection;\n  var node = ref.node;\n  var to = ref.to;\n  if (node) { return canJoin(state.doc, to) ? to : null }\n  else { return joinPoint(state.doc, to, 1) }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nfunction wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) { return false }\n    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()) }\n    return true\n  }\n}\nexports.wrapIn = wrapIn\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the textblock around the\n// selection to the given node type with the given attributes.\nfunction setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n    var depth\n    if (node) {\n      depth = $from.depth\n    } else {\n      if (!$from.depth || $to.pos > $from.end()) { return false }\n      depth = $from.depth - 1\n    }\n    var target = node || $from.parent\n    if (!target.isTextblock || target.hasMarkup(nodeType, attrs)) { return false }\n    var index = $from.index(depth)\n    if (!$from.node(depth).canReplaceWith(index, index + 1, nodeType)) { return false }\n    if (dispatch) {\n      var where = $from.before(depth + 1)\n      dispatch(state.tr\n               .clearNonMatching(where, nodeType.contentExpr.start(attrs))\n               .setNodeType(where, nodeType, attrs)\n               .scrollIntoView())\n    }\n    return true\n  }\n}\nexports.setBlockType = setBlockType\n\nfunction markApplies(doc, from, to, type) {\n  var can = false\n  doc.nodesBetween(from, to, function (node) {\n    if (can) { return false }\n    can = node.isTextblock && node.contentMatchAt(0).allowsMark(type)\n  })\n  return can\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nfunction toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var from = ref.from;\n    var to = ref.to;\n    var $from = ref.$from;\n    if (!markApplies(state.doc, from, to, markType)) { return false }\n    if (dispatch) {\n      if (empty) {\n        if (markType.isInSet(state.storedMarks || $from.marks()))\n          { dispatch(state.tr.removeStoredMark(markType)) }\n        else\n          { dispatch(state.tr.addStoredMark(markType.create(attrs))) }\n      } else {\n        if (state.doc.rangeHasMark(from, to, markType))\n          { dispatch(state.tr.removeMark(from, to, markType).scrollIntoView()) }\n        else\n          { dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView()) }\n      }\n    }\n    return true\n  }\n}\nexports.toggleMark = toggleMark\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) { return dispatch(tr) }\n\n    var ranges = []\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i]\n      for (var j = 0; j < ranges.length; j++)\n        { ranges[j] = map.map(ranges[j]) }\n      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); })\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    var joinable = []\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1], to = ranges[i$1 + 1]\n      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index)\n        if (!after) { break }\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            { joinable.push(pos) }\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort(function (a, b) { return a - b; })\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]) }\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable\n    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; }\n  }\n  return function (state, dispatch) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable)); }\n}\nexports.autoJoin = autoJoin\n\n// :: (...[(EditorState, ?(tr: Transaction)) → bool]) → (EditorState, ?(tr: Transaction)) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nfunction chainCommands() {\n  var commands = [], len = arguments.length;\n  while ( len-- ) commands[ len ] = arguments[ len ];\n\n  return function(state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++)\n      { if (commands[i](state, dispatch, view)) { return true } }\n    return false\n  }\n}\nexports.chainCommands = chainCommands\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** to `deleteSelection`, `joinBackward`\n// * **Mod-Backspace** to `deleteSelection`, `joinBackward`\n// * **Delete** to `deleteSelection`, `joinForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`\n// * **Alt-ArrowUp** to `joinUp`\n// * **Alt-ArrowDown** to `joinDown`\n// * **Mod-BracketLeft** to `lift`\n// * **Escape** to `selectParentNode`\nvar baseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n\n  \"Backspace\": chainCommands(deleteSelection, joinBackward),\n  \"Mod-Backspace\": chainCommands(deleteSelection, joinBackward),\n  \"Delete\": chainCommands(deleteSelection, joinForward),\n  \"Mod-Delete\": chainCommands(deleteSelection, joinForward),\n\n  \"Alt-ArrowUp\": joinUp,\n  \"Alt-ArrowDown\": joinDown,\n  \"Mod-BracketLeft\": lift,\n  \"Escape\": selectParentNode\n}\n\n// declare global: os, navigator\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\nif (mac) {\n  var extra = {\n    \"Ctrl-h\": baseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": baseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": baseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": baseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": baseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": baseKeymap[\"Mod-Delete\"]\n  }\n  for (var prop in extra) { baseKeymap[prop] = extra[prop] }\n}\n\nexports.baseKeymap = baseKeymap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-commands/dist/commands.js\n// module id = 14\n// module chunks = 1","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// We'll denote those as 'mappable'.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position,\n//   and when to consider the position to be deleted.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of marked ranges. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff\nvar factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted\n  this.recover = recover\n};\nexports.MapResult = MapResult\n\n// ::- A map describing the deletions and insertions made by a step,\n// which can be used to find the correspondence between positions in\n// the pre-step version of a document and the same position in the\n// post-step version. This class implements [`Mappable`](#transform.Mappable).\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  this.ranges = ranges\n  this.inverted = inverted\n};\n\nStepMap.prototype.recover = function recover (value) {\n    var this$1 = this;\n\n  var diff = 0, index = recoverIndex(value)\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this$1.ranges[i * 3 + 2] - this$1.ranges[i * 3 + 1] } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// :: (number, ?number) → MapResult\n// Map the given position through this map. The `assoc` parameter can\n// be used to control what happens when the transform inserted\n// content at (or around) this position—if `assoc` is negative, the a\n// position before the inserted content will be returned, if it is\n// positive, a position after the insertion is returned.\nStepMap.prototype.mapResult = function mapResult (pos, assoc) { return this._map(pos, assoc, false) };\n\n// :: (number, ?number) → number\n// Map the given position through this map, returning only the\n// mapped position.\nStepMap.prototype.map = function map (pos, assoc) { return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n    var this$1 = this;\n\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0)\n    if (start > pos) { break }\n    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex], end = start + oldSize\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n      var result = start + diff + (side < 0 ? 0 : newSize)\n      if (simple) { return result }\n      var recover = makeRecover(i / 3, pos - start)\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n    var this$1 = this;\n\n  var diff = 0, index = recoverIndex(recover)\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0)\n    if (start > pos) { break }\n    var oldSize = this$1.ranges[i + oldIndex], end = start + oldSize\n    if (pos <= end && i == index * 3) { return true }\n    diff += this$1.ranges[i + newIndex] - oldSize\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges denoted by\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n    var this$1 = this;\n\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i], oldStart = start - (this$1.inverted ? diff : 0), newStart = start + (this$1.inverted ? 0 : diff)\n    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex]\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n    diff += newSize - oldSize\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\nexports.StepMap = StepMap\n\nStepMap.empty = new StepMap([])\n\n// ::- A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘rebasing’ steps for collaboration or history management.) This\n// class implements [`Mappable`](#transform.Mappable).\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || []\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0\n  // :: number\n  // The end positions in the `maps` array.\n  this.to = to == null ? this.maps.length : to\n  this.mirror = mirror\n};\n\n// :: (?number, ?number) → Mapping\n// Create a remapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\nMapping.prototype.getMirror = function getMirror (n) {\n    var this$1 = this;\n\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this$1.mirror[i] == n) { return this$1.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = [] }\n  this.mirror.push(n, m)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this remapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map)\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors) }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n    var this$1 = this;\n\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i)\n    this$1.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n  }\n};\n\n// :: (number, ?number) → number\n// Map a position through this remapping.\nMapping.prototype.map = function map (pos, assoc) {\n    var this$1 = this;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this$1.maps[i].map(pos, assoc) }\n  return pos\n};\n\n// :: (number, ?number) → MapResult\n// Map a position through this remapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) { return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n    var this$1 = this;\n\n  var deleted = false, recoverables = null\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this$1.maps[i], rec = recoverables && recoverables[i]\n    if (rec != null && map.touches(pos, rec)) {\n      pos = map.recover(rec)\n      continue\n    }\n\n    var result = map.mapResult(pos, assoc)\n    if (result.recover != null) {\n      var corr = this$1.getMirror(i)\n      if (corr != null && corr > i && corr < this$1.to) {\n        if (result.deleted) {\n          i = corr\n          pos = this$1.maps[corr].recover(result.recover)\n          continue\n        } else {\n          ;(recoverables || (recoverables = Object.create(null)))[corr] = result.recover\n        }\n      }\n    }\n\n    if (result.deleted) { deleted = true }\n    pos = result.pos\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\nexports.Mapping = Mapping\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/map.js\n// module id = 15\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Slice = ref.Slice;\n\nvar ref$1 = require(\"./step\");\nvar Step = ref$1.Step;\nvar StepResult = ref$1.StepResult;\nvar ref$2 = require(\"./map\");\nvar StepMap = ref$2.StepMap;\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = (function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this)\n    this.from = from\n    this.to = to\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  if ( Step ) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure != this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openRight && !other.slice.openLeft) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openLeft, other.slice.openRight)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openLeft && !other.slice.openRight) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openLeft, this.slice.openRight)\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) { json.slice = this.slice.toJSON() }\n    if (this.structure) { json.structure = true }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\nexports.ReplaceStep = ReplaceStep\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = (function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this)\n    this.from = from\n    this.to = to\n    this.gapFrom = gapFrom\n    this.gapTo = gapTo\n    this.slice = slice\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openLeft || gap.openRight)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, slice: this.slice.toJSON()}\n    if (this.structure) { json.structure = true }\n    return true\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\nexports.ReplaceAroundStep = ReplaceAroundStep\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/replace_step.js\n// module id = 16\n// module chunks = 1","var ref = require(\"./map\");\nvar Mapping = ref.Mapping;\n\nvar TransformError = (function (Error) {\n  function TransformError () {\n    Error.apply(this, arguments);\n  }if ( Error ) TransformError.__proto__ = Error;\n  TransformError.prototype = Object.create( Error && Error.prototype );\n  TransformError.prototype.constructor = TransformError;\n\n  \n\n  return TransformError;\n}(Error));\nexports.TransformError = TransformError\n\n// ::- Abstraction to build up and track such an array of\n// [steps](#transform.Step).\n//\n// The high-level transforming methods return the `Transform` object\n// itself, so that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = []\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = []\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping\n};\n\nvar prototypeAccessors = { before: {} };\n\n// :: Node The document at the start of the transformation.\nprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → Transform\n// Apply a new step in this transformation, saving the result.\n// Throws an error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object)\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc)\n  if (!result.failed) { this.addStep(step, result.doc) }\n  return result\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc)\n  this.steps.push(step)\n  this.mapping.appendMap(step.getMap())\n  this.doc = doc\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors );\nexports.Transform = Transform\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/transform.js\n// module id = 17\n// module chunks = 1","var result = module.exports = {}\n\nif (typeof navigator != \"undefined\") {\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent)\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n  result.mac = /Mac/.test(navigator.platform)\n  result.ie = ie_upto10 || !!ie_11up\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up && +ie_11up[1]\n  result.gecko = /gecko\\/\\d/i.test(navigator.userAgent)\n  result.ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n  result.webkit = 'WebkitAppearance' in document.documentElement.style\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/browser.js\n// module id = 18\n// module chunks = 1","/*!\n * Vue.js v2.1.8\n * (c) 2014-2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val, 10);\n  return (n || n === 0) ? n : val\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delmited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b)\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set$1 (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set$1(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tidentity: identity,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tisServerRendering: isServerRendering,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    var watcher = queue[index];\n    var id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            process.env.NODE_ENV !== 'production' && warn(\n              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n              this.vm\n            );\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, props) {\n  var propsData = vm.$options.propsData || {};\n  var keys = vm.$options._propKeys = Object.keys(props);\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( i ) {\n    var key = keys[i];\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) loop( i );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm, computed) {\n  for (var key in computed) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && key in vm) {\n      warn(\n        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n        \"overwritten by a computed property with the same name.\",\n        vm\n      );\n    }\n    var userDef = computed[key];\n    if (typeof userDef === 'function') {\n      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n      computedSharedDefinition.set = noop;\n    } else {\n      computedSharedDefinition.get = userDef.get\n        ? userDef.cache !== false\n          ? makeComputedGetter(userDef.get, vm)\n          : bind$1(userDef.get, vm)\n        : noop;\n      computedSharedDefinition.set = userDef.set\n        ? bind$1(userDef.set, vm)\n        : noop;\n    }\n    Object.defineProperty(vm, key, computedSharedDefinition);\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm, methods) {\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production' && methods[key] == null) {\n      warn(\n        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n        \"Did you reference the function correctly?\",\n        vm\n      );\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set$1;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.child = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, fn, event, capture, once;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      once = name.charAt(0) === '~'; // Prefixed last, checked first\n      event = once ? name.slice(1) : name;\n      capture = event.charAt(0) === '!';\n      event = capture ? event.slice(1) : event;\n      if (Array.isArray(cur)) {\n        add(event, (cur.invoker = arrInvoker(cur)), once, capture);\n      } else {\n        if (!cur.invoker) {\n          fn = cur;\n          cur = on[name] = {};\n          cur.fn = fn;\n          cur.invoker = fnInvoker(cur);\n        }\n        add(event, cur.invoker, once, capture);\n      }\n    } else if (cur !== old) {\n      if (Array.isArray(old)) {\n        old.length = cur.length;\n        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n        on[name] = old;\n      } else {\n        old.fn = cur;\n        on[name] = old;\n      }\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      once = name.charAt(0) === '~'; // Prefixed last, checked first\n      event = once ? name.slice(1) : name;\n      capture = event.charAt(0) === '!';\n      event = capture ? event.slice(1) : event;\n      remove$$1(event, oldOn[name].invoker, capture);\n    }\n  }\n}\n\nfunction arrInvoker (arr) {\n  return function (ev) {\n    var arguments$1 = arguments;\n\n    var single = arguments.length === 1;\n    for (var i = 0; i < arr.length; i++) {\n      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n    }\n  }\n}\n\nfunction fnInvoker (o) {\n  return function (ev) {\n    var single = arguments.length === 1;\n    single ? o.fn(ev) : o.fn.apply(null, arguments);\n  }\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// nomralization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constrcuts that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add$1 (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$2 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true;\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    if (vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (\n  vnode,\n  hydrating,\n  parentElm,\n  refElm\n) {\n  if (!vnode.child || vnode.child._isDestroyed) {\n    var child = vnode.child = createComponentInstanceForVnode(\n      vnode,\n      activeInstance,\n      parentElm,\n      refElm\n    );\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.child = oldVnode.child;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.child._isMounted) {\n    vnode.child._isMounted = true;\n    callHook(vnode.child, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.child._inactive = false;\n    callHook(vnode.child, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.child._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.child.$destroy();\n    } else {\n      vnode.child._inactive = true;\n      callHook(vnode.child, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = {};\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (_parentVnode && _parentVnode.data.scopedSlots) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n        }\n        throw e\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // convert text to vnode\n  Vue.prototype._v = createTextVNode;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = createEmptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        extend(props, bindObject);\n      }\n      return scopedSlotFn(props) || fallback\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && process.env.NODE_ENV !== 'production') {\n        slotNodes._rendered && warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback\n    }\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        process.env.NODE_ENV !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var hash = asProp || config.mustUseProp(tag, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // check v-on keyCodes\n  Vue.prototype._k = function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInAlias\n  ) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  };\n}\n\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    initRender(vm);\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      extendOptions._scopeId = options._scopeId;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else {\n    return pattern.test(name)\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    if (vnode && vnode.componentOptions) {\n      var opts = vnode.componentOptions;\n      // check pattern\n      var name = opts.Ctor.options.name || opts.tag;\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? opts.Ctor.cid + (opts.tag ? (\"::\" + (opts.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.child = this.cache[key].child;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  },\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      var vnode = this$1.cache[key];\n      callHook(vnode.child, 'deactivated');\n      vnode.child.$destroy();\n    }\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set$1;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.1.8';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.child) {\n    childNode = childNode.child._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.child || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.child) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.child)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.child) {\n      innerNode = innerNode.child._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.child) {\n      vnode = vnode.child._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.child.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.child = oldVnode.child;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.child)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var elm, parent;\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        elm = oldVnode.elm;\n        parent = nodeOps.parentNode(elm);\n        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parent !== null) {\n          removeVnodes(parent, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar target$1;\n\nfunction add$2 (event, handler, once, capture) {\n  if (once) {\n    var oldHandler = handler;\n    handler = function (ev) {\n      remove$3(event, handler, capture);\n      arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$3 (event, handler, capture) {\n  target$1.removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n    // #4521: if a click event triggers update before the change event is\n    // dispatched on a checkbox/radio input, the input's checked state will\n    // be reset and fail to trigger another update.\n    /* istanbul ignore next */\n    if (key === 'checked' && !isDirty(elm, cur)) {\n      continue\n    }\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  if (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(vnode, checkVal)\n  )) {\n    return true\n  }\n  return false\n}\n\nfunction isDirty (elm, checkVal) {\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (vnode, newVal) {\n  var value = vnode.elm.value;\n  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.child) {\n      childNode = childNode.child._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\nvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.context === vnode.context &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    leaveToClass: (name + \"-leave-to\"),\n    appearToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.child && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.child._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    var key = child.key = child.key == null || child.isStatic\n      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n      : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.isUnknownElement = isUnknownElement;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n// wrap mount\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\nif (process.env.NODE_ENV !== 'production' &&\n    inBrowser && typeof console !== 'undefined') {\n  console[console.info ? 'info' : 'log'](\n    \"You are running Vue in development mode.\\n\" +\n    \"Make sure to turn on production mode when deploying for production.\\n\" +\n    \"See more tips at https://vuejs.org/guide/deployment.html\"\n  );\n}\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\n      process.env.NODE_ENV !== 'production' &&\n      inBrowser && !isEdge && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isScriptOrStyle = makeMap('script,style', true);\nvar hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };\nvar isSpecialTag = function (tag, isSFC, stack) {\n  if (isScriptOrStyle(tag)) {\n    return true\n  }\n  if (isSFC && stack.length === 1) {\n    // top-level template that has no pre-processor\n    if (tag === 'template' && !stack[0].attrs.some(hasLang)) {\n      return false\n    } else {\n      return true\n    }\n  }\n  return false\n};\n\nvar reCache = {};\n\nvar ltRE = /&lt;/g;\nvar gtRE = /&gt;/g;\nvar nlRE = /&#10;/g;\nvar ampRE = /&amp;/g;\nvar quoteRE = /&quot;/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  if (shouldDecodeNewlines) {\n    value = value.replace(nlRE, '\\n');\n  }\n  return value\n    .replace(ltRE, '<')\n    .replace(gtRE, '>')\n    .replace(ampRE, '&')\n    .replace(quoteRE, '\"')\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd > 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last && options.chars) {\n      options.chars(html);\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag('', lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag('', tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tag, tagName, start, end) {\n    var pos;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      var needle = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].tag.toLowerCase() === needle) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (tagName.toLowerCase() === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (tagName.toLowerCase() === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !/[\\w$]/.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue parser]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\nvar bindRE = /^:|^v-bind:/;\nvar onRE = /^@|^v-on:/;\nvar argRE = /:(.*)$/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$1;\nvar platformGetTagNamespace;\nvar platformMustUseProp;\nvar platformIsPreTag;\nvar preTransforms;\nvar transforms;\nvar postTransforms;\nvar delimiters;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$1 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$1(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production' && !warned) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warned = true;\n            warn$1(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes:\\n' + template\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warned = true;\n            warn$1(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements:\\n' + template\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production' && !warned) {\n          warned = true;\n          warn$1(\n            \"Component template should contain exactly one root element:\" +\n            \"\\n\\n\" + template + \"\\n\\n\" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {\n          warned = true;\n          warn$1(\n            'Component template requires a root element, rather than just text:\\n\\n' + template\n          );\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n          currentParent.children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$1(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$1(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once = getAndRemoveAttr(el, 'v-once');\n  if (once != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$1(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, arg, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        if (argMatch && (arg = argMatch[1])) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$1(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n      // #4530 also bind special attributes as props even if they are static\n      // so that patches between dynamic/static are consistent\n      if (platformMustUseProp(el.tag, name)) {\n        if (name === 'value') {\n          addProp(el, name, JSON.stringify(value));\n        } else {\n          addProp(el, name, 'true');\n        }\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$1('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: 'if($event.target !== $event.currentTarget)return;',\n  ctrl: 'if(!$event.ctrlKey)return;',\n  shift: 'if(!$event.shiftKey)return;',\n  alt: 'if(!$event.altKey)return;',\n  meta: 'if(!$event.metaKey)return;'\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  } else if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  } else if (!handler.modifiers) {\n    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\")\n  } else {\n    var code = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        code += modifierCode[key];\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code = genKeyFilter(keys) + code;\n    }\n    var handlerCode = simplePathRE.test(handler.value)\n      ? handler.value + '($event)'\n      : handler.value;\n    return 'function($event){' + code + handlerCode + '}'\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$2 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$2,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$2;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$2 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$2);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$2('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n}\n\nfunction genScopedSlot (key, el) {\n  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = getNormalizationType(children);\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n        ? normalizationType ? (\",\" + normalizationType) : ''\n        : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (needsNormalization(el) ||\n        (el.if && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.if && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return el.type === 1 && !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n/**\n * Compile a template.\n */\nfunction compile$1 (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\n/*  */\n\n// operators like typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"- avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n      );\n    } else {\n      errors.push((\"- invalid expression: \" + text));\n    }\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nvar warn$3;\n\nfunction model$1 (\n  el,\n  dir,\n  _warn\n) {\n  warn$3 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$3(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n  }\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else {\n    genDefaultModel(el, value, modifiers);\n  }\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (el.tag === 'input' && el.attrsMap.value) {\n      warn$3(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n        'inline value attributes will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n    if (el.tag === 'textarea' && el.children.length) {\n      warn$3(\n        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n        'inline content inside <textarea> will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n  }\n\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n  var needCompositionGuard = !lazy && type !== 'range';\n  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n  var valueExpression = isNative\n    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n  valueExpression = number || type === 'number'\n    ? (\"_n(\" + valueExpression + \")\")\n    : valueExpression;\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (isNative && needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  // inputs with type=\"file\" are read only and setting the input's\n  // value will throw an error.\n  if (process.env.NODE_ENV !== 'production' &&\n      type === 'file') {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n      \"File inputs are read only. Use a v-on:change listener instead.\"\n    );\n  }\n\n  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    el.children.some(checkOptionWarning);\n  }\n\n  var number = modifiers && modifiers.number;\n  var assignment = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n    (el.attrsMap.multiple == null ? '[0]' : '');\n\n  var code = genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction checkOptionWarning (option) {\n  if (option.type === 1 &&\n    option.tag === 'option' &&\n    option.attrsMap.selected != null) {\n    warn$3(\n      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n      'inline selected attributes on <option> will be ignored when using v-model. ' +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n    return true\n  }\n  return false\n}\n\nfunction genAssignmentCode (value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model$1,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar cache = Object.create(null);\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  staticKeys: genStaticKeys(modules$1),\n  directives: directives$1,\n  isReservedTag: isReservedTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  getTagNamespace: getTagNamespace,\n  isPreTag: isPreTag\n};\n\nfunction compile$$1 (\n  template,\n  options\n) {\n  options = options\n    ? extend(extend({}, baseOptions), options)\n    : baseOptions;\n  return compile$1(template, options)\n}\n\nfunction compileToFunctions (\n  template,\n  options,\n  vm\n) {\n  var _warn = (options && options.warn) || warn;\n  // detect possible CSP restriction\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      new Function('return 1');\n    } catch (e) {\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        _warn(\n          'It seems you are using the standalone build of Vue.js in an ' +\n          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n          'The template compiler cannot work in this environment. Consider ' +\n          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n          'templates into render functions.'\n        );\n      }\n    }\n  }\n  var key = options && options.delimiters\n    ? String(options.delimiters) + template\n    : template;\n  if (cache[key]) {\n    return cache[key]\n  }\n  var res = {};\n  var compiled = compile$$1(template, options);\n  res.render = makeFunction(compiled.render);\n  var l = compiled.staticRenderFns.length;\n  res.staticRenderFns = new Array(l);\n  for (var i = 0; i < l; i++) {\n    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n      _warn(\n        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n        detectErrors(compiled.ast).join('\\n') +\n        '\\n\\n',\n        vm\n      );\n    }\n  }\n  return (cache[key] = res)\n}\n\nfunction makeFunction (code) {\n  try {\n    return new Function(code)\n  } catch (e) {\n    return noop\n  }\n}\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      var ref = compileToFunctions(template, {\n        warn: warn,\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.common.js\n// module id = 19\n// module chunks = 1","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 20\n// module chunks = 1","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 21\n// module chunks = 1","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 22\n// module chunks = 1","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 23\n// module chunks = 1","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iterators.js\n// module id = 24\n// module chunks = 1","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 25\n// module chunks = 1","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 26\n// module chunks = 1","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 27\n// module chunks = 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 28\n// module chunks = 1","var RopeSequence = require(\"rope-sequence\")\nvar ref = require(\"prosemirror-transform\");\nvar Mapping = ref.Mapping;\nvar ref$1 = require(\"prosemirror-state\");\nvar Selection = ref$1.Selection;\nvar Plugin = ref$1.Plugin;\nvar PluginKey = ref$1.PluginKey;\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection JSON representation is\n// the start of an 'event' — a group of changes that will be undone\n// or redone at once. (It stores only the JSON, since that way we don't\n// have to provide a document until the selection is actually applied,\n// which is useful when compressing.)\n\n// Used to schedule history compression\nvar max_empty_items = 500\n\nvar Branch = function Branch(items, eventCount) {\n  this.items = items\n  this.eventCount = eventCount\n};\n\n// : (Node, bool, ?Item) → ?{transform: Transform, selection: Object}\n// Pop the latest event off the branch's history and apply it\n// to a document transform.\nBranch.prototype.popEvent = function popEvent (state, preserveItems) {\n    var this$1 = this;\n\n  if (this.eventCount == 0) { return null }\n\n  var end = this.items.length\n  for (;; end--) {\n    var next = this$1.items.get(end - 1)\n    if (next.selection) { --end; break }\n  }\n\n  var remap, mapFrom\n  if (preserveItems) {\n    remap = this.remapping(end, this.items.length)\n    mapFrom = remap.maps.length\n  }\n  var transform = state.tr\n  var selection, remaining\n  var addAfter = [], addBefore = []\n\n  this.items.forEach(function (item, i) {\n    if (!item.step) {\n      if (!remap) {\n        remap = this$1.remapping(end, i + 1)\n        mapFrom = remap.maps.length\n      }\n      mapFrom--\n      addBefore.push(item)\n      return\n    }\n\n    if (remap) {\n      addBefore.push(new Item(item.map))\n      var step = item.step.map(remap.slice(mapFrom)), map\n\n      if (step && transform.maybeStep(step).doc) {\n        map = transform.mapping.maps[transform.mapping.maps.length - 1]\n        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n      }\n      mapFrom--\n      if (map) { remap.appendMap(map, mapFrom) }\n    } else {\n      transform.maybeStep(item.step)\n    }\n\n    if (item.selection) {\n      selection = remap ? Selection.mapJSON(item.selection, remap.slice(mapFrom)) : item.selection\n      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1)\n      return false\n    }\n  }, this.items.length, 0)\n\n  return {remaining: remaining, transform: transform, selection: selection}\n};\n\n// : (Transform, Selection, Object)\n// Create a new branch with the given transform added.\nBranch.prototype.addTransform = function addTransform (transform, selection, histOptions) {\n  var newItems = [], eventCount = this.eventCount + (selection ? 1 : 0)\n  var oldItems = this.items, lastItem = !histOptions.preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n  for (var i = 0; i < transform.steps.length; i++) {\n    var step = transform.steps[i].invert(transform.docs[i])\n    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0)\n    if (merged = lastItem && lastItem.merge(item)) {\n      item = merged\n      if (i) { newItems.pop() }\n      else { oldItems = oldItems.slice(0, oldItems.length - 1) }\n    }\n    newItems.push(item)\n    selection = null\n    if (!histOptions.preserveItems) { lastItem = item }\n  }\n  var overflow = this.eventCount - histOptions.depth\n  if (overflow > DEPTH_OVERFLOW) { oldItems = cutOffEvents(oldItems, overflow) }\n  return new Branch(oldItems.append(newItems), eventCount)\n};\n\nBranch.prototype.remapping = function remapping (from, to) {\n  var maps = [], mirrors = []\n  this.items.forEach(function (item, i) {\n    if (item.mirrorOffset != null) {\n      var mirrorPos = i - item.mirrorOffset\n      if (mirrorPos >= from) { mirrors.push(maps.length - item.mirrorOffset, maps.length) }\n    }\n    maps.push(item.map)\n  }, from, to)\n  return new Mapping(maps, mirrors)\n};\n\nBranch.prototype.addMaps = function addMaps (array) {\n  if (this.eventCount == 0) { return this }\n  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)\n};\n\n// : ([StepMap], Transform, [number])\n// When the collab module receives remote changes, the history has\n// to know about those, so that it can adjust the steps that were\n// rebased on top of the remote changes, and include the position\n// maps for the remote changes in its array of items.\nBranch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {\n  if (!this.eventCount) { return this }\n\n  var rebasedItems = [], start = this.items.length - rebasedCount, startPos = 0\n  if (start < 0) {\n    startPos = -start\n    start = 0\n  }\n\n  var mapping = rebasedTransform.mapping\n  var newUntil = rebasedTransform.steps.length\n\n  var iRebased = startPos\n  this.items.forEach(function (item) {\n    var pos = mapping.getMirror(iRebased++)\n    if (pos == null) { return }\n    newUntil = Math.min(newUntil, pos)\n    var map = mapping.maps[pos]\n    if (item.step) {\n      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n      var selection = item.selection && Selection.mapJSON(item.selection, mapping.slice(iRebased - 1, pos))\n      rebasedItems.push(new Item(map, step, selection))\n    } else {\n      rebasedItems.push(new Item(map))\n    }\n  }, start)\n\n  var newMaps = []\n  for (var i = rebasedCount; i < newUntil; i++)\n    { newMaps.push(new Item(mapping.maps[i])) }\n  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n  var branch = new Branch(items, this.eventCount) // FIXME might update event count\n  if (branch.emptyItemCount() > max_empty_items)\n    { branch = branch.compress(this.items.length - rebasedItems.length) }\n  return branch\n};\n\nBranch.prototype.emptyItemCount = function emptyItemCount () {\n  var count = 0\n  this.items.forEach(function (item) { if (!item.step) { count++ } })\n  return count\n};\n\n// Compressing a branch means rewriting it to push the air (map-only\n// items) out. During collaboration, these naturally accumulate\n// because each remote change adds one. The `upto` argument is used\n// to ensure that only the items below a given level are compressed,\n// because `rebased` relies on a clean, untouched set of items in\n// order to associate old items with rebased steps.\nBranch.prototype.compress = function compress (upto) {\n    if ( upto === void 0 ) upto = this.items.length;\n\n  var remap = this.remapping(0, upto), mapFrom = remap.maps.length\n  var items = [], events = 0\n  this.items.forEach(function (item, i) {\n    if (i >= upto) {\n      items.push(item)\n    } else if (item.step) {\n      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n      mapFrom--\n      if (map) { remap.appendMap(map, mapFrom) }\n      if (step) {\n        var selection = item.selection && Selection.mapJSON(item.selection, remap.slice(mapFrom))\n        if (selection) { events++ }\n        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n        if (merged = items.length && items[last].merge(newItem))\n          { items[last] = merged }\n        else\n          { items.push(newItem) }\n      }\n    } else if (item.map) {\n      mapFrom--\n    }\n  }, this.items.length, 0)\n  return new Branch(RopeSequence.from(items.reverse()), events)\n};\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  var cutPoint\n  items.forEach(function (item, i) {\n    if (item.selection && (--n == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nvar Item = function Item(map, step, selection, mirrorOffset) {\n  this.map = map\n  this.step = step\n  this.selection = selection\n  this.mirrorOffset = mirrorOffset\n};\n\nItem.prototype.merge = function merge (other) {\n  if (this.step && other.step && !other.selection) {\n    var step = other.step.merge(this.step)\n    if (step) { return new Item(step.getMap().invert(), step, this.selection) }\n  }\n};\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nvar HistoryState = function HistoryState(done, undone, prevMap, prevTime) {\n  this.done = done\n  this.undone = undone\n  this.prevMap = prevMap\n  this.prevTime = prevTime\n};\nexports.HistoryState = HistoryState\n\nvar DEPTH_OVERFLOW = 20\n\n// : (EditorState, Transform, Selection, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, selection, tr, options) {\n  var newState = tr.getMeta(historyKey), rebased\n  if (newState) {\n    return newState\n  } else if (tr.steps.length == 0) {\n    if (tr.getMeta(closeHistoryKey)) { return new HistoryState(history.done, history.undone, null, 0) }\n    else { return history }\n  } else if (tr.getMeta(\"addToHistory\") !== false) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n        !isAdjacentToLastStep(tr, history.prevMap, history.done)\n    return new HistoryState(history.done.addTransform(tr, newGroup ? selection.toJSON() : null, options),\n                            Branch.empty, tr.mapping.maps[tr.steps.length - 1], tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            history.prevMap && tr.mapping.maps[tr.steps.length - 1], history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            history.prevMap, history.prevTime)\n  }\n}\n\nfunction isAdjacentToLastStep(transform, prevMap, done) {\n  if (!prevMap) { return false }\n  var firstMap = transform.mapping.maps[0], adjacent = false\n  if (!firstMap) { return true }\n  firstMap.forEach(function (start, end) {\n    done.items.forEach(function (item) {\n      if (item.step) {\n        prevMap.forEach(function (_start, _end, rStart, rEnd) {\n          if (start <= rEnd && end >= rStart) { adjacent = true }\n        })\n        return false\n      } else {\n        start = item.map.invert().map(start, -1)\n        end = item.map.invert().map(end, 1)\n      }\n    }, done.items.length, 0)\n  })\n  return adjacent\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and optionally\n// shift the event onto the other branch. Returns true when an event could\n// be shifted.\nfunction histTransaction(history, state, dispatch, redo) {\n  var histOptions = historyKey.get(state).options.config\n  var pop = (redo ? history.undone : history.done).popEvent(state, histOptions.preserveItems)\n  if (!pop) { return }\n\n  var selectionBefore = state.selection\n  var selection = Selection.fromJSON(pop.transform.doc, pop.selection)\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, selectionBefore.toJSON(), histOptions)\n\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, newHist).scrollIntoView())\n}\n\nfunction closeHistory(state) {\n  return state.tr.setMeta(closeHistoryKey, true)\n}\nexports.closeHistory = closeHistory\n\nvar historyKey = new PluginKey(\"history\")\nvar closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which the\n// [`undo`](##history.undo) and [`redo`](##history.redo) commands can\n// use to move the state back and forward.\n//\n// Note that this implementation doesn't implement history by simply\n// resetting back to some previous state. In order to support\n// collaborative editing (as well as some other use cases), it\n// selectively rolls back some transactions, but not other (for\n// example, not the changes made by other users). You can set an\n// `\"addToHistory\"` [metadata property](##state.Transaction.setMeta)\n// of `false` on a transaction to prevent it from being rolled back by\n// undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\n//\n//     preserveItems:: ?bool\n//     Whether to preserve the steps exactly as they came in. **Must**\n//     be true when using the history together with the collaborative\n//     editing plugin, to allow syncing the history when concurrent\n//     changes come in. Defaults to false.\nfunction history(config) {\n  config = {depth: config && config.depth || 100,\n            preserveItems: !!(config && config.preserveItems),\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state.selection, tr, config)\n      }\n    },\n\n    config: config\n  })\n}\nexports.history = history\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nfunction undo(state, dispatch) {\n  var hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, false) }\n  return true\n}\nexports.undo = undo\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nfunction redo(state, dispatch) {\n  var hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, true) }\n  return true\n}\nexports.redo = redo\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\nexports.undoDepth = undoDepth\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\nexports.redoDepth = redoDepth\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-history/dist/history.js\n// module id = 29\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar Plugin = ref.Plugin;\nvar PluginKey = ref.PluginKey;\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nvar InputRule = function InputRule(match, handler) {\n  this.match = match\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n};\nexports.InputRule = InputRule\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    var insert = string\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      var cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    var marks = state.doc.resolve(start).marks()\n    return state.tr.replaceWith(start, end, state.schema.text(insert, marks))\n  }\n}\n\nvar MAX_MATCH = 100\n\nvar stateKey = new PluginKey(\"fromInputRule\")\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action, and binds the backspace key, when applied directly after an\n// input rule triggered, to undo the rule's effect.\nfunction inputRules(ref) {\n  var rules = ref.rules;\n\n  return new Plugin({\n    state: {\n      init: function init() { return null },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(stateKey)\n        if (stored) { return stored }\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        var state = view.state, $from = state.doc.resolve(from)\n        var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                                  null, \"\\ufffc\") + text\n        for (var i = 0; i < rules.length; i++) {\n          var match = rules[i].match.exec(textBefore)\n          var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n          if (!tr) { continue }\n          view.dispatch(tr.setMeta(stateKey, {transform: tr, from: from, to: to, text: text}))\n          return true\n        }\n        return false\n      },\n\n      handleKeyDown: function handleKeyDown(view, event) {\n        if (event.keyCode == 8) { return maybeUndoInputRule(view.state, view.dispatch, this.getState(view.state)) }\n        return false\n      }\n    }\n  })\n}\nexports.inputRules = inputRules\n\nfunction maybeUndoInputRule(state, dispatch, undoable) {\n  if (!undoable) { return false }\n  var tr = state.tr, toUndo = undoable.transform\n  for (var i = toUndo.steps.length - 1; i >= 0; i--)\n    { tr.step(toUndo.steps[i].invert(toUndo.docs[i])) }\n  var marks = tr.doc.resolve(undoable.from).marks()\n  dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)))\n  return true\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-inputrules/dist/inputrules.js\n// module id = 30\n// module chunks = 1","var ref = require(\"./fragment\");\nvar Fragment = ref.Fragment;\n\n// ::- Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\nvar ReplaceError = (function (Error) {\n  function ReplaceError(message) {\n    Error.call(this, message)\n    this.message = message\n  }\n\n  if ( Error ) ReplaceError.__proto__ = Error;\n  ReplaceError.prototype = Object.create( Error && Error.prototype );\n  ReplaceError.prototype.constructor = ReplaceError;\n\n  return ReplaceError;\n}(Error));\nexports.ReplaceError = ReplaceError\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are 'open' / cut through.\nvar Slice = function(content, openLeft, openRight) {\n  // :: Fragment The slice's content nodes.\n  this.content = content\n  // :: number The open depth at the start.\n  this.openLeft = openLeft\n  // :: number The open depth at the end.\n  this.openRight = openRight\n};\n\nvar prototypeAccessors = { size: {} };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors.size.get = function () {\n  return this.content.size - this.openLeft - this.openRight\n};\n\nSlice.prototype.insertAt = function (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openLeft, fragment, null)\n  return content && new Slice(content, this.openLeft, this.openRight)\n};\n\nSlice.prototype.removeBetween = function (from, to) {\n  return new Slice(removeRange(this.content, from + this.openLeft, to + this.openLeft), this.openLeft, this.openRight)\n};\n\nSlice.prototype.eq = function (other) {\n  return this.content.eq(other.content) && this.openLeft == other.openLeft && this.openRight == other.openRight\n};\n\nSlice.prototype.toString = function () {\n  return this.content + \"(\" + this.openLeft + \",\" + this.openRight + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function () {\n  if (!this.content.size) { return null }\n  return {content: this.content.toJSON(),\n          openLeft: this.openLeft,\n          openRight: this.openRight}\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function (schema, json) {\n  if (!json) { return Slice.empty }\n  return new Slice(Fragment.fromJSON(schema, json.content), json.openLeft, json.openRight)\n};\n\n// :: (Fragment) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function (fragment) {\n  var openLeft = 0, openRight = 0\n  for (var n = fragment.firstChild; n && !n.isLeaf; n = n.firstChild) { openLeft++ }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf; n$1 = n$1.lastChild) { openRight++ }\n  return new Slice(fragment, openLeft, openRight)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors );\nexports.Slice = Slice\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index)\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nfunction replace($from, $to, slice) {\n  if (slice.openLeft > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openLeft != $to.depth - slice.openRight)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\nexports.replace = replace\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openLeft) {\n    var inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openLeft && !slice.openRight && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text) }\n  else\n    { target.push(child) }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth)\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target) }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target) }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content, node.attrs))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openLeft = $from.depth > depth && joinable($from, $start, depth + 1)\n  var openRight = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  var content = []\n  addRange(null, $from, depth, content)\n  if (openLeft && openRight && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openLeft, openRight)\n    addNode(close(openLeft, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openLeft)\n      { addNode(close(openLeft, replaceTwoWay($from, $start, depth + 1)), content) }\n    addRange($start, $end, depth, content)\n    if (openRight)\n      { addNode(close(openRight, replaceTwoWay($end, $to, depth + 1)), content) }\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openLeft, parent = $along.node(extra)\n  var node = parent.copy(slice.content)\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)) }\n  return {start: node.resolveNoCache(slice.openLeft + extra),\n          end: node.resolveNoCache(node.content.size - slice.openRight - extra)}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/replace.js\n// module id = 31\n// module chunks = 1","// ::- Superclass for editor selections.\nvar Selection = function Selection($from, $to) {\n  // :: ResolvedPos\n  // The resolved lower bound of the selection\n  this.$from = $from\n  // :: ResolvedPos\n  // The resolved upper bound of the selection\n  this.$to = $to\n};\n\nvar prototypeAccessors = { from: {},to: {},empty: {} };\n\n// :: bool\n// True if the selection is an empty text selection (head an anchor\n// are the same).\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\nprototypeAccessors.empty.get = function () {\n  return this.from == this.to\n};\n\n// eq:: (other: Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document, to which we are mapping.\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// negative. When `textOnly` is true, only consider cursor\n// selections.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.isTextblock ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number, ?bool) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  var result = this.findFrom($pos, bias) || this.findFrom($pos, -bias)\n  if (!result) { throw new RangeError(\"Searching for selection in invalid document \" + $pos.node(0)) }\n  return result\n};\n\n// :: (Node, ?bool) → ?Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. When `textOnly` is true, only consider cursor\n// selections.\nSelection.atStart = function atStart (doc, textOnly) {\n  return findSelectionIn(doc, doc, 0, 0, 1, textOnly)\n};\n\n// :: (Node, ?bool) → ?Selection\n// Find the cursor or leaf node selection closest to the end of\n// the given document. When `textOnly` is true, only consider cursor\n// selections.\nSelection.atEnd = function atEnd (doc, textOnly) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1, textOnly)\n};\n\n// :: (ResolvedPos, ResolvedPos, ?number) → Selection\n// Find a selection that spans the given positions, if both are text\n// positions. If not, return some other selection nearby, where\n// `bias` determines whether the method searches forward (default)\n// or backwards (negative number) first.\nSelection.between = function between ($anchor, $head, bias) {\n  var found = Selection.near($head, bias)\n  if (found instanceof TextSelection) {\n    var nearAnchor = Selection.findFrom($anchor, $anchor.pos > found.to ? -1 : 1, true)\n    found = new TextSelection(nearAnchor.$anchor, found.$head)\n  } else if ($anchor.pos < found.from || $anchor.pos > found.to) {\n    // If head falls on a node, but anchor falls outside of it, create\n    // a text selection between them\n    var inv = $anchor.pos > found.to\n    var foundAnchor = Selection.findFrom($anchor, inv ? -1 : 1, true)\n    var foundHead = Selection.findFrom(inv ? found.$from : found.$to, inv ? 1 : -1, true)\n    if (foundAnchor && foundHead)\n      { found = new TextSelection(foundAnchor.$anchor, foundHead.$head) }\n  }\n  return found\n};\n\nSelection.mapJSON = function mapJSON (json, mapping) {\n  if (json.anchor != null)\n    { return {head: mapping.map(json.head), anchor: mapping.map(json.anchor)} }\n  else\n    { return {node: mapping.map(json.node), after: mapping.map(json.after, -1)} }\n};\n\n// :: (Node, Object) → Selection\n// Deserialize a JSON representation of a selection.\nSelection.fromJSON = function fromJSON (doc, json) {\n  // This is cautious, because the history will blindly map\n  // selections and then try to deserialize them, and the endpoints\n  // might not point at appropriate positions anymore (though they\n  // are guaranteed to be inside of the document's range).\n  if (json.head != null) {\n    var $anchor = doc.resolve(json.anchor), $head = doc.resolve(json.head)\n    if ($anchor.parent.isTextblock && $head.parent.isTextblock) { return new TextSelection($anchor, $head) }\n    else { return Selection.between($anchor, $head) }\n  } else {\n    var $pos = doc.resolve(json.node), after = $pos.nodeAfter\n    if (after && json.after == json.pos + after.nodeSize && NodeSelection.isSelectable(after)) { return new NodeSelection($pos) }\n    else { return Selection.near($pos) }\n  }\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\nexports.Selection = Selection\n\n// ::- A text selection represents a classical editor\n// selection, with a head (the moving side) and anchor (immobile\n// side), both of which point into textblock nodes. It can be empty (a\n// regular cursor position).\nvar TextSelection = (function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    var inv = $anchor.pos > $head.pos\n    Selection.call(this, inv ? $head : $anchor, inv ? $anchor : $head)\n    // :: ResolvedPos The resolved anchor of the selection.\n    this.$anchor = $anchor\n    // :: ResolvedPos The resolved head of the selection.\n    this.$head = $head\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { anchor: {},head: {},inverted: {} };\n\n  prototypeAccessors$1.anchor.get = function () { return this.$anchor.pos };\n  // :: number\n  // The selection's mobile side (the side that moves when pressing\n  // shift-arrow).\n  prototypeAccessors$1.head.get = function () { return this.$head.pos };\n\n  prototypeAccessors$1.inverted.get = function () { return this.anchor > this.head };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.head == this.head && other.anchor == this.anchor\n  };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.isTextblock) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.isTextblock ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {head: this.head, anchor: this.anchor}\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\nexports.TextSelection = TextSelection\n\n// ::- A node selection is a selection that points at a\n// single node. All nodes marked [selectable](#model.NodeSpec.selectable)\n// can be the target of a node selection. In such an object, `from`\n// and `to` point directly before and after the selected node.\nvar NodeSelection = (function (Selection) {\n  function NodeSelection($from) {\n    var $to = $from.node(0).resolve($from.pos + $from.nodeAfter.nodeSize)\n    Selection.call(this, $from, $to)\n    // :: Node The selected node.\n    this.node = $from.nodeAfter\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && this.from == other.from\n  };\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    var $from = doc.resolve(from.pos), node = $from.nodeAfter\n    if (!from.deleted && !to.deleted && node && to.pos == from.pos + node.nodeSize && NodeSelection.isSelectable(node))\n      { return new NodeSelection($from) }\n    return Selection.near($from)\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {node: this.from, after: this.to}\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\nexports.NodeSelection = NodeSelection\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.isTextblock) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i)\n    if (!child.isLeaf) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-state/dist/selection.js\n// module id = 32\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar ReplaceError = ref.ReplaceError;\n\nvar ref$1 = require(\"./map\");\nvar StepMap = ref$1.StepMap;\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null)\n\n// ::- A step object wraps an atomic operation. It generally applies\n// only to the document it was created for, since the positions\n// associated with it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this\n// step.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. By\n// default, it'll create an object with the step's [JSON\n// id](#transform.Step^jsonID), and each of the steps's own properties,\n// automatically calling `toJSON` on the property values that have\n// such a method.\nStep.prototype.toJSON = function toJSON () {\n    var this$1 = this;\n\n  var obj = {stepType: this.jsonID}\n  for (var prop in this$1) { if (this$1.hasOwnProperty(prop)) {\n    var val = this$1[prop]\n    obj[prop] = val && val.toJSON ? val.toJSON() : val\n  } }\n  return obj\n};\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  return stepsByID[json.stepType].fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass\n  stepClass.prototype.jsonID = id\n  return stepClass\n};\nexports.Step = Step\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\nexports.StepResult = StepResult\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/step.js\n// module id = 33\n// module chunks = 1","var ref = require(\"./domcoords\");\nvar scrollRectIntoView = ref.scrollRectIntoView;\nvar posAtCoords = ref.posAtCoords;\nvar coordsAtPos = ref.coordsAtPos;\nvar endOfTextblock = ref.endOfTextblock;\nvar ref$1 = require(\"./viewdesc\");\nvar docViewDesc = ref$1.docViewDesc;\nvar ref$2 = require(\"./input\");\nvar initInput = ref$2.initInput;\nvar destroyInput = ref$2.destroyInput;\nvar dispatchEvent = ref$2.dispatchEvent;\nvar startObserving = ref$2.startObserving;\nvar stopObserving = ref$2.stopObserving;\nvar ensureListeners = ref$2.ensureListeners;\nvar ref$3 = require(\"./selection\");\nvar SelectionReader = ref$3.SelectionReader;\nvar selectionToDOM = ref$3.selectionToDOM;\nvar ref$4 = require(\"./decoration\");\nvar viewDecorations = ref$4.viewDecorations;\nvar Decoration = ref$4.Decoration;var assign;\n((assign = require(\"./decoration\"), exports.Decoration = assign.Decoration, exports.DecorationSet = assign.DecorationSet))\n\n// ::- An editor view manages the DOM structure that represents an\n// editor. Its state and behavior are determined by its\n// [props](#view.EditorProps).\nvar EditorView = function(place, props) {\n  // :: EditorProps\n  // The view's current [props](#view.EditorProps).\n  this.props = props\n  // :: EditorState\n  // The view's current [state](#state.EditorState).\n  this.state = props.state\n\n  this.dispatch = this.dispatch.bind(this)\n\n  this._root = null\n  this.focused = false\n\n  // :: dom.Element\n  // The editable DOM node containing the document. (You probably\n  // should not be directly interfering with its child nodes.)\n  this.content = document.createElement(\"div\")\n\n  if (place && place.appendChild) { place.appendChild(this.content) }\n  else if (place) { place(this.content) }\n\n  this.editable = getEditable(this)\n  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.content, this)\n\n  this.lastSelectedViewDesc = null\n  this.selectionReader = new SelectionReader(this)\n  initInput(this)\n\n  this.pluginViews = []\n  this.updatePluginViews()\n};\n\nvar prototypeAccessors = { root: {} };\n\n// :: (EditorProps)\n// Update the view's props. Will immediately cause an update to\n// the view's DOM.\nEditorView.prototype.update = function (props) {\n  if (props.handleDOMEvents != this.props.handleDOMEvents) { ensureListeners(this) }\n  this.props = props\n  this.updateState(props.state)\n};\n\n// :: (EditorState)\n// Update the editor's `state` prop, without touching any of the\n// other props.\nEditorView.prototype.updateState = function (state) {\n  var prev = this.state\n  this.state = state\n  if (prev.plugins != state.plugins) { ensureListeners(this) }\n\n  if (this.inDOMChange) { return }\n\n  var prevEditable = this.editable\n  this.editable = getEditable(this)\n  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this)\n\n  if (!this.docView.matchesNode(state.doc, outerDeco, innerDeco)) {\n    stopObserving(this)\n    this.docView.update(state.doc, outerDeco, innerDeco, this)\n    selectionToDOM(this, state.selection)\n    startObserving(this)\n  } else if (!state.selection.eq(prev.selection) || this.selectionReader.domChanged()) {\n    stopObserving(this)\n    selectionToDOM(this, state.selection)\n    startObserving(this)\n  }\n\n  if (prevEditable != this.editable) { this.selectionReader.editableChanged() }\n  this.updatePluginViews(prev)\n\n  if (state.scrollToSelection > prev.scrollToSelection || prev.config != state.config) {\n    if (state.selection.node)\n      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect()) }\n    else\n      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head)) }\n  }\n};\n\nEditorView.prototype.destroyPluginViews = function () {\n  var view\n  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy() } }\n};\n\nEditorView.prototype.updatePluginViews = function (prevState) {\n    var this$1 = this;\n\n  var plugins = this.state.plugins\n  if (!prevState || prevState.plugins != plugins) {\n    this.destroyPluginViews()\n    for (var i = 0; i < plugins.length; i++) {\n      var plugin = plugins[i]\n      if (plugin.options.view) { this$1.pluginViews.push(plugin.options.view(this$1)) }\n    }\n  } else {\n    for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {\n      var pluginView = this$1.pluginViews[i$1]\n      if (pluginView.update) { pluginView.update(this$1) }\n    }\n  }\n};\n\n// :: () → bool\n// Query whether the view has focus.\nEditorView.prototype.hasFocus = function () {\n  if (this.editable && this.content.ownerDocument.activeElement != this.content) { return false }\n  var sel = this.root.getSelection()\n  return sel.rangeCount && this.content.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode)\n};\n\n// :: (string, (prop: *) → *) → *\n// Goes over the values of a prop, first those provided directly,\n// then those from plugins (in order), and calls `f` every time a\n// non-undefined value is found. When `f` returns a truthy value,\n// that is immediately returned. When `f` isn't provided, it is\n// treated as the identity function (the prop value is returned\n// directly).\nEditorView.prototype.someProp = function (propName, f) {\n  var prop = this.props && this.props[propName], value\n  if (prop != null && (value = f ? f(prop) : prop)) { return value }\n  var plugins = this.state.plugins\n  if (plugins) { for (var i = 0; i < plugins.length; i++) {\n    var prop$1 = plugins[i].props[propName]\n    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }\n  } }\n};\n\n// :: ()\n// Focus the editor.\nEditorView.prototype.focus = function () {\n  stopObserving(this)\n  selectionToDOM(this, this.state.selection, true)\n  startObserving(this)\n  if (this.editable) { this.content.focus() }\n};\n\n// :: union<dom.Document, dom.DocumentFragment>\n// Get the document root in which the editor exists. This will\n// usually be the top-level `document`, but might be a shadow DOM\n// root if the editor is inside a shadow DOM.\nprototypeAccessors.root.get = function () {\n    var this$1 = this;\n\n  var cached = this._root\n  if (cached == null) { for (var search = this.content.parentNode; search; search = search.parentNode) {\n    if (search.nodeType == 9 || (search.nodeType == 11 && search.host))\n      { return this$1._root = search }\n  } }\n  return cached || document\n};\n\n// :: ({left: number, top: number}) → ?{pos: number, inside: number}\n// Given a pair of coordinates, return the document position that\n// corresponds to them. May return null if the given coordinates\n// aren't inside of the visible editor. When an object is returned,\n// its `pos` property is the position nearest to the coordinates,\n// and its `inside` property holds the position before the inner\n// node that the click happened inside of, or -1 if the click was at\n// the top level.\nEditorView.prototype.posAtCoords = function (coords) { return posAtCoords(this, coords) };\n\n// :: (number) → {left: number, right: number, top: number, bottom: number}\n// Returns the screen rectangle at a given document position. `left`\n// and `right` will be the same number, as this returns a flat\n// cursor-ish rectangle.\nEditorView.prototype.coordsAtPos = function (pos) { return coordsAtPos(this, pos) };\n\n// :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n// Find out whether the selection is at the end of a textblock when\n// moving in a given direction. When, for example, given `\"left\"`,\n// it will return true if moving left from the current cursor\n// position would leave that position's parent textblock. For\n// horizontal motion, it will always return false if the selection\n// isn't a cursor selection.\nEditorView.prototype.endOfTextblock = function (dir, state) {\n  return endOfTextblock(this, state || this.state, dir)\n};\n\n// :: ()\n// Removes the editor from the DOM and destroys all [node\n// views](#view.NodeView).\nEditorView.prototype.destroy = function () {\n  destroyInput(this)\n  this.destroyPluginViews()\n  this.docView.destroy()\n  this.selectionReader.destroy()\n  if (this.content.parentNode) { this.content.parentNode.removeChild(this.content) }\n};\n\n// Used for testing.\nEditorView.prototype.dispatchEvent = function (event) {\n  return dispatchEvent(this, event)\n};\n\n// :: (Transaction)\n// Dispatch a transaction. Will call the\n// [`dispatchTransaction`](#view.EditorProps.dispatchTransaction) when given,\n// and defaults to applying the transaction to the current state and\n// calling [`updateState`](#view.EditorView.updateState) otherwise.\n// This method is bound to the view instance, so that it can be\n// easily passed around.\nEditorView.prototype.dispatch = function (tr) {\n  var dispatchTransaction = this.props.dispatchTransaction\n  if (dispatchTransaction) { dispatchTransaction(tr) }\n  else { this.updateState(this.state.apply(tr)) }\n};\n\nObject.defineProperties( EditorView.prototype, prototypeAccessors );\nexports.EditorView = EditorView\n\nfunction computeDocDeco(view) {\n  var attrs = Object.create(null)\n  attrs.class = \"ProseMirror\" + (view.focused ? \" ProseMirror-focused\" : \"\") +\n    (view.state.selection.node ? \" ProseMirror-nodeselection\" : \"\")\n  attrs.contenteditable = String(view.editable)\n\n  view.someProp(\"attributes\", function (value) {\n    if (typeof value == \"function\") { value = value(view.state) }\n    if (value) { for (var attr in value) {\n      if (attr == \"class\")\n        { attrs.class += \" \" + value[attr] }\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        { attrs[attr] = String(value[attr]) }\n    } }\n  })\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", function (value) { return value(view.state) === false; })\n}\n\n// EditorProps:: interface\n//\n// The configuration object that can be passed to an editor view. It\n// supports the following properties (only `state` is required).\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// Except for `state` and `dispatchTransaction`, these may also be\n// present on the `props` property of plugins. How a prop is resolved\n// depends on the prop. Handler functions are called one at a time,\n// starting with the plugins (in order of appearance), and finally\n// looking at the base props, until one of them returns true. For some\n// props, the first plugin that yields a value gets precedence. For\n// `class`, all the classes returned are combined.\n//\n//   state:: EditorState\n//   The state of the editor.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. You'll usually want to make sure this ends\n//   up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply).\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   effect of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handleContextMenu:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when a context menu event is fired in the editor.\n//\n//   onFocus:: ?(view: EditorView, event: dom.Event)\n//   Called when the editor is focused.\n//\n//   onBlur:: ?(view: EditorView, event: dom.Event)\n//   Called when the editor loses focus.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   transformPastedHTML:: ?(string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   transformPastedText:: ?(string) → string\n//   Transform pasted plain text.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration]) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor function\n//   that produce a [`NodeView`](#view.NodeView) object implementing\n//   the node's display behavior. `getPos` is a function that can be\n//   called to get the node's current position, which can be useful\n//   when creating transactions that update it.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   decorations:: (EditorState) → ?DecorationSet\n//   A set of [document decorations](#view.Decoration) to add to the\n//   view.\n//\n//   editable:: ?(EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?number\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?number\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/index.js\n// module id = 34\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/json/stringify.js\n// module id = 35\n// module chunks = 1","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 36\n// module chunks = 1","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 37\n// module chunks = 1","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 38\n// module chunks = 1","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 39\n// module chunks = 1","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 40\n// module chunks = 1","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 41\n// module chunks = 1","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-to-string-tag.js\n// module id = 42\n// module chunks = 1","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 43\n// module chunks = 1","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 44\n// module chunks = 1","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 45\n// module chunks = 1","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 46\n// module chunks = 1","//Copyright (C) 2012 Kory Nunn\r\n\r\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n/*\r\n\r\n    This code is not formatted for readability, but rather run-speed and to assist compilers.\r\n\r\n    However, the code's intention should be transparent.\r\n\r\n    *** IE SUPPORT ***\r\n\r\n    If you require this library to work in IE7, add the following after declaring crel.\r\n\r\n    var testDiv = document.createElement('div'),\r\n        testLabel = document.createElement('label');\r\n\r\n    testDiv.setAttribute('class', 'a');\r\n    testDiv['className'] !== 'a' ? crel.attrMap['class'] = 'className':undefined;\r\n    testDiv.setAttribute('name','a');\r\n    testDiv['name'] !== 'a' ? crel.attrMap['name'] = function(element, value){\r\n        element.id = value;\r\n    }:undefined;\r\n\r\n\r\n    testLabel.setAttribute('for', 'a');\r\n    testLabel['htmlFor'] !== 'a' ? crel.attrMap['for'] = 'htmlFor':undefined;\r\n\r\n\r\n\r\n*/\r\n\r\n(function (root, factory) {\r\n    if (typeof exports === 'object') {\r\n        module.exports = factory();\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        define(factory);\r\n    } else {\r\n        root.crel = factory();\r\n    }\r\n}(this, function () {\r\n    var fn = 'function',\r\n        obj = 'object',\r\n        nodeType = 'nodeType',\r\n        textContent = 'textContent',\r\n        setAttribute = 'setAttribute',\r\n        attrMapString = 'attrMap',\r\n        isNodeString = 'isNode',\r\n        isElementString = 'isElement',\r\n        d = typeof document === obj ? document : {},\r\n        isType = function(a, type){\r\n            return typeof a === type;\r\n        },\r\n        isNode = typeof Node === fn ? function (object) {\r\n            return object instanceof Node;\r\n        } :\r\n        // in IE <= 8 Node is an object, obviously..\r\n        function(object){\r\n            return object &&\r\n                isType(object, obj) &&\r\n                (nodeType in object) &&\r\n                isType(object.ownerDocument,obj);\r\n        },\r\n        isElement = function (object) {\r\n            return crel[isNodeString](object) && object[nodeType] === 1;\r\n        },\r\n        isArray = function(a){\r\n            return a instanceof Array;\r\n        },\r\n        appendChild = function(element, child) {\r\n          if(!crel[isNodeString](child)){\r\n              child = d.createTextNode(child);\r\n          }\r\n          element.appendChild(child);\r\n        };\r\n\r\n\r\n    function crel(){\r\n        var args = arguments, //Note: assigned to a variable to assist compilers. Saves about 40 bytes in closure compiler. Has negligable effect on performance.\r\n            element = args[0],\r\n            child,\r\n            settings = args[1],\r\n            childIndex = 2,\r\n            argumentsLength = args.length,\r\n            attributeMap = crel[attrMapString];\r\n\r\n        element = crel[isElementString](element) ? element : d.createElement(element);\r\n        // shortcut\r\n        if(argumentsLength === 1){\r\n            return element;\r\n        }\r\n\r\n        if(!isType(settings,obj) || crel[isNodeString](settings) || isArray(settings)) {\r\n            --childIndex;\r\n            settings = null;\r\n        }\r\n\r\n        // shortcut if there is only one child that is a string\r\n        if((argumentsLength - childIndex) === 1 && isType(args[childIndex], 'string') && element[textContent] !== undefined){\r\n            element[textContent] = args[childIndex];\r\n        }else{\r\n            for(; childIndex < argumentsLength; ++childIndex){\r\n                child = args[childIndex];\r\n\r\n                if(child == null){\r\n                    continue;\r\n                }\r\n\r\n                if (isArray(child)) {\r\n                  for (var i=0; i < child.length; ++i) {\r\n                    appendChild(element, child[i]);\r\n                  }\r\n                } else {\r\n                  appendChild(element, child);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(var key in settings){\r\n            if(!attributeMap[key]){\r\n                element[setAttribute](key, settings[key]);\r\n            }else{\r\n                var attr = attributeMap[key];\r\n                if(typeof attr === fn){\r\n                    attr(element, settings[key]);\r\n                }else{\r\n                    element[setAttribute](attr, settings[key]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return element;\r\n    }\r\n\r\n    // Used for mapping one kind of attribute to the supported version of that in bad browsers.\r\n    crel[attrMapString] = {};\r\n\r\n    crel[isElementString] = isElement;\r\n\r\n    crel[isNodeString] = isNode;\r\n\r\n    if(typeof Proxy !== 'undefined'){\r\n        crel.proxy = new Proxy(crel, {\r\n            get: function(target, key){\r\n                !(key in crel) && (crel[key] = crel.bind(null, key));\r\n                return crel[key];\r\n            }\r\n        });\r\n    }\r\n\r\n    return crel;\r\n}));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crel/crel.js\n// module id = 47\n// module chunks = 1",";var assign;\n((assign = require(\"./inputrules\"), exports.InputRule = assign.InputRule, exports.inputRules = assign.inputRules))\n;var assign$1;\n((assign$1 = require(\"./rules\"), exports.emDash = assign$1.emDash, exports.ellipsis = assign$1.ellipsis, exports.openDoubleQuote = assign$1.openDoubleQuote, exports.closeDoubleQuote = assign$1.closeDoubleQuote, exports.openSingleQuote = assign$1.openSingleQuote, exports.closeSingleQuote = assign$1.closeSingleQuote, exports.smartQuotes = assign$1.smartQuotes, exports.allInputRules = assign$1.allInputRules))\n;var assign$2;\n((assign$2 = require(\"./util\"), exports.wrappingInputRule = assign$2.wrappingInputRule, exports.textblockTypeInputRule = assign$2.textblockTypeInputRule, exports.blockQuoteRule = assign$2.blockQuoteRule, exports.orderedListRule = assign$2.orderedListRule, exports.bulletListRule = assign$2.bulletListRule, exports.codeBlockRule = assign$2.codeBlockRule, exports.headingRule = assign$2.headingRule))\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-inputrules/dist/index.js\n// module id = 48\n// module chunks = 1","var crel = require(\"crel\")\nvar ref = require(\"prosemirror-commands\");\nvar lift = ref.lift;\nvar joinUp = ref.joinUp;\nvar selectParentNode = ref.selectParentNode;\nvar wrapIn = ref.wrapIn;\nvar setBlockType = ref.setBlockType;\nvar ref$1 = require(\"prosemirror-history\");\nvar undo = ref$1.undo;\nvar redo = ref$1.redo;\n\nvar ref$2 = require(\"./icons\");\nvar getIcon = ref$2.getIcon;\n\nvar prefix = \"ProseMirror-menu\"\n\n// ::- An icon or label that, when clicked, executes a command.\nvar MenuItem = function MenuItem(spec) {\n  // :: MenuItemSpec\n  // The spec used to create the menu item.\n  this.spec = spec\n};\n\n// :: (EditorView) → dom.Node\n// Renders the icon according to its [display\n// spec](#menu.MenuItemSpec.display), and adds an event handler which\n// executes the command when the representation is clicked.\nMenuItem.prototype.render = function render (view) {\n  var disabled = false, spec = this.spec\n  if (spec.select && !spec.select(view.state)) {\n    if (spec.onDeselected == \"disable\") { disabled = true }\n    else { return null }\n  }\n  var active = spec.active && !disabled && spec.active(view.state)\n\n  var dom\n  if (spec.render) {\n    dom = spec.render(view)\n  } else if (spec.icon) {\n    dom = getIcon(spec.icon)\n    if (active) { dom.classList.add(prefix + \"-active\") }\n  } else if (spec.label) {\n    dom = crel(\"div\", null, translate(view, spec.label))\n  } else {\n    throw new RangeError(\"MenuItem without render, icon, or label property\")\n  }\n\n  if (spec.title) { dom.setAttribute(\"title\", translate(view, spec.title)) }\n  if (spec.class) { dom.classList.add(spec.class) }\n  if (disabled) { dom.classList.add(prefix + \"-disabled\") }\n  if (spec.css) { dom.style.cssText += spec.css }\n  if (!disabled) { dom.addEventListener(spec.execEvent || \"mousedown\", function (e) {\n    e.preventDefault()\n    spec.run(view.state, view.dispatch, view)\n  }) }\n  return dom\n};\nexports.MenuItem = MenuItem\n\nfunction translate(view, text) {\n  return view.props.translate ? view.props.translate(text) : text\n}\n\n// MenuItemSpec:: interface\n// The configuration object passed to the `MenuItem` constructor.\n//\n//   run:: (EditorState, (Transaction), EditorView)\n//   The function to execute when the menu item is activated.\n//\n//   select:: ?(EditorState) → bool\n//   Optional function that is used to determine whether the item is\n//   appropriate at the moment.\n//\n//   onDeselect:: ?string\n//   Determines what happens when [`select`](#menu.MenuItemSpec.select)\n//   returns false. The default is to hide the item, you can set this to\n//   `\"disable\"` to instead render the item with a disabled style.\n//\n//   active:: ?(EditorState) → bool\n//   A predicate function to determine whether the item is 'active' (for\n//   example, the item for toggling the strong mark might be active then\n//   the cursor is in strong text).\n//\n//   render:: ?(EditorView) → dom.Node\n//   A function that renders the item. You must provide either this,\n//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).\n//\n//   icon:: ?Object\n//   Describes an icon to show for this item. The object may specify\n//   an SVG icon, in which case its `path` property should be an [SVG\n//   path\n//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),\n//   and `width` and `height` should provide the viewbox in which that\n//   path exists. Alternatively, it may have a `text` property\n//   specifying a string of text that makes up the icon, with an\n//   optional `css` property giving additional CSS styling for the\n//   text. _Or_ it may contain `dom` property containing a DOM node.\n//\n//   label:: ?string\n//   Makes the item show up as a text label. Mostly useful for items\n//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object\n//   should have a `label` property providing the text to display.\n//\n//   title:: ?string\n//   Defines DOM title (mouseover) text for the item.\n//\n//   class:: string\n//   Optionally adds a CSS class to the item's DOM representation.\n//\n//   css:: string\n//   Optionally adds a string of inline CSS to the item's DOM\n//   representation.\n//\n//   execEvent:: string\n//   Defines which event on the command's DOM representation should\n//   trigger the execution of the command. Defaults to mousedown.\n\nvar lastMenuEvent = {time: 0, node: null}\nfunction markMenuEvent(e) {\n  lastMenuEvent.time = Date.now()\n  lastMenuEvent.node = e.target\n}\nfunction isMenuEvent(wrapper) {\n  return Date.now() - 100 < lastMenuEvent.time &&\n    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)\n}\n\n// ::- A drop-down menu, displayed as a label with a downwards-pointing\n// triangle to the right of it.\nvar Dropdown = function Dropdown(content, options) {\n  this.options = options || {}\n  this.content = Array.isArray(content) ? content : [content]\n};\n\n// :: (EditorView) → dom.Node\n// Returns a node showing the collapsed menu, which expands when clicked.\nDropdown.prototype.render = function render (view) {\n    var this$1 = this;\n\n  var items = renderDropdownItems(this.content, view)\n  if (!items.length) { return null }\n\n  var label = crel(\"div\", {class: prefix + \"-dropdown \" + (this.options.class || \"\"),\n                           style: this.options.css,\n                           title: this.options.title && translate(view, this.options.title)},\n                  translate(view, this.options.label))\n  var wrap = crel(\"div\", {class: prefix + \"-dropdown-wrap\"}, label)\n  var open = null, listeningOnClose = null\n  var close = function () {\n    if (open && open.close()) {\n      open = null\n      window.removeEventListener(\"mousedown\", listeningOnClose)\n    }\n  }\n  label.addEventListener(\"mousedown\", function (e) {\n    e.preventDefault()\n    markMenuEvent(e)\n    if (open) {\n      close()\n    } else {\n      open = this$1.expand(wrap, items)\n      window.addEventListener(\"mousedown\", listeningOnClose = function () {\n        if (!isMenuEvent(wrap)) { close() }\n      })\n    }\n  })\n  return wrap\n};\n\nDropdown.prototype.expand = function expand (dom, items) {\n  var menuDOM = crel(\"div\", {class: prefix + \"-dropdown-menu \" + (this.options.class || \"\")}, items)\n\n  var done = false\n  function close() {\n    if (done) { return }\n    done = true\n    dom.removeChild(menuDOM)\n    return true\n  }\n  dom.appendChild(menuDOM)\n  return {close: close, node: menuDOM}\n};\nexports.Dropdown = Dropdown\n\nfunction renderDropdownItems(items, view) {\n  var rendered = []\n  for (var i = 0; i < items.length; i++) {\n    var inner = items[i].render(view)\n    if (inner) { rendered.push(crel(\"div\", {class: prefix + \"-dropdown-item\"}, inner)) }\n  }\n  return rendered\n}\n\n// ::- Represents a submenu wrapping a group of elements that start\n// hidden and expand to the right when hovered over or tapped.\nvar DropdownSubmenu = function DropdownSubmenu(content, options) {\n  this.options = options || {}\n  this.content = Array.isArray(content) ? content : [content]\n};\n\n// :: (EditorView) → dom.Node\n// Renders the submenu.\nDropdownSubmenu.prototype.render = function render (view) {\n  var items = renderDropdownItems(this.content, view)\n  if (!items.length) { return null }\n\n  var label = crel(\"div\", {class: prefix + \"-submenu-label\"}, translate(view, this.options.label))\n  var wrap = crel(\"div\", {class: prefix + \"-submenu-wrap\"}, label,\n                 crel(\"div\", {class: prefix + \"-submenu\"}, items))\n  var listeningOnClose = null\n  label.addEventListener(\"mousedown\", function (e) {\n    e.preventDefault()\n    markMenuEvent(e)\n    wrap.classList.toggle(prefix + \"-submenu-wrap-active\")\n    if (!listeningOnClose)\n      { window.addEventListener(\"mousedown\", listeningOnClose = function () {\n        if (!isMenuEvent(wrap)) {\n          wrap.classList.remove(prefix + \"-submenu-wrap-active\")\n          window.removeEventListener(\"mousedown\", listeningOnClose)\n          listeningOnClose = null\n        }\n      }) }\n  })\n  return wrap\n};\nexports.DropdownSubmenu = DropdownSubmenu\n\n// :: (EditorView, [union<MenuElement, [MenuElement]>]) → ?dom.DocumentFragment\n// Render the given, possibly nested, array of menu elements into a\n// document fragment, placing separators between them (and ensuring no\n// superfluous separators appear when some of the groups turn out to\n// be empty).\nfunction renderGrouped(view, content) {\n  var result = document.createDocumentFragment(), needSep = false\n  for (var i = 0; i < content.length; i++) {\n    var items = content[i], added = false\n    for (var j = 0; j < items.length; j++) {\n      var rendered = items[j].render(view)\n      if (rendered) {\n        if (!added && needSep) { result.appendChild(separator()) }\n        result.appendChild(crel(\"span\", {class: prefix + \"item\"}, rendered))\n        added = true\n      }\n    }\n    if (added) { needSep = true }\n  }\n  return result\n}\nexports.renderGrouped = renderGrouped\n\nfunction separator() {\n  return crel(\"span\", {class: prefix + \"separator\"})\n}\n\n// :: Object\n// A set of basic editor-related icons. Contains the properties\n// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,\n// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each\n// holding an object that can be used as the `icon` option to\n// `MenuItem`.\nvar icons = {\n  join: {\n    width: 800, height: 900,\n    path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n  },\n  lift: {\n    width: 1024, height: 1024,\n    path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n  },\n  selectParentNode: {text: \"\\u2b1a\", css: \"font-weight: bold\"},\n  undo: {\n    width: 1024, height: 1024,\n    path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n  },\n  redo: {\n    width: 1024, height: 1024,\n    path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n  },\n  strong: {\n    width: 805, height: 1024,\n    path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n  },\n  em: {\n    width: 585, height: 1024,\n    path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n  },\n  code: {\n    width: 896, height: 1024,\n    path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n  },\n  link: {\n    width: 951, height: 1024,\n    path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n  },\n  bulletList: {\n    width: 768, height: 896,\n    path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n  },\n  orderedList: {\n    width: 768, height: 896,\n    path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n  },\n  blockquote: {\n    width: 640, height: 896,\n    path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n  }\n}\nexports.icons = icons\n\n// :: MenuItem\n// Menu item for the `joinUp` command.\nvar joinUpItem = new MenuItem({\n  title: \"Join with above block\",\n  run: joinUp,\n  select: function (state) { return joinUp(state); },\n  icon: icons.join\n})\nexports.joinUpItem = joinUpItem\n\n// :: MenuItem\n// Menu item for the `lift` command.\nvar liftItem = new MenuItem({\n  title: \"Lift out of enclosing block\",\n  run: lift,\n  select: function (state) { return lift(state); },\n  icon: icons.lift\n})\nexports.liftItem = liftItem\n\n// :: MenuItem\n// Menu item for the `selectParentNode` command.\nvar selectParentNodeItem = new MenuItem({\n  title: \"Select parent node\",\n  run: selectParentNode,\n  select: function (state) { return selectParentNode(state); },\n  icon: icons.selectParentNode\n})\nexports.selectParentNodeItem = selectParentNodeItem\n\n// :: (Object) → MenuItem\n// Menu item for the `undo` command.\nvar undoItem = new MenuItem({\n  title: \"Undo last change\",\n  run: undo,\n  select: function (state) { return undo(state); },\n  icon: icons.undo\n})\nexports.undoItem = undoItem\n\n// :: (Object) → MenuItem\n// Menu item for the `redo` command.\nvar redoItem = new MenuItem({\n  title: \"Redo last undone change\",\n  run: redo,\n  select: function (state) { return redo(state); },\n  icon: icons.redo\n})\nexports.redoItem = redoItem\n\n// :: (NodeType, Object) → MenuItem\n// Build a menu item for wrapping the selection in a given node type.\n// Adds `run` and `select` properties to the ones present in\n// `options`. `options.attrs` may be an object or a function, as in\n// `toggleMarkItem`.\nfunction wrapItem(nodeType, options) {\n  var passedOptions = {\n    run: function run(state, dispatch) {\n      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))\n      return wrapIn(nodeType, options.attrs)(state, dispatch)\n    },\n    select: function select(state) {\n      return wrapIn(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)\n    }\n  }\n  for (var prop in options) { passedOptions[prop] = options[prop] }\n  return new MenuItem(passedOptions)\n}\nexports.wrapItem = wrapItem\n\n// :: (NodeType, Object) → MenuItem\n// Build a menu item for changing the type of the textblock around the\n// selection to the given type. Provides `run`, `active`, and `select`\n// properties. Others must be given in `options`. `options.attrs` may\n// be an object to provide the attributes for the textblock node.\nfunction blockTypeItem(nodeType, options) {\n  var command = setBlockType(nodeType, options.attrs)\n  var passedOptions = {\n    run: command,\n    select: function select(state) { return command(state) },\n    active: function active(state) {\n      var ref = state.selection;\n      var $from = ref.$from;\n      var to = ref.to;\n      var node = ref.node;\n      if (node) { return node.hasMarkup(nodeType, options.attrs) }\n      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)\n    }\n  }\n  for (var prop in options) { passedOptions[prop] = options[prop] }\n  return new MenuItem(passedOptions)\n}\nexports.blockTypeItem = blockTypeItem\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-menu/dist/menu.js\n// module id = 49\n// module chunks = 1","function compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a)\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\nexports.compareDeep = compareDeep\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/comparedeep.js\n// module id = 50\n// module chunks = 1","var ref = require(\"./fragment\");\nvar Fragment = ref.Fragment;\nvar ref$1 = require(\"./mark\");\nvar Mark = ref$1.Mark;\n\nvar ContentExpr = function(nodeType, elements, inlineContent) {\n  this.nodeType = nodeType\n  this.elements = elements\n  this.inlineContent = inlineContent\n};\n\nvar prototypeAccessors = { isLeaf: {} };\n\nprototypeAccessors.isLeaf.get = function () {\n  return this.elements.length == 0\n};\n\n// : (?Object) → ContentMatch\n// The content match at the start of this expression.\nContentExpr.prototype.start = function (attrs) {\n  return new ContentMatch(this, attrs, 0, 0)\n};\n\n// : (NodeType, ?Object, ?Object) → ?ContentMatch\n// Try to find a match that matches the given node, anywhere in the\n// expression. (Useful when synthesizing a match for a node that's\n// open to the left.)\nContentExpr.prototype.atType = function (parentAttrs, type, attrs, marks) {\n    var this$1 = this;\n    if ( marks === void 0 ) marks = Mark.none;\n\n  for (var i = 0; i < this.elements.length; i++)\n    { if (this$1.elements[i].matchesType(type, attrs, marks, parentAttrs, this$1))\n      { return new ContentMatch(this$1, parentAttrs, i, 0) } }\n};\n\nContentExpr.prototype.matches = function (attrs, fragment, from, to) {\n  return this.start(attrs).matchToEnd(fragment, from, to)\n};\n\n// Get a position in a known-valid fragment. If this is a simple\n// (single-element) expression, we don't have to do any matching,\n// and can simply skip to the position with count `index`.\nContentExpr.prototype.getMatchAt = function (attrs, fragment, index) {\n    if ( index === void 0 ) index = fragment.childCount;\n\n  if (this.elements.length == 1)\n    { return new ContentMatch(this, attrs, 0, index) }\n  else\n    { return this.start(attrs).matchFragment(fragment, 0, index) }\n};\n\nContentExpr.prototype.checkReplace = function (attrs, content, from, to, replacement, start, end) {\n    var this$1 = this;\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  // Check for simple case, where the expression only has a single element\n  // (Optimization to avoid matching more than we need)\n  if (this.elements.length == 1) {\n    var elt = this.elements[0]\n    if (!checkCount(elt, content.childCount - (to - from) + (end - start), attrs, this)) { return false }\n    for (var i = start; i < end; i++) { if (!elt.matches(replacement.child(i), attrs, this$1)) { return false } }\n    return true\n  }\n\n  var match = this.getMatchAt(attrs, content, from).matchFragment(replacement, start, end)\n  return match ? match.matchToEnd(content, to) : false\n};\n\nContentExpr.prototype.checkReplaceWith = function (attrs, content, from, to, type, typeAttrs, marks) {\n  if (this.elements.length == 1) {\n    var elt = this.elements[0]\n    if (!checkCount(elt, content.childCount - (to - from) + 1, attrs, this)) { return false }\n    return elt.matchesType(type, typeAttrs, marks, attrs, this)\n  }\n\n  var match = this.getMatchAt(attrs, content, from).matchType(type, typeAttrs, marks)\n  return match ? match.matchToEnd(content, to) : false\n};\n\nContentExpr.prototype.compatible = function (other) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.elements.length; i++) {\n    var elt = this$1.elements[i]\n    for (var j = 0; j < other.elements.length; j++)\n      { if (other.elements[j].compatible(elt)) { return true } }\n  }\n  return false\n};\n\nContentExpr.prototype.generateContent = function (attrs) {\n  return this.start(attrs).fillBefore(Fragment.empty, true)\n};\n\nContentExpr.parse = function (nodeType, expr, specs) {\n  var elements = [], pos = 0, inline = null\n  for (;;) {\n    pos += /^\\s*/.exec(expr.slice(pos))[0].length\n    if (pos == expr.length) { break }\n\n    var types = /^(?:(\\w+)|\\(\\s*(\\w+(?:\\s*\\|\\s*\\w+)*)\\s*\\))/.exec(expr.slice(pos))\n    if (!types) { throw new SyntaxError(\"Invalid content expression '\" + expr + \"' at \" + pos) }\n    pos += types[0].length\n    var attrs = /^\\[([^\\]]+)\\]/.exec(expr.slice(pos))\n    if (attrs) { pos += attrs[0].length }\n    var marks = /^<(?:(_)|\\s*(\\w+(?:\\s+\\w+)*)\\s*)>/.exec(expr.slice(pos))\n    if (marks) { pos += marks[0].length }\n    var repeat = /^(?:([+*?])|\\{\\s*(\\d+|\\.\\w+)\\s*(,\\s*(\\d+|\\.\\w+)?)?\\s*\\})/.exec(expr.slice(pos))\n    if (repeat) { pos += repeat[0].length }\n\n    var nodeTypes = expandTypes(nodeType.schema, specs, types[1] ? [types[1]] : types[2].split(/\\s*\\|\\s*/))\n    for (var i = 0; i < nodeTypes.length; i++) {\n      if (inline == null) { inline = nodeTypes[i].isInline }\n      else if (inline != nodeTypes[i].isInline) { throw new SyntaxError(\"Mixing inline and block content in a single node\") }\n    }\n    var attrSet = !attrs ? null : parseAttrs(nodeType, attrs[1])\n    var markSet = !marks ? false : marks[1] ? true : checkMarks(nodeType.schema, marks[2].split(/\\s+/))\n    var ref = parseRepeat(nodeType, repeat);\n      var min = ref.min;\n      var max = ref.max;\n    if (min != 0 && (nodeTypes[0].hasRequiredAttrs(attrSet) || nodeTypes[0].isText))\n      { throw new SyntaxError(\"Node type \" + types[0] + \" in type \" + nodeType.name +\n                            \" is required, but has non-optional attributes\") }\n    var newElt = new ContentElement(nodeTypes, attrSet, markSet, min, max)\n    for (var i$1 = elements.length - 1; i$1 >= 0; i$1--) {\n      var prev = elements[i$1]\n      if (prev.min != prev.max && prev.overlaps(newElt))\n        { throw new SyntaxError(\"Possibly ambiguous overlapping adjacent content expressions in '\" + expr + \"'\") }\n      if (prev.min != 0) { break }\n    }\n    elements.push(newElt)\n  }\n\n  return new ContentExpr(nodeType, elements, !!inline)\n};\n\nObject.defineProperties( ContentExpr.prototype, prototypeAccessors );\nexports.ContentExpr = ContentExpr\n\nvar ContentElement = function(nodeTypes, attrs, marks, min, max) {\n  this.nodeTypes = nodeTypes\n  this.attrs = attrs\n  this.marks = marks\n  this.min = min\n  this.max = max\n};\n\nContentElement.prototype.matchesType = function (type, attrs, marks, parentAttrs, parentExpr) {\n    var this$1 = this;\n\n  if (this.nodeTypes.indexOf(type) == -1) { return false }\n  if (this.attrs) {\n    if (!attrs) { return false }\n    for (var prop in this$1.attrs)\n      { if (attrs[prop] != resolveValue(this$1.attrs[prop], parentAttrs, parentExpr)) { return false } }\n  }\n  if (this.marks === true) { return true }\n  if (this.marks === false) { return marks.length == 0 }\n  for (var i = 0; i < marks.length; i++)\n    { if (this$1.marks.indexOf(marks[i].type) == -1) { return false } }\n  return true\n};\n\nContentElement.prototype.matches = function (node, parentAttrs, parentExpr) {\n  return this.matchesType(node.type, node.attrs, node.marks, parentAttrs, parentExpr)\n};\n\nContentElement.prototype.compatible = function (other) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.nodeTypes.length; i++)\n    { if (other.nodeTypes.indexOf(this$1.nodeTypes[i]) != -1) { return true } }\n  return false\n};\n\nContentElement.prototype.constrainedAttrs = function (parentAttrs, expr) {\n    var this$1 = this;\n\n  if (!this.attrs) { return null }\n  var attrs = Object.create(null)\n  for (var prop in this$1.attrs)\n    { attrs[prop] = resolveValue(this$1.attrs[prop], parentAttrs, expr) }\n  return attrs\n};\n\nContentElement.prototype.createFiller = function (parentAttrs, expr) {\n  var type = this.nodeTypes[0], attrs = type.computeAttrs(this.constrainedAttrs(parentAttrs, expr))\n  return type.create(attrs, type.contentExpr.generateContent(attrs))\n};\n\nContentElement.prototype.defaultType = function () {\n  var first = this.nodeTypes[0]\n  if (!(first.hasRequiredAttrs() || first.isText)) { return first }\n};\n\nContentElement.prototype.overlaps = function (other) {\n  return this.nodeTypes.some(function (t) { return other.nodeTypes.indexOf(t) > -1; })\n};\n\nContentElement.prototype.allowsMark = function (markType) {\n  return this.marks === true || this.marks && this.marks.indexOf(markType) > -1\n};\n\n// ::- Represents a partial match of a node type's [content\n// expression](#model.NodeSpec), and can be used to find out whether further\n// content matches here, and whether a given position is a valid end\n// of the parent node.\nvar ContentMatch = function(expr, attrs, index, count) {\n  this.expr = expr\n  this.attrs = attrs\n  this.index = index\n  this.count = count\n};\n\nvar prototypeAccessors$1 = { element: {},nextElement: {} };\n\nprototypeAccessors$1.element.get = function () { return this.expr.elements[this.index] };\n\nprototypeAccessors$1.nextElement.get = function () {\n    var this$1 = this;\n\n  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++) {\n    var element = this$1.expr.elements[i]\n    if (this$1.resolveValue(element.max) > count) { return element }\n    count = 0\n  }\n};\n\nContentMatch.prototype.move = function (index, count) {\n  return new ContentMatch(this.expr, this.attrs, index, count)\n};\n\nContentMatch.prototype.resolveValue = function (value) {\n  return value instanceof AttrValue ? resolveValue(value, this.attrs, this.expr) : value\n};\n\n// :: (Node) → ?ContentMatch\n// Match a node, returning a new match after the node if successful.\nContentMatch.prototype.matchNode = function (node) {\n  return this.matchType(node.type, node.attrs, node.marks)\n};\n\n// :: (NodeType, ?Object, [Mark]) → ?ContentMatch\n// Match a node type and marks, returning an match after that node\n// if successful.\nContentMatch.prototype.matchType = function (type, attrs, marks) {\n    var this$1 = this;\n    if ( marks === void 0 ) marks = Mark.none;\n\n  for (var ref = this, index = ref.index, count = ref.count; index < this.expr.elements.length; index++, count = 0) {\n    var elt = this$1.expr.elements[index], max = this$1.resolveValue(elt.max)\n    if (count < max && elt.matchesType(type, attrs, marks, this$1.attrs, this$1.expr)) {\n      count++\n      return this$1.move(index, count)\n    }\n    if (count < this$1.resolveValue(elt.min)) { return null }\n  }\n};\n\n// :: (Fragment, ?number, ?number) → ?union<ContentMatch, bool>\n// Try to match a fragment. Returns a new match when successful,\n// `null` when it ran into a required element it couldn't fit, and\n// `false` if it reached the end of the expression without\n// matching all nodes.\nContentMatch.prototype.matchFragment = function (fragment, from, to) {\n    var this$1 = this;\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = fragment.childCount;\n\n  if (from == to) { return this }\n  var fragPos = from, end = this.expr.elements.length\n  for (var ref = this, index = ref.index, count = ref.count; index < end; index++, count = 0) {\n    var elt = this$1.expr.elements[index], max = this$1.resolveValue(elt.max)\n\n    while (count < max && fragPos < to) {\n      if (elt.matches(fragment.child(fragPos), this$1.attrs, this$1.expr)) {\n        count++\n        if (++fragPos == to) { return this$1.move(index, count) }\n      } else {\n        break\n      }\n    }\n    if (count < this$1.resolveValue(elt.min)) { return null }\n  }\n  return false\n};\n\n// :: (Fragment, ?number, ?number) → bool\n// Returns true only if the fragment matches here, and reaches all\n// the way to the end of the content expression.\nContentMatch.prototype.matchToEnd = function (fragment, start, end) {\n  var matched = this.matchFragment(fragment, start, end)\n  return matched && matched.validEnd() || false\n};\n\n// :: () → bool\n// Returns true if this position represents a valid end of the\n// expression (no required content follows after it).\nContentMatch.prototype.validEnd = function () {\n    var this$1 = this;\n\n  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0)\n    { if (count < this$1.resolveValue(this$1.expr.elements[i].min)) { return false } }\n  return true\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function (after, toEnd, startIndex) {\n    var this$1 = this;\n\n  var added = [], match = this, index = startIndex || 0, end = this.expr.elements.length\n  for (;;) {\n    var fits = match.matchFragment(after, index)\n    if (fits && (!toEnd || fits.validEnd())) { return Fragment.from(added) }\n    if (fits === false) { return null } // Matched to end with content remaining\n\n    var elt = match.element\n    if (match.count < this$1.resolveValue(elt.min)) {\n      added.push(elt.createFiller(this$1.attrs, this$1.expr))\n      match = match.move(match.index, match.count + 1)\n    } else if (match.index < end) {\n      match = match.move(match.index + 1, 0)\n    } else if (after.childCount > index) {\n      return null\n    } else {\n      return Fragment.from(added)\n    }\n  }\n};\n\nContentMatch.prototype.possibleContent = function () {\n    var this$1 = this;\n\n  var found = []\n  for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0) {\n    var elt = this$1.expr.elements[i], attrs = elt.constrainedAttrs(this$1.attrs, this$1.expr)\n    if (count < this$1.resolveValue(elt.max)) { for (var j = 0; j < elt.nodeTypes.length; j++) {\n      var type = elt.nodeTypes[j]\n      if (!type.hasRequiredAttrs(attrs) && !type.isText) { found.push({type: type, attrs: attrs}) }\n    } }\n    if (this$1.resolveValue(elt.min) > count) { break }\n  }\n  return found\n};\n\n// :: (MarkType) → bool\n// Check whether a node with the given mark type is allowed after\n// this position.\nContentMatch.prototype.allowsMark = function (markType) {\n  return this.element.allowsMark(markType)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → ?[{type: NodeType, attrs: Object}]\n// Find a set of wrapping node types that would allow a node of type\n// `target` with attributes `targetAttrs` to appear at this\n// position. The result may be empty (when it fits directly) and\n// will be null when no such wrapping exists.\nContentMatch.prototype.findWrapping = function (target, targetAttrs, targetMarks) {\n  var seen = Object.create(null), first = {match: this, via: null}, active = [first]\n  while (active.length) {\n    var current = active.shift(), match = current.match\n    if (match.matchType(target, targetAttrs, targetMarks)) {\n      var result = []\n      for (var obj = current; obj != first; obj = obj.via)\n        { result.push({type: obj.match.expr.nodeType, attrs: obj.match.attrs}) }\n      return result.reverse()\n    }\n    var possible = match.possibleContent()\n    for (var i = 0; i < possible.length; i++) {\n      var ref = possible[i];\n        var type = ref.type;\n        var attrs = ref.attrs;\n        var fullAttrs = type.computeAttrs(attrs)\n      if (!type.isLeaf && !(type.name in seen) &&\n          (current == first || match.matchType(type, fullAttrs).validEnd())) {\n        active.push({match: type.contentExpr.start(fullAttrs), via: current})\n        seen[type.name] = true\n      }\n    }\n  }\n};\n\n// :: (Node) → ?[{type: NodeType, attrs: Object}]\n// Call [`findWrapping`](#model.ContentMatch.findWrapping) with the\n// properties of the given node.\nContentMatch.prototype.findWrappingFor = function (node) {\n  return this.findWrapping(node.type, node.attrs, node.marks)\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$1 );\nexports.ContentMatch = ContentMatch\n\nvar AttrValue = function(attr) { this.attr = attr };\n\nfunction parseValue(nodeType, value) {\n  if (value.charAt(0) == \".\") {\n    var attr = value.slice(1)\n    if (!nodeType.attrs[attr]) { throw new SyntaxError(\"Node type \" + nodeType.name + \" has no attribute \" + attr) }\n    return new AttrValue(attr)\n  } else {\n    return JSON.parse(value)\n  }\n}\n\nfunction checkMarks(schema, marks) {\n  var found = []\n  for (var i = 0; i < marks.length; i++) {\n    var mark = schema.marks[marks[i]]\n    if (mark) { found.push(mark) }\n    else { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\nfunction resolveValue(value, attrs, expr) {\n  if (!(value instanceof AttrValue)) { return value }\n  var attrVal = attrs && attrs[value.attr]\n  return attrVal !== undefined ? attrVal : expr.nodeType.defaultAttrs[value.attr]\n}\n\nfunction checkCount(elt, count, attrs, expr) {\n  return count >= resolveValue(elt.min, attrs, expr) &&\n    count <= resolveValue(elt.max, attrs, expr)\n}\n\nfunction expandTypes(schema, specs, types) {\n  var result = []\n  types.forEach(function (type) {\n    var found = schema.nodes[type]\n    if (found) {\n      if (result.indexOf(found) == -1) { result.push(found) }\n    } else {\n      specs.forEach(function (name, spec) {\n        if (spec.group && spec.group.split(\" \").indexOf(type) > -1) {\n          found = schema.nodes[name]\n          if (result.indexOf(found) == -1) { result.push(found) }\n        }\n      })\n    }\n    if (!found)\n      { throw new SyntaxError(\"Node type or group '\" + type + \"' does not exist\") }\n  })\n  return result\n}\n\nvar many = 2e9 // Big number representable as a 32-bit int\n\nfunction parseRepeat(nodeType, match) {\n  var min = 1, max = 1\n  if (match) {\n    if (match[1] == \"+\") {\n      max = many\n    } else if (match[1] == \"*\") {\n      min = 0\n      max = many\n    } else if (match[1] == \"?\") {\n      min = 0\n    } else if (match[2]) {\n      min = parseValue(nodeType, match[2])\n      if (match[3])\n        { max = match[4] ? parseValue(nodeType, match[4]) : many }\n      else\n        { max = min }\n    }\n    if (max == 0 || min > max)\n      { throw new SyntaxError(\"Invalid repeat count in '\" + match[0] + \"'\") }\n  }\n  return {min: min, max: max}\n}\n\nfunction parseAttrs(nodeType, expr) {\n  var parts = expr.split(/\\s*,\\s*/)\n  var attrs = Object.create(null)\n  for (var i = 0; i < parts.length; i++) {\n    var match = /^(\\w+)=(\\w+|\\\"(?:\\\\.|[^\\\\])*\\\"|\\.\\w+)$/.exec(parts[i])\n    if (!match) { throw new SyntaxError(\"Invalid attribute syntax: \" + parts[i]) }\n    attrs[match[1]] = parseValue(nodeType, match[2])\n  }\n  return attrs\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/content.js\n// module id = 51\n// module chunks = 1","var ref = require(\"./fragment\");\nvar Fragment = ref.Fragment;\nvar ref$1 = require(\"./mark\");\nvar Mark = ref$1.Mark;\nvar ref$2 = require(\"./replace\");\nvar Slice = ref$2.Slice;\nvar replace = ref$2.replace;\nvar ref$3 = require(\"./resolvedpos\");\nvar ResolvedPos = ref$3.ResolvedPos;\nvar ref$4 = require(\"./comparedeep\");\nvar compareDeep = ref$4.compareDeep;\n\nvar emptyAttrs = Object.create(null)\n\nvar warnedAboutMarksAt = false\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Never** directly mutate the properties of a `Node` object. See\n// [this guide](guide/doc.html) for more information.\nvar Node = function(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are determined by the node\n  // type.\n  this.attrs = attrs\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) associated with this node.\n  this.marks = marks || Mark.none\n};\n\nvar prototypeAccessors = { nodeSize: {},childCount: {},textContent: {},firstChild: {},lastChild: {},isBlock: {},isTextblock: {},isInline: {},isText: {},isLeaf: {} };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](guide/doc.html#indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. And for\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function (f) { this.content.forEach(f) };\n\n// :: (?number, ?number, (node: Node, pos: number, parent: Node, index: number))\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's content.\n// The callback is invoked with the node, its parent-relative position,\n// its parent node, and its child index. If the callback returns false,\n// the current node's children will not be recursed over.\nNode.prototype.nodesBetween = function (from, to, f, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  this.content.nodesBetween(from, to, f, pos, this)\n};\n\n// :: ((node: Node, pos: number, parent: Node))\n// Call the given callback for every descendant node.\nNode.prototype.descendants = function (f) {\n  this.nodesBetween(0, this.content.size, f)\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?string) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same content.\nNode.prototype.eq = function (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given offsets. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to)\n  var depth = includeParents ? 0 : $from.sharedDepth(to)\n  var start = $from.start(depth), node = $from.node(depth)\n  var content = node.content.cut($from.pos - start, $to.pos - start)\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node after the given position.\nNode.prototype.nodeAt = function (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index)\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1)\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an object\n// describing its path through the document.\nNode.prototype.resolve = function (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function (pos) { return ResolvedPos.resolve(this, pos) };\n\nNode.prototype.marksAt = function (pos, useAfter) {\n  if (!warnedAboutMarksAt && typeof console != \"undefined\" && console.warn) {\n    warnedAboutMarksAt = true\n    console.warn(\"Node.marksAt is deprecated. Use ResolvedPos.marks instead.\")\n  }\n  return this.resolve(pos).marks(useAfter)\n};\n\n// :: (?number, ?number, MarkType) → bool\n// Test whether a mark of the given type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function (from, to, type) {\n  var found = false\n  this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true }\n    return !found\n  })\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function () {\n  var name = this.type.name\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\" }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function (index) {\n  return this.type.contentExpr.getMatchAt(this.attrs, this.content, index)\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range `from` to `to` (by index) with\n// the given replacement fragment (which defaults to the empty\n// fragment) would leave the node's content valid. You can\n// optionally pass `start` and `end` indices into the replacement\n// fragment.\nNode.prototype.canReplace = function (from, to, replacement, start, end) {\n  return this.type.contentExpr.checkReplace(this.attrs, this.content, from, to, replacement, start, end)\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type with the given attributes and marks would\n// be valid.\nNode.prototype.canReplaceWith = function (from, to, type, attrs, marks) {\n  return this.type.contentExpr.checkReplaceWith(this.attrs, this.content, from, to, type, attrs, marks || Mark.none)\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\nNode.prototype.defaultContentType = function (at) {\n  var elt = this.contentMatchAt(at).nextElement\n  return elt && elt.defaultType()\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function () {\n    var this$1 = this;\n\n  var obj = {type: this.type.name}\n  for (var _ in this$1.attrs) {\n    obj.attrs = this$1.attrs\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON() }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }) }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function (schema, json) {\n  var marks = json.marks && json.marks.map(schema.markFromJSON)\n  if (json.type == \"text\") { return schema.text(json.text, marks) }\n  return schema.nodeType(json.type).create(json.attrs, Fragment.fromJSON(schema, json.content), marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors );\nexports.Node = Node\n\nvar TextNode = (function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks)\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: {},nodeSize: {} };\n\n  TextNode.prototype.toString = function () { return wrapMarks(this.marks, JSON.stringify(this.text)) };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function (marks) {\n    return new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function () {\n    var base = Node.prototype.toJSON.call(this)\n    base.text = this.text\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\nexports.TextNode = TextNode\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\" }\n  return str\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/node.js\n// module id = 52\n// module chunks = 1","var ref = require(\"./mark\");\nvar Mark = ref.Mark;\n\n// ::- You'll often have to '[resolve](#model.Node.resolve)' a\n// position to get the context you need. Objects of this class\n// represent such a resolved position, providing various pieces of\n// context information and helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos\n  this.path = path\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root, it is 0. If it points\n  // into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset\n};\n\nvar prototypeAccessors = { parent: {},textOffset: {},nodeAfter: {},nodeBefore: {} };\n\nResolvedPos.prototype.resolveDepth = function (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are 'flat' in this model.\nprototypeAccessors.parent.get = function () { return this.node(this.depth) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 2 and `p.index(1)` is 3.\nResolvedPos.prototype.index = function (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function (depth) {\n  depth = this.resolveDepth(depth)\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function (depth) {\n  depth = this.resolveDepth(depth)\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function (depth) {\n  depth = this.resolveDepth(depth)\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the node at the given\n// level, or, when `level` is `this.level + 1`, the original\n// position.\nResolvedPos.prototype.before = function (depth) {\n  depth = this.resolveDepth(depth)\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the node at the given\n// level, or, when `level` is `this.level + 1`, the original\n// position.\nResolvedPos.prototype.after = function (depth) {\n  depth = this.resolveDepth(depth)\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth)\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors.nodeBefore.get = function () {\n  var index = this.index(this.depth)\n  var dOff = this.pos - this.path[this.path.length - 1]\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (?bool) → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' inclusiveRight property. If the position is at the start\n// of a non-empty node, or `after` is true, the marks of the node\n// after it (if any) are returned.\nResolvedPos.prototype.marks = function (after) {\n  var parent = this.parent, index = this.index()\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n  // When inside a text node or at the start of the parent node, return the node's marks\n  if ((after && index < parent.childCount) || index == 0 || this.textOffset)\n    { return parent.child(index).marks }\n\n  var marks = parent.child(index - 1).marks\n  for (var i = 0; i < marks.length; i++) { if (marks[i].type.spec.inclusiveRight === false)\n    { marks = marks[i--].removeFromSet(marks) } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function (pos) {\n    var this$1 = this;\n\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this$1.start(depth) <= pos && this$1.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks or their ancestors in their common ancestor\n// is returned. You can pass in an optional predicate that will be\n// called with a parent node to see if a range into that parent is\n// acceptable.\nResolvedPos.prototype.blockRange = function (other, pred) {\n    var this$1 = this;\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.isTextblock || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this$1.end(d) && (!pred || pred(this$1.node(d))))\n      { return new NodeRange(this$1, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\nResolvedPos.prototype.toString = function () {\n    var this$1 = this;\n\n  var str = \"\"\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this$1.node(i).type.name + \"_\" + this$1.index(i - 1) }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = []\n  var start = 0, parentOffset = pos\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset\n    path.push(node, index, start + offset)\n    if (!rem) { break }\n    node = node.child(index)\n    if (node.isText) { break }\n    parentOffset = rem - 1\n    start += offset + 1\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i]\n    if (cached.pos == pos && cached.node(0) == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors );\nexports.ResolvedPos = ResolvedPos\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 6\n\n// ::- Represents a flat range of content.\nvar NodeRange = function($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to\n  // :: number The depth of the node that this range points into.\n  this.depth = depth\n};\n\nvar prototypeAccessors$1 = { start: {},end: {},parent: {},startIndex: {},endIndex: {} };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1 );\nexports.NodeRange = NodeRange\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/resolvedpos.js\n// module id = 53\n// module chunks = 1","var ref = require(\"prosemirror-transform\");\nvar findWrapping = ref.findWrapping;\nvar liftTarget = ref.liftTarget;\nvar canSplit = ref.canSplit;\nvar ReplaceAroundStep = ref.ReplaceAroundStep;\nvar ref$1 = require(\"prosemirror-model\");\nvar Slice = ref$1.Slice;\nvar Fragment = ref$1.Fragment;\nvar NodeRange = ref$1.NodeRange;\n\n// :: NodeSpec\n// An ordered list node type spec. Has a single attribute, `order`,\n// which determines the number at which the list starts counting, and\n// defaults to 1.\nvar orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM: function toDOM(node) {\n    return [\"ol\", {start: node.attrs.order == 1 ? null : node.attrs.order}, 0]\n  }\n}\nexports.orderedList = orderedList\n\n// :: NodeSpec\n// A bullet list node spec.\nvar bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM: function toDOM() { return [\"ul\", 0] }\n}\nexports.bulletList = bulletList\n\n// :: NodeSpec\n// A list item node spec.\nvar listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM: function toDOM() { return [\"li\", 0] },\n  defining: true\n}\nexports.listItem = listItem\n\nfunction add(obj, props) {\n  var copy = {}\n  for (var prop in obj) { copy[prop] = obj[prop] }\n  for (var prop$1 in props) { copy[prop$1] = props[prop$1] }\n  return copy\n}\n\n// :: (OrderedMap, string, ?string) → OrderedMap\n// Convenience function for adding list-related node types to a map\n// describing the nodes in a schema. Adds `OrderedList` as\n// `\"ordered_list\"`, `BulletList` as `\"bullet_list\"`, and `ListItem`\n// as `\"list_item\"`. `itemContent` determines the content expression\n// for the list items. If you want the commands defined in this module\n// to apply to your list structure, it should have a shape like\n// `\"paragraph block*\"`, a plain textblock type followed by zero or\n// more arbitrary nodes. `listGroup` can be given to assign a group\n// name to the list node types, for example `\"block\"`.\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\nexports.addListNodes = addListNodes\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `apply` is `false`, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nfunction wrapInList(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), doJoin = false, outerRange = range\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(nodeType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) { return false }\n      var $insert = state.doc.resolve(range.start - 2)\n      outerRange = new NodeRange($insert, $insert, range.depth)\n      if (range.endIndex < range.parent.childCount)\n        { range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth) }\n      doJoin = true\n    }\n    var wrap = findWrapping(outerRange, nodeType, attrs, range)\n    if (!wrap) { return false }\n    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, nodeType).scrollIntoView()) }\n    return true\n  }\n}\nexports.wrapInList = wrapInList\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, nodeType) {\n  var content = Fragment.empty\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)) }\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true))\n\n  var found = 0\n  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == nodeType) { found = i$1 + 1 } }\n  var splitDepth = wrappers.length - found\n\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent\n  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) { tr.split(splitPos, splitDepth) }\n    splitPos += parent.child(i$2).nodeSize + (first ? 0 : 2 * splitDepth)\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nfunction splitListItem(nodeType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n    if ((node && node.isBlock) || !$from.parent.content.size ||\n        $from.depth < 2 || !$from.sameParent($to)) { return false }\n    var grandParent = $from.node(-1)\n    if (grandParent.type != nodeType) { return false }\n    var nextType = $to.pos == $from.end() ? grandParent.defaultContentType($from.indexAfter(-1)) : null\n    var tr = state.tr.delete($from.pos, $to.pos)\n    var types = nextType && [null, {type: nextType}]\n    if (!canSplit(tr.doc, $from.pos, 2, types)) { return false }\n    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()) }\n    return true\n  }\n}\nexports.splitListItem = splitListItem\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nfunction liftListItem(nodeType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == nodeType; })\n    if (!range || range.depth < 2 || $from.node(range.depth - 1).type != nodeType) { return false }\n    if (dispatch) {\n      var tr = state.tr, end = range.end, endOfList = $to.end(range.depth)\n      if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                      new Slice(Fragment.from(nodeType.create(null, range.parent.copy())), 1, 0), 1, true))\n        range = new NodeRange(tr.doc.resolveNoCache($from.pos), tr.doc.resolveNoCache(endOfList), range.depth)\n      }\n      dispatch(tr.lift(range, liftTarget(range)).scrollIntoView())\n    }\n    return true\n  }\n}\nexports.liftListItem = liftListItem\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nfunction sinkListItem(nodeType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == nodeType; })\n    if (!range) { return false }\n    var startIndex = range.startIndex\n    if (startIndex == 0) { return false }\n    var parent = range.parent, nodeBefore = parent.child(startIndex - 1)\n    if (nodeBefore.type != nodeType) { return false }\n\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type\n      var inner = Fragment.from(nestedBefore ? nodeType.create() : null)\n      var slice = new Slice(Fragment.from(nodeType.create(null, Fragment.from(parent.copy(inner)))),\n                            nestedBefore ? 3 : 1, 0)\n      var before = range.start, after = range.end\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView())\n    }\n    return true\n  }\n}\nexports.sinkListItem = sinkListItem\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-schema-list/dist/schema-list.js\n// module id = 54\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Fragment = ref.Fragment;\nvar Slice = ref.Slice;\nvar ref$1 = require(\"prosemirror-transform\");\nvar Step = ref$1.Step;\nvar StepResult = ref$1.StepResult;\nvar StepMap = ref$1.StepMap;\nvar ReplaceStep = ref$1.ReplaceStep;\nvar ref$2 = require(\"prosemirror-state\");\nvar Selection = ref$2.Selection;\n\n// :: NodeSpec\n// A table node spec. Has one attribute, **`columns`**, which holds\n// a number indicating the amount of columns in the table.\nvar table = {\n  attrs: {columns: {default: 1}},\n  parseDOM: [{tag: \"table\", getAttrs: function getAttrs(dom) {\n    var row = dom.querySelector(\"tr\")\n    if (!row || !row.children.length) { return false }\n    // FIXME using the child count as column width is problematic\n    // when parsing document fragments\n    return {columns: row.children.length}\n  }}],\n  toDOM: function toDOM() { return [\"table\", [\"tbody\", 0]] }\n}\nexports.table = table\n\n// :: NodeSpec\n// A table row node spec. Has one attribute, **`columns`**, which\n// holds a number indicating the amount of columns in the table.\nvar tableRow = {\n  attrs: {columns: {default: 1}},\n  parseDOM: [{tag: \"tr\", getAttrs: function (dom) { return dom.children.length ? {columns: dom.children.length} : false; }}],\n  toDOM: function toDOM() { return [\"tr\", 0] },\n  tableRow: true\n}\nexports.tableRow = tableRow\n\n// :: NodeSpec\n// A table cell node spec.\nvar tableCell = {\n  parseDOM: [{tag: \"td\"}],\n  toDOM: function toDOM() { return [\"td\", 0] }\n}\nexports.tableCell = tableCell\n\nfunction add(obj, props) {\n  var copy = {}\n  for (var prop in obj) { copy[prop] = obj[prop] }\n  for (var prop$1 in props) { copy[prop$1] = props[prop$1] }\n  return copy\n}\n\n// :: (OrderedMap, string, ?string) → OrderedMap\n// Convenience function for adding table-related node types to a map\n// describing the nodes in a schema. Adds `Table` as `\"table\"`,\n// `TableRow` as `\"table_row\"`, and `TableCell` as `\"table_cell\"`.\n// `cellContent` should be a content expression describing what may\n// occur inside cells.\nfunction addTableNodes(nodes, cellContent, tableGroup) {\n  return nodes.append({\n    table: add(table, {content: \"table_row[columns=.columns]+\", group: tableGroup}),\n    table_row: add(tableRow, {content: \"table_cell{.columns}\"}),\n    table_cell: add(tableCell, {content: cellContent})\n  })\n}\nexports.addTableNodes = addTableNodes\n\n// :: (NodeType, number, number, ?Object) → Node\n// Create a table node with the given number of rows and columns.\nfunction createTable(nodeType, rows, columns, attrs) {\n  attrs = setColumns(attrs, columns)\n  var rowType = nodeType.contentExpr.elements[0].nodeTypes[0]\n  var cellType = rowType.contentExpr.elements[0].nodeTypes[0]\n  var cell = cellType.createAndFill(), cells = []\n  for (var i = 0; i < columns; i++) { cells.push(cell) }\n  var row = rowType.create({columns: columns}, Fragment.from(cells)), rowNodes = []\n  for (var i$1 = 0; i$1 < rows; i$1++) { rowNodes.push(row) }\n  return nodeType.create(attrs, Fragment.from(rowNodes))\n}\nexports.createTable = createTable\n\n// Steps to add and remove a column\n\nfunction setColumns(attrs, columns) {\n  var result = Object.create(null)\n  if (attrs) { for (var prop in attrs) { result[prop] = attrs[prop] } }\n  result.columns = columns\n  return result\n}\n\nfunction adjustColumns(attrs, diff) {\n  return setColumns(attrs, attrs.columns + diff)\n}\n\n// ::- A `Step` subclass for adding a column to a table in a single\n// atomic step.\nvar AddColumnStep = (function (Step) {\n  function AddColumnStep(positions, cells) {\n    Step.call(this)\n    this.positions = positions\n    this.cells = cells\n  }\n\n  if ( Step ) AddColumnStep.__proto__ = Step;\n  AddColumnStep.prototype = Object.create( Step && Step.prototype );\n  AddColumnStep.prototype.constructor = AddColumnStep;\n\n  // :: (Node, number, number, NodeType, ?Object) → AddColumnStep\n  // Create a step that inserts a column into the table after\n  // `tablePos`, at the index given by `columnIndex`, using cells with\n  // the given type and attributes.\n  AddColumnStep.create = function create (doc, tablePos, columnIndex, cellType, cellAttrs) {\n    var cell = cellType.createAndFill(cellAttrs)\n    var positions = [], cells = []\n    var table = doc.nodeAt(tablePos)\n    table.forEach(function (row, rowOff) {\n      var cellPos = tablePos + 2 + rowOff\n      for (var i = 0; i < columnIndex; i++) { cellPos += row.child(i).nodeSize }\n      positions.push(cellPos)\n      cells.push(cell)\n    })\n    return new AddColumnStep(positions, cells)\n  };\n\n  AddColumnStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var index = null, table = null, tablePos = null\n    for (var i = 0; i < this.positions.length; i++) {\n      var $pos = doc.resolve(this$1.positions[i])\n      if ($pos.depth < 2 || $pos.index(-1) != i)\n        { return StepResult.fail(\"Invalid cell insert position\") }\n      if (table == null) {\n        table = $pos.node(-1)\n        if (table.childCount != this$1.positions.length)\n          { return StepResult.fail(\"Mismatch in number of rows\") }\n        tablePos = $pos.before(-1)\n        index = $pos.index()\n      } else if ($pos.before(-1) != tablePos || $pos.index() != index) {\n        return StepResult.fail(\"Column insert positions not consistent\")\n      }\n    }\n\n    var updatedRows = []\n    for (var i$1 = 0; i$1 < table.childCount; i$1++) {\n      var row = table.child(i$1), rowCells = index ? [] : [this$1.cells[i$1]]\n      for (var j = 0; j < row.childCount; j++) {\n        rowCells.push(row.child(j))\n        if (j + 1 == index) { rowCells.push(this$1.cells[i$1]) }\n      }\n      updatedRows.push(row.type.create(adjustColumns(row.attrs, 1), Fragment.from(rowCells)))\n    }\n    var updatedTable = table.type.create(adjustColumns(table.attrs, 1),  Fragment.from(updatedRows))\n    return StepResult.fromReplace(doc, tablePos, tablePos + table.nodeSize,\n                                  new Slice(Fragment.from(updatedTable), 0, 0))\n  };\n\n  AddColumnStep.prototype.getMap = function getMap () {\n    var this$1 = this;\n\n    var ranges = []\n    for (var i = 0; i < this.positions.length; i++)\n      { ranges.push(this$1.positions[i], 0, this$1.cells[i].nodeSize) }\n    return new StepMap(ranges)\n  };\n\n  AddColumnStep.prototype.invert = function invert (doc) {\n    var this$1 = this;\n\n    var $first = doc.resolve(this.positions[0])\n    var table = $first.node(-1)\n    var from = [], to = [], dPos = 0\n    for (var i = 0; i < table.childCount; i++) {\n      var pos = this$1.positions[i] + dPos, size = this$1.cells[i].nodeSize\n      from.push(pos)\n      to.push(pos + size)\n      dPos += size\n    }\n    return new RemoveColumnStep(from, to)\n  };\n\n  AddColumnStep.prototype.map = function map (mapping) {\n    return new AddColumnStep(this.positions.map(function (p) { return mapping.map(p); }), this.cells)\n  };\n\n  AddColumnStep.prototype.toJSON = function toJSON () {\n    return {stepType: this.jsonID,\n            positions: this.positions,\n            cells: this.cells.map(function (c) { return c.toJSON(); })}\n  };\n\n  AddColumnStep.fromJSON = function fromJSON (schema, json) {\n    return new AddColumnStep(json.positions, json.cells.map(schema.nodeFromJSON))\n  };\n\n  return AddColumnStep;\n}(Step));\nexports.AddColumnStep = AddColumnStep\n\nStep.jsonID(\"addTableColumn\", AddColumnStep)\n\n// ::- A subclass of `Step` that removes a column from a table.\nvar RemoveColumnStep = (function (Step) {\n  function RemoveColumnStep(from, to) {\n    Step.call(this)\n    this.from = from\n    this.to = to\n  }\n\n  if ( Step ) RemoveColumnStep.__proto__ = Step;\n  RemoveColumnStep.prototype = Object.create( Step && Step.prototype );\n  RemoveColumnStep.prototype.constructor = RemoveColumnStep;\n\n  // :: (Node, number, number) → RemoveColumnStep\n  // Create a step that deletes the column at `columnIndex` in the\n  // table after `tablePos`.\n  RemoveColumnStep.create = function create (doc, tablePos, columnIndex) {\n    var from = [], to = []\n    var table = doc.nodeAt(tablePos)\n    table.forEach(function (row, rowOff) {\n      var cellPos = tablePos + 2 + rowOff\n      for (var i = 0; i < columnIndex; i++) { cellPos += row.child(i).nodeSize }\n      from.push(cellPos)\n      to.push(cellPos + row.child(columnIndex).nodeSize)\n    })\n    return new RemoveColumnStep(from, to)\n  };\n\n  RemoveColumnStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var index = null, table = null, tablePos = null\n    for (var i = 0; i < this.from.length; i++) {\n      var $from = doc.resolve(this$1.from[i]), after = $from.nodeAfter\n      if ($from.depth < 2 || $from.index(-1) != i || !after || this$1.from[i] + after.nodeSize != this$1.to[i])\n        { return StepResult.fail(\"Invalid cell delete positions\") }\n      if (table == null) {\n        table = $from.node(-1)\n        if (table.childCount != this$1.from.length)\n          { return StepResult.fail(\"Mismatch in number of rows\") }\n        tablePos = $from.before(-1)\n        index = $from.index()\n      } else if ($from.before(-1) != tablePos || $from.index() != index) {\n        return StepResult.fail(\"Column delete positions not consistent\")\n      }\n    }\n\n    var updatedRows = []\n    for (var i$1 = 0; i$1 < table.childCount; i$1++) {\n      var row = table.child(i$1), rowCells = []\n      for (var j = 0; j < row.childCount; j++)\n        { if (j != index) { rowCells.push(row.child(j)) } }\n      updatedRows.push(row.type.create(adjustColumns(row.attrs, -1), Fragment.from(rowCells)))\n    }\n    var updatedTable = table.type.create(adjustColumns(table.attrs, -1),  Fragment.from(updatedRows))\n    return StepResult.fromReplace(doc, tablePos, tablePos + table.nodeSize,\n                                  new Slice(Fragment.from(updatedTable), 0, 0))\n  };\n\n  RemoveColumnStep.prototype.getMap = function getMap () {\n    var this$1 = this;\n\n    var ranges = []\n    for (var i = 0; i < this.from.length; i++)\n      { ranges.push(this$1.from[i], this$1.to[i] - this$1.from[i], 0) }\n    return new StepMap(ranges)\n  };\n\n  RemoveColumnStep.prototype.invert = function invert (doc) {\n    var this$1 = this;\n\n    var $first = doc.resolve(this.from[0])\n    var table = $first.node(-1), index = $first.index()\n    var positions = [], cells = [], dPos = 0\n    for (var i = 0; i < table.childCount; i++) {\n      positions.push(this$1.from[i] - dPos)\n      var cell = table.child(i).child(index)\n      dPos += cell.nodeSize\n      cells.push(cell)\n    }\n    return new AddColumnStep(positions, cells)\n  };\n\n  RemoveColumnStep.prototype.map = function map (mapping) {\n    var this$1 = this;\n\n    var from = [], to = []\n    for (var i = 0; i < this.from.length; i++) {\n      var start = mapping.map(this$1.from[i], 1), end = mapping.map(this$1.to[i], -1)\n      if (end <= start) { return null }\n      from.push(start)\n      to.push(end)\n    }\n    return new RemoveColumnStep(from, to)\n  };\n\n  RemoveColumnStep.fromJSON = function fromJSON (_schema, json) {\n    return new RemoveColumnStep(json.from, json.to)\n  };\n\n  return RemoveColumnStep;\n}(Step));\nexports.RemoveColumnStep = RemoveColumnStep\n\nStep.jsonID(\"removeTableColumn\", RemoveColumnStep)\n\n// Table-related command functions\n\nfunction findRow($pos, pred) {\n  for (var d = $pos.depth; d > 0; d--)\n    { if ($pos.node(d).type.spec.tableRow && (!pred || pred(d))) { return d } }\n  return -1\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that adds a column before the column with the\n// selection.\nfunction addColumnBefore(state, dispatch) {\n  var $from = state.selection.$from, cellFrom\n  var rowDepth = findRow($from, function (d) { return cellFrom = d == $from.depth ? $from.nodeBefore : $from.node(d + 1); })\n  if (rowDepth == -1) { return false }\n  if (dispatch)\n    { dispatch(state.tr.step(AddColumnStep.create(state.doc, $from.before(rowDepth - 1), $from.index(rowDepth),\n                                                cellFrom.type, cellFrom.attrs))) }\n  return true\n}\nexports.addColumnBefore = addColumnBefore\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that adds a column after the column with the\n// selection.\nfunction addColumnAfter(state, dispatch) {\n  var $from = state.selection.$from, cellFrom\n  var rowDepth = findRow($from, function (d) { return cellFrom = d == $from.depth ? $from.nodeAfter : $from.node(d + 1); })\n  if (rowDepth == -1) { return false }\n  if (dispatch)\n    { dispatch(state.tr.step(AddColumnStep.create(state.doc, $from.before(rowDepth - 1),\n                                                $from.indexAfter(rowDepth) + (rowDepth == $from.depth ? 1 : 0),\n                                                cellFrom.type, cellFrom.attrs))) }\n  return true\n}\nexports.addColumnAfter = addColumnAfter\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the column with the selection.\nfunction removeColumn(state, dispatch) {\n  var $from = state.selection.$from\n  var rowDepth = findRow($from, function (d) { return $from.node(d).childCount > 1; })\n  if (rowDepth == -1) { return false }\n  if (dispatch)\n    { dispatch(state.tr.step(RemoveColumnStep.create(state.doc, $from.before(rowDepth - 1), $from.index(rowDepth)))) }\n  return true\n}\nexports.removeColumn = removeColumn\n\nfunction addRow(state, dispatch, side) {\n  var $from = state.selection.$from\n  var rowDepth = findRow($from)\n  if (rowDepth == -1) { return false }\n  if (dispatch) {\n    var exampleRow = $from.node(rowDepth)\n    var cells = [], pos = side < 0 ? $from.before(rowDepth) : $from.after(rowDepth)\n    exampleRow.forEach(function (cell) { return cells.push(cell.type.createAndFill(cell.attrs)); })\n    var row = exampleRow.copy(Fragment.from(cells))\n    dispatch(state.tr.step(new ReplaceStep(pos, pos, new Slice(Fragment.from(row), 0, 0))))\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that adds a row after the row with the\n// selection.\nfunction addRowBefore(state, dispatch) {\n  return addRow(state, dispatch, -1)\n}\nexports.addRowBefore = addRowBefore\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that adds a row before the row with the\n// selection.\nfunction addRowAfter(state, dispatch) {\n  return addRow(state, dispatch, 1)\n}\nexports.addRowAfter = addRowAfter\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the row with the selection.\nfunction removeRow(state, dispatch) {\n  var $from = state.selection.$from\n  var rowDepth = findRow($from, function (d) { return $from.node(d - 1).childCount > 1; })\n  if (rowDepth == -1) { return false }\n  if (dispatch)\n    { dispatch(state.tr.step(new ReplaceStep($from.before(rowDepth), $from.after(rowDepth), Slice.empty))) }\n  return true\n}\nexports.removeRow = removeRow\n\nfunction moveCell(state, dir, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var rowDepth = findRow($from)\n  if (rowDepth == -1) { return false }\n  var row = $from.node(rowDepth), newIndex = $from.index(rowDepth) + dir\n  if (newIndex >= 0 && newIndex < row.childCount) {\n    var $cellStart = state.doc.resolve(row.content.offsetAt(newIndex) + $from.start(rowDepth))\n    var sel = Selection.findFrom($cellStart, 1)\n    if (!sel || sel.from >= $cellStart.end()) { return false }\n    if (dispatch) { dispatch(state.tr.setSelection(sel).scrollIntoView()) }\n    return true\n  } else {\n    var rowIndex = $from.index(rowDepth - 1) + dir, table = $from.node(rowDepth - 1)\n    if (rowIndex < 0 || rowIndex >= table.childCount) { return false }\n    var cellStart = dir > 0 ? $from.after(rowDepth) + 2 : $from.before(rowDepth) - 2 - table.child(rowIndex).lastChild.content.size\n    var $cellStart$1 = state.doc.resolve(cellStart), sel$1 = Selection.findFrom($cellStart$1, 1)\n    if (!sel$1 || sel$1.from >= $cellStart$1.end()) { return false }\n    if (dispatch) { dispatch(state.tr.setSelection(sel$1).scrollIntoView()) }\n    return true\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Move to the next cell in the current table, if there is one.\nfunction selectNextCell(state, dispatch) { return moveCell(state, 1, dispatch) }\nexports.selectNextCell = selectNextCell\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Move to the previous cell in the current table, if there is one.\nfunction selectPreviousCell(state, dispatch) { return moveCell(state, -1, dispatch) }\nexports.selectPreviousCell = selectPreviousCell\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-schema-table/dist/schema-table.js\n// module id = 55\n// module chunks = 1","var ref = require(\"prosemirror-transform\");\nvar Transform = ref.Transform;\nvar ref$1 = require(\"prosemirror-model\");\nvar Mark = ref$1.Mark;\nvar ref$2 = require(\"./selection\");\nvar Selection = ref$2.Selection;\n\nvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](##state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// informations that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](##state.StateField) accordingly.\n//\n// The [editor view](##view.EditorView) uses a single metadata\n// property: it will attach a property `\"pointer\"` with the value\n// `true` to selection transactions directly caused by mouse or touch\n// input.\nvar Transaction = (function (Transform) {\n  function Transaction(state) {\n    Transform.call(this, state.doc)\n    // :: number\n    // The timestamp associated with this transaction.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks in this transaction.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  if ( Transform ) Transaction.__proto__ = Transform;\n  Transaction.prototype = Object.create( Transform && Transform.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { docChanged: {},selection: {},selectionSet: {},storedMarksSet: {},isGeneric: {},scrolledIntoView: {} };\n\n  // :: bool\n  // True when this transaction changes the document.\n  prototypeAccessors.docChanged.get = function () {\n    return this.steps.length > 0\n  };\n\n  // :: Selection\n  // The transform's current selection. This defaults to the\n  // editor selection [mapped](#state.Selection.map) through the steps in\n  // this transform, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. This will determine\n  // the selection that the editor gets when the transaction is\n  // applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return this.updated & UPDATED_SEL > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Replace the set of stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return this.updated & UPDATED_MARKS > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform.prototype.addStep.call(this, step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    var ref = this.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var startLen = this.steps.length\n    this.replaceRange(from, to, slice)\n    // Move the selection to the position after the inserted content.\n    // When that ended in an inline node, search backwards, to get the\n    // position after that node. If not, search forward.\n    var lastNode = slice.content.lastChild, lastParent = null\n    for (var i = 0; i < slice.openRight; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n    selectionToInsertionEnd(this, startLen, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node or slice, or delete it\n  // if `content` is null. When `inheritMarks` is true and the content\n  // is inline, it inherits the marks from the place where it is\n  // inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var ref = this.selection;\n    var $from = ref.$from;\n    var from = ref.from;\n    var to = ref.to;\n    var startLen = this.steps.length\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || $from.marks(to > from)) }\n    this.replaceRangeWith(from, to, node)\n    selectionToInsertionEnd(this, startLen, node.isInline ? -1 : 1)\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    var ref = this.selection;\n    var from = ref.from;\n    var to = ref.to;\n    return this.deleteRange(from, to)\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var node = schema.text(text, this.storedMarks || this.doc.resolve(from).marks(to > from))\n      return this.replaceRangeWith(from, to, node)\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus be safely extended.\n  prototypeAccessors.isGeneric.get = function () {\n    var this$1 = this;\n\n    for (var _ in this$1.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return this.updated | UPDATED_SCROLL > 0\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    this.storedMarks = mark.addToSet(this.storedMarks || currentMarks(this.selection))\n    return this\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    this.storedMarks = mark.removeFromSet(this.storedMarks || currentMarks(this.selection))\n    return this\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(Transform));\nexports.Transaction = Transaction\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  if (tr.steps.length == startLen) { return }\n  var map = tr.mapping.maps[tr.mapping.maps.length - 1], end\n  map.forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; })\n  if (end != null) { tr.setSelection(Selection.near(tr.doc.resolve(end), bias)) }\n}\n\nfunction currentMarks(selection) {\n  return selection.head == null ? Mark.none : selection.$head.marks()\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-state/dist/transaction.js\n// module id = 56\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Fragment = ref.Fragment;\nvar Slice = ref.Slice;\nvar ref$1 = require(\"./step\");\nvar Step = ref$1.Step;\nvar StepResult = ref$1.StepResult;\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = []\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i)\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)) }\n    if (child.isInline) { child = f(child, parent, i) }\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = (function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this)\n    this.from = from\n    this.to = to\n    this.mark = mark\n  }\n\n  if ( Step ) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    var parent = $from.node($from.sharedDepth(this.to))\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent, index) {\n      if (!parent.contentMatchAt(index + 1).allowsMark(this$1.mark.type)) { return node }\n      return node.mark(this$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openLeft, oldSlice.openRight)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\nexports.AddMarkStep = AddMarkStep\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = (function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this)\n    this.from = from\n    this.to = to\n    this.mark = mark\n  }\n\n  if ( Step ) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to)\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openLeft, oldSlice.openRight)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\nexports.RemoveMarkStep = RemoveMarkStep\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/mark_step.js\n// module id = 57\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Slice = ref.Slice;\nvar Fragment = ref.Fragment;\n\nvar ref$1 = require(\"./transform\");\nvar Transform = ref$1.Transform;\nvar ref$2 = require(\"./replace_step\");\nvar ReplaceStep = ref$2.ReplaceStep;\nvar ReplaceAroundStep = ref$2.ReplaceAroundStep;\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted.\nfunction liftTarget(range) {\n  var parent = range.parent\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth), index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      { return depth }\n    if (depth == 0 || !canCut(node, index, endIndex)) { break }\n  }\n}\nexports.liftTarget = liftTarget\n\n// :: (NodeRange, number) → Transform\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// `liftTarget` to compute `target`, in order to be sure the lift is\n// valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  var start = gapStart, end = gapEnd\n\n  var before = Fragment.empty, openLeft = 0\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openLeft++\n    } else {\n      start--\n    } }\n  var after = Fragment.empty, openRight = 0\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true\n      after = Fragment.from($to.node(d$1).copy(after))\n      openRight++\n    } else {\n      end++\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openLeft, openRight),\n                                         before.size - openLeft, true))\n}\n\n// :: (NodeRange, NodeType, ?Object) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found.\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if ( innerRange === void 0 ) innerRange = range;\n\n  var wrap = {type: nodeType, attrs: attrs}\n  var around = findWrappingOutside(range, wrap)\n  var inner = around && findWrappingInside(innerRange, wrap)\n  if (!inner) { return null }\n  return around.concat(wrap).concat(inner)\n}\nexports.findWrapping = findWrapping\n\nfunction findWrappingOutside(range, wrap) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(wrap.type, wrap.attrs)\n  if (!around) { return null }\n  var outer = around.length ? around[0] : wrap\n  if (!parent.canReplaceWith(startIndex, endIndex, outer.type, outer.attrs))\n    { return null }\n  return around\n}\n\nfunction findWrappingInside(range, wrap) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex)\n  var inside = wrap.type.contentExpr.start(wrap.attrs).findWrappingFor(inner)\n  if (!inside) { return null }\n  var last = inside.length ? inside[inside.length - 1] : wrap\n  var innerMatch = last.type.contentExpr.start(last.attrs)\n  for (var i = startIndex; i < endIndex; i++)\n    { innerMatch = innerMatch && innerMatch.matchNode(parent.child(i)) }\n  if (!innerMatch || !innerMatch.validEnd()) { return null }\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → Transform\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with `findWrapping`.\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = Fragment.empty\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)) }\n\n  var start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → Transform\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearNonMatching(this$1.mapping.slice(mapFrom).map(pos, 1), type.contentExpr.start(attrs))\n      var mapping = this$1.mapping.slice(mapFrom)\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\n// :: (number, ?NodeType, ?Object) → Transform\n// Change the type and attributes of the node after `pos`.\nTransform.prototype.setNodeType = function(pos, type, attrs) {\n  var node = this.doc.nodeAt(pos)\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type }\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, type.create(attrs, null, node.marks)) }\n\n  if (!type.validContent(node.content, attrs))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(type.create(attrs)), 0, 0), 1, true))\n}\n\n// :: (Node, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = doc.resolve(pos), base = $pos.depth - depth\n  if (base < 0 ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !$pos.parent.canReplace(0, $pos.indexAfter()))\n    { return false }\n  for (var d = $pos.depth - 1, i = depth - 1; d > base; d--, i--) {\n    var node = $pos.node(d), index$1 = $pos.index(d)\n    var typeAfter = typesAfter && typesAfter[i]\n    if (!node.canReplace(0, index$1) ||\n        !node.canReplaceWith(index$1, node.childCount, typeAfter ? typeAfter.type : $pos.node(d + 1).type,\n                             typeAfter ? typeAfter.attrs : $pos.node(d + 1).attrs))\n      { return false }\n  }\n  var index = $pos.indexAfter(base)\n  var baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type,\n                                        baseType ? baseType.attrs : $pos.node(base + 1).attrs)\n}\nexports.canSplit = canSplit\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → Transform\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    var typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth, true)))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\nexports.canJoin = canJoin\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos, dir) {\n  if ( dir === void 0 ) dir = -1;\n\n  var $pos = doc.resolve(pos)\n  for (var d = $pos.depth;; d--) {\n    var before = (void 0), after = (void 0)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      after = $pos.node(d).maybeChild($pos.index(d) + 1)\n    } else {\n      before = $pos.node(d).maybeChild($pos.index(d) - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after)) { return pos }\n    if (d == 0) { break }\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\nexports.joinPoint = joinPoint\n\n// :: (number, ?number, ?bool) → Transform\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType, ?Object) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType, attrs) {\n  var $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType, attrs)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType, attrs)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1)\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType, attrs)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\nexports.insertPoint = insertPoint\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/structure.js\n// module id = 58\n// module chunks = 1","function compareObjs(a, b) {\n  if (a == b) { return true }\n  for (var p in a) { if (a[p] !== b[p]) { return false } }\n  for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  return true\n}\n\nvar WidgetType = function(widget, options) {\n  if (widget.nodeType != 1) {\n    var wrap = document.createElement(\"span\")\n    wrap.appendChild(widget)\n    widget = wrap\n  }\n  widget.contentEditable = false\n  widget.classList.add(\"ProseMirror-widget\")\n  this.widget = widget\n  this.options = options || noOptions\n};\n\nWidgetType.prototype.map = function (mapping, span, offset, oldOffset) {\n  var ref = mapping.mapResult(span.from + oldOffset, this.options.associative == \"left\" ? -1 : 1);\n    var pos = ref.pos;\n    var deleted = ref.deleted;\n  return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n};\n\nWidgetType.prototype.valid = function () { return true };\n\nWidgetType.prototype.eq = function (other) {\n  return this == other ||\n    (other instanceof WidgetType && (this.widget == other.widget || this.options.key) &&\n     compareObjs(this.options, other.options))\n};\n\nvar InlineType = function(attrs, options) {\n  this.options = options || noOptions\n  this.attrs = attrs\n};\n\nInlineType.prototype.map = function (mapping, span, offset, oldOffset) {\n  var from = mapping.map(span.from + oldOffset, this.options.inclusiveLeft ? -1 : 1) - offset\n  var to = mapping.map(span.to + oldOffset, this.options.inclusiveRight ? 1 : -1) - offset\n  return from >= to ? null : new Decoration(from, to, this)\n};\n\nInlineType.prototype.valid = function (_, span) { return span.from < span.to };\n\nInlineType.prototype.eq = function (other) {\n  return this == other ||\n    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.options, other.options))\n};\n\nInlineType.is = function (span) { return span.type instanceof InlineType };\n\nvar NodeType = function(attrs, options) {\n  this.attrs = attrs\n  this.options = options || noOptions\n};\n\nNodeType.prototype.map = function (mapping, span, offset, oldOffset) {\n  var from = mapping.mapResult(span.from + oldOffset, 1)\n  if (from.deleted) { return null }\n  var to = mapping.mapResult(span.to + oldOffset, -1)\n  if (to.deleted || to.pos <= from.pos) { return null }\n  return new Decoration(from.pos - offset, to.pos - offset, this)\n};\n\nNodeType.prototype.valid = function (node, span) {\n  var ref = node.content.findIndex(span.from);\n    var index = ref.index;\n    var offset = ref.offset;\n  return offset == span.from && offset + node.child(index).nodeSize == span.to\n};\n\nNodeType.prototype.eq = function (other) {\n  return this == other ||\n    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.options, other.options))\n};\n\n// ::- Decorations can be provided to the view (through the\n// [`decorations` prop](#view.EditorProps.decorations)) to adjust the\n// way the document is drawn. They come in several variants. See the\n// static members of this class for details.\nvar Decoration = function(from, to, type) {\n  this.from = from\n  this.to = to\n  this.type = type\n};\n\nvar prototypeAccessors = { options: {} };\n\nDecoration.prototype.copy = function (from, to) {\n  return new Decoration(from, to, this.type)\n};\n\nDecoration.prototype.eq = function (other) {\n  return this.type.eq(other.type) && this.from == other.from && this.to == other.to\n};\n\nDecoration.prototype.map = function (mapping, offset, oldOffset) {\n  return this.type.map(mapping, this, offset, oldOffset)\n};\n\n// :: (number, dom.Node, ?Object) → Decoration\n// Creates a widget decoration, which is a DOM node that's shown in\n// the document at the given position.\n//\n// options::- These options are supported:\n//\n//   associative:: ?string\n//   By default, widgets are right-associative, meaning they end\n//   up to the right of content inserted at their position. You\n//   can set this to `\"left\"` to make it left-associative, so that\n//   the inserted content will end up after the widget.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to control which DOM events, when they bubble out\n//   of this widget, the editor view should ignore.\n//\n//   key:: ?string\n//   When comparing decorations of this type (in order to decide\n//   whether it needs to be redrawn), ProseMirror will by default\n//   compare the widget DOM node by identity. If you pass a key,\n//   that key will be compared instead, which can be useful when\n//   you generate decorations on the fly and don't want to store\n//   and reuse DOM nodes.\nDecoration.widget = function (pos, dom, options) {\n  return new Decoration(pos, pos, new WidgetType(dom, options))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates an inline decoration, which adds the given attributes to\n// each inline node between `from` and `to`.\n//\n// options::- These options are recognized:\n//\n//   inclusiveLeft:: ?bool\n//   Determines how the left side of the decoration is\n//   [mapped](#transform.Position_Mapping) when content is\n//   inserted directly at that positon. By default, the decoration\n//   won't include the new content, but you can set this to `true`\n//   to make it inclusive.\n//\n//   inclusiveRight:: ?bool\n//   Determines how the right side of the decoration is mapped.\n//   See\n//   [`inclusiveLeft`](#view.Decoration^inline^options.inclusiveLeft).\nDecoration.inline = function (from, to, attrs, options) {\n  return new Decoration(from, to, new InlineType(attrs, options))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates a node decoration. `from` and `to` should point precisely\n// before and after a node in the document. That node, and only that\n// node, will receive the given attributes.\nDecoration.node = function (from, to, attrs, options) {\n  return new Decoration(from, to, new NodeType(attrs, options))\n};\n\n// :: Object\n// The options provided when creating this decoration. Can be useful\n// if you've stored extra information in that object.\nprototypeAccessors.options.get = function () { return this.type.options };\n\nObject.defineProperties( Decoration.prototype, prototypeAccessors );\nexports.Decoration = Decoration\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nvar none = [], noOptions = {}\n\n// ::- A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nvar DecorationSet = function(local, children) {\n  this.local = local && local.length ? local : none\n  this.children = children && children.length ? children : none\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Create a set of decorations, using the structure of the given\n// document.\nDecorationSet.create = function (doc, decorations) {\n  return decorations.length ? buildTree(decorations, doc, 0, noOptions) : empty\n};\n\n// :: (?number, ?number) → [Decoration]\n// Find all decorations in this set which touch the given range\n// (including decorations that start or end directly at the\n// boundaries). When the arguments are omitted, all decorations in\n// the set are collected.\nDecorationSet.prototype.find = function (start, end) {\n  var result = []\n  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0)\n  return result\n};\n\nDecorationSet.prototype.findInner = function (start, end, result, offset) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.local.length; i++) {\n    var span = this$1.local[i]\n    if (span.from <= end && span.to >= start)\n      { result.push(span.copy(span.from + offset, span.to + offset)) }\n  }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {\n    if (this$1.children[i$1] < end && this$1.children[i$1 + 1] > start) {\n      var childOff = this$1.children[i$1] + 1\n      this$1.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff)\n    }\n  }\n};\n\n// :: (Mapping, Node, ?Object) → DecorationSet\n// Map the set of decorations in response to a change in the\n// document.\n//\n// options::- An optional set of options.\n//\n//   onRemove:: ?(decorationOptions: Object)\n//   When given, this function will be called for each decoration\n//   that gets dropped as a result of the mapping, passing the\n//   options of that decoration.\nDecorationSet.prototype.map = function (mapping, doc, options) {\n  if (this == empty || mapping.maps.length == 0) { return this }\n  return this.mapInner(mapping, doc, 0, 0, options || noOptions)\n};\n\nDecorationSet.prototype.mapInner = function (mapping, node, offset, oldOffset, options) {\n    var this$1 = this;\n\n  var newLocal\n  for (var i = 0; i < this.local.length; i++) {\n    var mapped = this$1.local[i].map(mapping, offset, oldOffset)\n    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped) }\n    else if (options.onRemove) { options.onRemove(this$1.local[i].options) }\n  }\n\n  if (this.children.length)\n    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }\n  else\n    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Add the given array of decorations to the ones in the set,\n// producing a new set. Needs access to the current document to\n// create the appropriate tree structure.\nDecorationSet.prototype.add = function (doc, decorations) {\n  if (!decorations.length) { return this }\n  if (this == empty) { return DecorationSet.create(doc, decorations) }\n  return this.addInner(doc, decorations, 0)\n};\n\nDecorationSet.prototype.addInner = function (doc, decorations, offset) {\n    var this$1 = this;\n\n  var children, childIndex = 0\n  doc.forEach(function (childNode, childOffset) {\n    var baseOffset = childOffset + offset, found\n    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }\n\n    if (!children) { children = this$1.children.slice() }\n    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3 }\n    if (children[childIndex] == childOffset)\n      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1) }\n    else\n      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noOptions)) }\n    childIndex += 3\n  })\n\n  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset)\n  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                           children || this.children)\n};\n\n// :: ([Decoration]) → DecorationSet\n// Create a new set that contains the decorations in this set, minus\n// the ones in the given array.\nDecorationSet.prototype.remove = function (decorations) {\n  if (decorations.length == 0 || this == empty) { return this }\n  return this.removeInner(decorations, 0)\n};\n\nDecorationSet.prototype.removeInner = function (decorations, offset) {\n    var this$1 = this;\n\n  var children = this.children, local = this.local\n  for (var i = 0; i < children.length; i += 3) {\n    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset\n    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {\n      if (span.from > from && span.to < to) {\n        decorations[j] = null\n        ;(found || (found = [])).push(span)\n      }\n    } }\n    if (!found) { continue }\n    if (children == this$1.children) { children = this$1.children.slice() }\n    var removed = children[i + 2].removeInner(found, from + 1)\n    if (removed != empty) {\n      children[i + 2] = removed\n    } else {\n      children.splice(i, 3)\n      i -= 3\n    }\n  }\n  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {\n    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].type == span$1.type) {\n      if (local == this$1.local) { local = this$1.local.slice() }\n      local.splice(j$1--, 1)\n    } }\n  } } }\n  if (children == this.children && local == this.local) { return this }\n  return local.length || children.length ? new DecorationSet(local, children) : empty\n};\n\nDecorationSet.prototype.forChild = function (offset, node) {\n    var this$1 = this;\n\n  if (this == empty) { return this }\n  if (node.isLeaf) { return DecorationSet.empty }\n\n  var child, local\n  for (var i = 0; i < this.children.length; i += 3) { if (this$1.children[i] >= offset) {\n    if (this$1.children[i] == offset) { child = this$1.children[i + 2] }\n    break\n  } }\n  var start = offset + 1, end = start + node.content.size\n  for (var i$1 = 0; i$1 < this.local.length; i$1++) {\n    var dec = this$1.local[i$1]\n    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start\n      if (from < to) { (local || (local = [])).push(dec.copy(from, to)) }\n    }\n  }\n  if (local) {\n    var localSet = new DecorationSet(local)\n    return child ? new DecorationGroup([localSet, child]) : localSet\n  }\n  return child || empty\n};\n\nDecorationSet.prototype.eq = function (other) {\n    var this$1 = this;\n\n  if (this == other) { return true }\n  if (!(other instanceof DecorationSet) ||\n      this.local.length != other.local.length ||\n      this.children.length != other.children.length) { return false }\n  for (var i = 0; i < this.local.length; i++)\n    { if (!this$1.local[i].eq(other.local[i])) { return false } }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)\n    { if (this$1.children[i$1] != other.children[i$1] ||\n        this$1.children[i$1 + 1] != other.children[i$1 + 1] ||\n        !this$1.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }\n  return false\n};\n\nDecorationSet.prototype.locals = function (node) {\n  return removeOverlap(this.localsInner(node))\n};\n\nDecorationSet.prototype.localsInner = function (node) {\n    var this$1 = this;\n\n  if (this == empty) { return none }\n  if (node.isTextblock || !this.local.some(InlineType.is)) { return this.local }\n  var result = []\n  for (var i = 0; i < this.local.length; i++) {\n    if (!(this$1.local[i].type instanceof InlineType))\n      { result.push(this$1.local[i]) }\n  }\n  return result\n};\nexports.DecorationSet = DecorationSet\n\nvar empty = new DecorationSet()\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty\n\nvar DecorationGroup = function(members) {\n  this.members = members\n};\n\nDecorationGroup.prototype.forChild = function (offset, child) {\n    var this$1 = this;\n\n  if (child.isLeaf) { return DecorationSet.empty }\n  var found = []\n  for (var i = 0; i < this.members.length; i++) {\n    var result = this$1.members[i].forChild(offset, child)\n    if (result == empty) { continue }\n    if (result instanceof DecorationGroup) { found = found.concat(result.members) }\n    else { found.push(result) }\n  }\n  return DecorationGroup.from(found)\n};\n\nDecorationGroup.prototype.eq = function (other) {\n    var this$1 = this;\n\n  if (!(other instanceof DecorationGroup) ||\n      other.members.length != this.members.length) { return false }\n  for (var i = 0; i < this.members.length; i++)\n    { if (!this$1.members[i].eq(other.members[i])) { return false } }\n  return true\n};\n\nDecorationGroup.prototype.locals = function (node) {\n    var this$1 = this;\n\n  var result, sorted = true\n  for (var i = 0; i < this.members.length; i++) {\n    var locals = this$1.members[i].localsInner(node)\n    if (!locals.length) { continue }\n    if (!result) {\n      result = locals\n    } else {\n      if (sorted) {\n        result = result.slice()\n        sorted = false\n      }\n      for (var j = 0; j < locals.length; j++) { result.push(locals[j]) }\n    }\n  }\n  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n};\n\nDecorationGroup.from = function (members) {\n  switch (members.length) {\n    case 0: return empty\n    case 1: return members[0]\n    default: return new DecorationGroup(members)\n  }\n};\nexports.DecorationGroup = DecorationGroup\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  var children = oldChildren.slice()\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  var shift = function (oldStart, oldEnd, newStart, newEnd) {\n    for (var i = 0; i < children.length; i += 3) {\n      var end = children[i + 1], dSize = (void 0)\n      if (end == -1 || oldStart > end + oldOffset) { continue }\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1\n      } else if (dSize = (newEnd - newStart) - (oldEnd - oldStart)) {\n        children[i] += dSize\n        children[i + 1] += dSize\n      }\n    }\n  }\n  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift) }\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  var mustRebuild = false\n  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes\n    var from = mapping.map(children[i$1] + oldOffset), fromLocal = from - offset\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset\n    var ref = node.content.findIndex(fromLocal);\n    var index = ref.index;\n    var childOffset = ref.offset;\n    var childNode = node.maybeChild(index)\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, children[i$1] + oldOffset + 1, options)\n      if (mapped != empty) {\n        children[i$1] = fromLocal\n        children[i$1 + 1] = toLocal\n        children[i$1 + 2] = mapped\n      } else {\n        children.splice(i$1, 3)\n        i$1 -= 3\n      }\n    } else {\n      mustRebuild = true\n    }\n  } }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    var decorations = mapAndGatherRemainingDecorations(children, newLocal ? moveSpans(newLocal, offset) : [], mapping, oldOffset, options)\n    var built = buildTree(decorations, node, 0, options)\n    newLocal = built.local\n    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] == -1) {\n      children.splice(i$2, 3)\n      i$2 -= 3\n    } }\n    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {\n      var from$1 = built.children[i$3]\n      while (j < children.length && children[j] < from$1) { j += 3 }\n      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2])\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) { return spans }\n  var result = []\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i]\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type))\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, decorations, mapping, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (var i = 0; i < set.local.length; i++) {\n      var mapped = set.local[i].map(mapping, 0, oldOffset)\n      if (mapped) { decorations.push(mapped) }\n      else if (options.onRemove) { options.onRemove(set.local[i].options) }\n    }\n    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)\n      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1) }\n  }\n  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)\n    { gather(children[i + 2], children[i] + oldOffset + 1) } }\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) { return null }\n  var end = offset + node.nodeSize, found = null\n  for (var i = 0, span = (void 0); i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      ;(found || (found = [])).push(span)\n      spans[i] = null\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  var result = []\n  for (var i = 0; i < array.length; i++)\n    { if (array[i] != null) { result.push(array[i]) } }\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtractet from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  var children = [], hasNulls = false\n  node.forEach(function (childNode, localStart) {\n    var found = takeSpansForNode(spans, childNode, localStart + offset)\n    if (found) {\n      hasNulls = true\n      var subtree = buildTree(found, childNode, offset + localStart + 1, options)\n      if (subtree != empty)\n        { children.push(localStart, localStart + childNode.nodeSize, subtree) }\n    }\n  })\n  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos)\n  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) { options.onRemove(locals[i].options) }\n    locals.splice(i--, 1)\n  } }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decorations]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  var working = spans\n  for (var i = 0; i < working.length - 1; i++) {\n    var span = working[i]\n    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {\n      var next = working[j]\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) { working = spans.slice() }\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to)\n          insertAhead(working, j + 1, next.copy(span.to, next.to))\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) { working = spans.slice() }\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from)\n          insertAhead(working, j, span.copy(next.from, span.to))\n        }\n        break\n      }\n    } }\n  }\n  return working\n}\nexports.removeOverlap = removeOverlap\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) { i++ }\n  array.splice(i, 0, deco)\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n  var found = []\n  view.someProp(\"decorations\", function (f) {\n    var result = f(view.state)\n    if (result && result != empty) { found.push(result) }\n  })\n  return DecorationGroup.from(found)\n}\nexports.viewDecorations = viewDecorations\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/decoration.js\n// module id = 59\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar EditorState = ref.EditorState;\nvar ref$1 = require(\"prosemirror-transform\");\nvar Mapping = ref$1.Mapping;\n\nvar TrackedRecord = function(prev, mapping, state) {\n  this.prev = prev\n  this.mapping = mapping\n  this.state = state\n};\n\nvar TrackMappings = function(state) {\n  this.seen = [new TrackedRecord(null, null, state)]\n  // Kludge to listen to state changes globally in order to be able\n  // to find mappings from a given state to another.\n  EditorState.addApplyListener(this.track = this.track.bind(this))\n};\n\nTrackMappings.prototype.destroy = function () {\n  EditorState.removeApplyListener(this.track)\n};\n\nTrackMappings.prototype.find = function (state) {\n    var this$1 = this;\n\n  for (var i = this.seen.length - 1; i >= 0; i--) {\n    var record = this$1.seen[i]\n    if (record.state == state) { return record }\n  }\n};\n\nTrackMappings.prototype.track = function (old, tr, state) {\n  var found = this.seen.length < 200 ? this.find(old) : null\n  if (found)\n    { this.seen.push(new TrackedRecord(found, tr.docChanged ? tr.mapping : null, state)) }\n};\n\nTrackMappings.prototype.getMapping = function (state) {\n  var found = this.find(state)\n  if (!found) { return null }\n  var mappings = []\n  for (var rec = found; rec; rec = rec.prev)\n    { if (rec.mapping) { mappings.push(rec.mapping) } }\n  var result = new Mapping\n  for (var i = mappings.length - 1; i >= 0; i--)\n    { result.appendMapping(mappings[i]) }\n  return result\n};\nexports.TrackMappings = TrackMappings\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/trackmappings.js\n// module id = 60\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/array/from.js\n// module id = 81\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/assign.js\n// module id = 82\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _from = require(\"../core-js/array/from\");\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/toConsumableArray.js\n// module id = 83\n// module chunks = 1","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/array/from.js\n// module id = 84\n// module chunks = 1","var core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/json/stringify.js\n// module id = 85\n// module chunks = 1","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/assign.js\n// module id = 86\n// module chunks = 1","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 87\n// module chunks = 1","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 88\n// module chunks = 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_classof.js\n// module id = 89\n// module chunks = 1","'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_create-property.js\n// module id = 90\n// module chunks = 1","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_html.js\n// module id = 91\n// module chunks = 1","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 92\n// module chunks = 1","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array-iter.js\n// module id = 93\n// module chunks = 1","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-call.js\n// module id = 94\n// module chunks = 1","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-create.js\n// module id = 95\n// module chunks = 1","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-define.js\n// module id = 96\n// module chunks = 1","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-detect.js\n// module id = 97\n// module chunks = 1","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_library.js\n// module id = 98\n// module chunks = 1","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-assign.js\n// module id = 99\n// module chunks = 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-create.js\n// module id = 100\n// module chunks = 1","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dps.js\n// module id = 101\n// module chunks = 1","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 102\n// module chunks = 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gpo.js\n// module id = 103\n// module chunks = 1","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 104\n// module chunks = 1","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 105\n// module chunks = 1","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine.js\n// module id = 106\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_string-at.js\n// module id = 107\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 108\n// module chunks = 1","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 109\n// module chunks = 1","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator-method.js\n// module id = 110\n// module chunks = 1","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.array.from.js\n// module id = 111\n// module chunks = 1","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.assign.js\n// module id = 112\n// module chunks = 1","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.string.iterator.js\n// module id = 113\n// module chunks = 1","/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.NProgress = factory();\n  }\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nprogress/nprogress.js\n// module id = 133\n// module chunks = 1","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key)\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this\n    var found = self.find(key), content = self.content.slice()\n    if (found == -1) {\n      content.push(newKey || key, value)\n    } else {\n      content[found + 1] = value\n      if (newKey) content[found] = newKey\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key)\n    if (found == -1) return this\n    var content = this.content.slice()\n    content.splice(found, 2)\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice()\n    content.push(key, value)\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice()\n    var found = without.find(place)\n    content.splice(found == -1 ? content.length : found, 0, key, value)\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1])\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map)\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map)\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this\n    map = OrderedMap.from(map)\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i])\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n}\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = []\n  if (value) for (var prop in value) content.push(prop, value[prop])\n  return new OrderedMap(content)\n}\n\nmodule.exports = OrderedMap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/orderedmap/index.js\n// module id = 134\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar Plugin = ref.Plugin;\nvar ref$1 = require(\"prosemirror-view\");\nvar Decoration = ref$1.Decoration;\nvar DecorationSet = ref$1.DecorationSet;\n\nvar gecko = typeof navigator != \"undefined\" && /gecko\\/\\d/i.test(navigator.userAgent)\nvar linux = typeof navigator != \"undefined\" && /linux/i.test(navigator.platform)\n\nfunction dropCursor(options) {\n  function dispatch(view, data) {\n    view.dispatch(view.state.tr.setMeta(plugin, data))\n  }\n\n  var timeout = null\n  function scheduleRemoval(view) {\n    clearTimeout(timeout)\n    timeout = setTimeout(function () {\n      if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n    }, 1000)\n  }\n\n  var plugin = new Plugin({\n    state: {\n      init: function init() { return null },\n      apply: function apply(tr, prev, state) {\n        // Firefox on Linux gets really confused an breaks dragging when we\n        // mess with the nodes around the target node during a drag. So\n        // disable this plugin there. See https://bugzilla.mozilla.org/show_bug.cgi?id=1323170\n        if (gecko && linux) { return null }\n        var command = tr.getMeta(plugin)\n        if (!command) { return prev }\n        if (command.type == \"set\") { return pluginStateFor(state, command.pos, options) }\n        return null\n      }\n    },\n    props: {\n      handleDOMEvents: {\n        dragover: function dragover(view, event) {\n          var active = plugin.getState(view.state)\n          var pos = view.posAtCoords({left: event.clientX, top: event.clientY})\n          if (pos && !active || active.pos != pos.pos) { dispatch(view, {type: \"setDropCursor\", pos: pos.pos}) }\n          scheduleRemoval(view)\n          return false\n        },\n\n        dragend: function dragend(view) {\n          if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n          return false\n        },\n\n        drop: function drop(view) {\n          if (plugin.getState(view.state)) { dispatch(view, {type: \"remove\"}) }\n          return false\n        },\n\n        dragleave: function dragleave(view, event) {\n          if (event.target == view.content) { dispatch(view, {type: \"remove\"}) }\n          return false\n        }\n      },\n      decorations: function decorations(state) {\n        var active = plugin.getState(state)\n        return active && active.deco\n      }\n    }\n  })\n  return plugin\n}\nexports.dropCursor = dropCursor\n\nfunction style(options, side) {\n  var width = (options && options.width) || 1\n  var color = (options && options.color) || \"black\"\n  return (\"border-\" + side + \": \" + width + \"px solid \" + color + \"; margin-\" + side + \": -\" + width + \"px\")\n}\n\nfunction pluginStateFor(state, pos, options) {\n  var $pos = state.doc.resolve(pos), deco\n  if (!$pos.parent.isTextblock) {\n    var before, after\n    if (before = $pos.nodeBefore)\n      { deco = Decoration.node(pos - before.nodeSize, pos, {nodeName: \"div\", style: style(options, \"right\")}) }\n    else if (after = $pos.nodeAfter)\n      { deco = Decoration.node(pos, pos + after.nodeSize, {nodeName: \"div\", style: style(options, \"left\")}) }\n  }\n  if (!deco) {\n    var node = document.createElement(\"span\")\n    node.textContent = \"\\u200b\"\n    node.style.cssText = style(options, \"left\") + \"; display: inline-block; pointer-events: none\"\n    deco = Decoration.widget(pos, node)\n  }\n  return {pos: pos, deco: DecorationSet.create(state.doc, [deco])}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-dropcursor/dist/dropcursor.js\n// module id = 135\n// module chunks = 1","var ref = require(\"prosemirror-inputrules\");\nvar blockQuoteRule = ref.blockQuoteRule;\nvar orderedListRule = ref.orderedListRule;\nvar bulletListRule = ref.bulletListRule;\nvar codeBlockRule = ref.codeBlockRule;\nvar headingRule = ref.headingRule;\nvar inputRules = ref.inputRules;\nvar allInputRules = ref.allInputRules;\nvar ref$1 = require(\"prosemirror-keymap\");\nvar keymap = ref$1.keymap;\nvar ref$2 = require(\"prosemirror-history\");\nvar history = ref$2.history;\nvar ref$3 = require(\"prosemirror-commands\");\nvar baseKeymap = ref$3.baseKeymap;\nvar ref$4 = require(\"prosemirror-state\");\nvar Plugin = ref$4.Plugin;\nvar ref$5 = require(\"prosemirror-dropcursor\");\nvar dropCursor = ref$5.dropCursor;\n\nvar ref$6 = require(\"./menu\");\nvar buildMenuItems = ref$6.buildMenuItems;\nexports.buildMenuItems = buildMenuItems\nvar ref$7 = require(\"./keymap\");\nvar buildKeymap = ref$7.buildKeymap;\nexports.buildKeymap = buildKeymap\n\n// !! This module exports helper functions for deriving a set of basic\n// menu items, input rules, or key bindings from a schema. These\n// values need to know about the schema for two reasons—they need\n// access to specific instances of node and mark types, and they need\n// to know which of the node and mark types that they know about are\n// actually present in the schema.\n//\n// The `exampleSetup` plugin ties these together into a plugin that\n// will automatically enable this basic functionality in an editor.\n\n// :: (Object) → [Plugin]\n// A convenience plugin that bundles together a simple menu with basic\n// key bindings, input rules, and styling for the example schema.\n// Probably only useful for quickly setting up a passable\n// editor—you'll need more control over your settings in most\n// real-world situations.\n//\n//   options::- The following options are recognized:\n//\n//     schema:: Schema\n//     The schema to generate key bindings and menu items for.\n//\n//     mapKeys:: ?Object\n//     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.\nfunction exampleSetup(options) {\n  var plugins = [\n    inputRules({rules: allInputRules.concat(buildInputRules(options.schema))}),\n    keymap(buildKeymap(options.schema, options.mapKeys)),\n    keymap(baseKeymap),\n    dropCursor()\n  ]\n  if (options.history !== false) { plugins.push(history()) }\n\n  return plugins.concat(new Plugin({\n    props: {\n      attributes: {class: \"ProseMirror-example-setup-style\"},\n      menuContent: buildMenuItems(options.schema).fullMenu,\n      floatingMenu: true\n    }\n  }))\n}\nexports.exampleSetup = exampleSetup\n\n// :: (Schema) → [InputRule]\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\nfunction buildInputRules(schema) {\n  var result = [], type\n  if (type = schema.nodes.blockquote) { result.push(blockQuoteRule(type)) }\n  if (type = schema.nodes.ordered_list) { result.push(orderedListRule(type)) }\n  if (type = schema.nodes.bullet_list) { result.push(bulletListRule(type)) }\n  if (type = schema.nodes.code_block) { result.push(codeBlockRule(type)) }\n  if (type = schema.nodes.heading) { result.push(headingRule(type, 6)) }\n  return result\n}\nexports.buildInputRules = buildInputRules\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-example-setup/dist/index.js\n// module id = 136\n// module chunks = 1","var ref = require(\"prosemirror-commands\");\nvar wrapIn = ref.wrapIn;\nvar setBlockType = ref.setBlockType;\nvar chainCommands = ref.chainCommands;\nvar toggleMark = ref.toggleMark;\nvar exitCode = ref.exitCode;\nvar ref$1 = require(\"prosemirror-schema-table\");\nvar selectNextCell = ref$1.selectNextCell;\nvar selectPreviousCell = ref$1.selectPreviousCell;\nvar ref$2 = require(\"prosemirror-schema-list\");\nvar wrapInList = ref$2.wrapInList;\nvar splitListItem = ref$2.splitListItem;\nvar liftListItem = ref$2.liftListItem;\nvar sinkListItem = ref$2.sinkListItem;\nvar ref$3 = require(\"prosemirror-history\");\nvar undo = ref$3.undo;\nvar redo = ref$3.redo;\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\n// :: (Schema, ?Object) → Object\n// Inspect the given schema looking for marks and nodes from the\n// basic schema, and if found, add key bindings related to them.\n// This will add:\n//\n// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)\n// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)\n// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)\n// * **Ctrl-Shift-0** for making the current textblock a paragraph\n// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current\n//   textblock a heading of the corresponding level\n// * **Ctrl-Shift-Backslash** to make the current textblock a code block\n// * **Ctrl-Shift-8** to wrap the selection in an ordered list\n// * **Ctrl-Shift-9** to wrap the selection in a bullet list\n// * **Ctrl->** to wrap the selection in a block quote\n// * **Enter** to split a non-empty textblock in a list item while at\n//   the same time splitting the list item\n// * **Mod-Enter** to insert a hard break\n// * **Mod-_** to insert a horizontal rule\n//\n// You can suppress or map these bindings by passing a `mapKeys`\n// argument, which maps key names (say `\"Mod-B\"` to either `false`, to\n// remove the binding, or a new key name string.\nfunction buildKeymap(schema, mapKeys) {\n  var keys = {}, type\n  function bind(key, cmd) {\n    if (mapKeys) {\n      var mapped = mapKeys[key]\n      if (mapped === false) { return }\n      if (mapped) { key = mapped }\n    }\n    keys[key] = cmd\n  }\n\n  bind(\"Mod-z\", undo)\n  bind(\"Shift-Mod-z\", redo)\n  if (!mac) { bind(\"Mod-y\", redo) }\n\n  if (type = schema.marks.strong)\n    { bind(\"Mod-b\", toggleMark(type)) }\n  if (type = schema.marks.em)\n    { bind(\"Mod-i\", toggleMark(type)) }\n  if (type = schema.marks.code)\n    { bind(\"Mod-`\", toggleMark(type)) }\n\n  if (type = schema.nodes.bullet_list)\n    { bind(\"Shift-Ctrl-8\", wrapInList(type)) }\n  if (type = schema.nodes.ordered_list)\n    { bind(\"Shift-Ctrl-9\", wrapInList(type)) }\n  if (type = schema.nodes.blockquote)\n    { bind(\"Ctrl->\", wrapIn(type)) }\n  if (type = schema.nodes.hard_break) {\n    var br = type, cmd = chainCommands(exitCode, function (state, dispatch) {\n      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView())\n      return true\n    })\n    bind(\"Mod-Enter\", cmd)\n    bind(\"Shift-Enter\", cmd)\n    if (mac) { bind(\"Ctrl-Enter\", cmd) }\n  }\n  if (type = schema.nodes.list_item) {\n    bind(\"Enter\", splitListItem(type))\n    bind(\"Mod-[\", liftListItem(type))\n    bind(\"Mod-]\", sinkListItem(type))\n  }\n  if (type = schema.nodes.paragraph)\n    { bind(\"Shift-Ctrl-0\", setBlockType(type)) }\n  if (type = schema.nodes.code_block)\n    { bind(\"Shift-Ctrl-\\\\\", setBlockType(type)) }\n  if (type = schema.nodes.heading)\n    { for (var i = 1; i <= 6; i++) { bind(\"Shift-Ctrl-\" + i, setBlockType(type, {level: i})) } }\n  if (type = schema.nodes.horizontal_rule) {\n    var hr = type\n    bind(\"Mod-_\", function (state, dispatch) {\n      dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView())\n      return true\n    })\n  }\n\n  if (schema.nodes.table_row) {\n    bind(\"Tab\", selectNextCell)\n    bind(\"Shift-Tab\", selectPreviousCell)\n  }\n  return keys\n}\nexports.buildKeymap = buildKeymap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-example-setup/dist/keymap.js\n// module id = 137\n// module chunks = 1","var ref = require(\"prosemirror-menu\");\nvar wrapItem = ref.wrapItem;\nvar blockTypeItem = ref.blockTypeItem;\nvar Dropdown = ref.Dropdown;\nvar DropdownSubmenu = ref.DropdownSubmenu;\nvar joinUpItem = ref.joinUpItem;\nvar liftItem = ref.liftItem;\nvar selectParentNodeItem = ref.selectParentNodeItem;\nvar undoItem = ref.undoItem;\nvar redoItem = ref.redoItem;\nvar icons = ref.icons;\nvar MenuItem = ref.MenuItem;\nvar ref$1 = require(\"prosemirror-schema-table\");\nvar createTable = ref$1.createTable;\nvar addColumnBefore = ref$1.addColumnBefore;\nvar addColumnAfter = ref$1.addColumnAfter;\nvar removeColumn = ref$1.removeColumn;\nvar addRowBefore = ref$1.addRowBefore;\nvar addRowAfter = ref$1.addRowAfter;\nvar removeRow = ref$1.removeRow;\nvar ref$2 = require(\"prosemirror-state\");\nvar Selection = ref$2.Selection;\nvar ref$3 = require(\"prosemirror-commands\");\nvar toggleMark = ref$3.toggleMark;\nvar ref$4 = require(\"prosemirror-schema-list\");\nvar wrapInList = ref$4.wrapInList;\nvar ref$5 = require(\"./prompt\");\nvar TextField = ref$5.TextField;\nvar openPrompt = ref$5.openPrompt;\n\n// Helpers to create specific types of items\n\nfunction canInsert(state, nodeType, attrs) {\n  var $from = state.selection.$from\n  for (var d = $from.depth; d >= 0; d--) {\n    var index = $from.index(d)\n    if ($from.node(d).canReplaceWith(index, index, nodeType, attrs)) { return true }\n  }\n  return false\n}\n\nfunction insertImageItem(nodeType) {\n  return new MenuItem({\n    title: \"Insert image\",\n    label: \"Image\",\n    select: function select(state) { return canInsert(state, nodeType) },\n    run: function run(state, _, view) {\n      var ref = state.selection;\n      var node = ref.node;\n      var from = ref.from;\n      var to = ref.to;\n      var attrs = nodeType && node && node.type == nodeType && node.attrs\n      openPrompt({\n        title: \"Insert image\",\n        fields: {\n          src: new TextField({label: \"Location\", required: true, value: attrs && attrs.src}),\n          title: new TextField({label: \"Title\", value: attrs && attrs.title}),\n          alt: new TextField({label: \"Description\",\n                              value: attrs ? attrs.title : state.doc.textBetween(from, to, \" \")})\n        },\n        // FIXME this (and similar uses) won't have the current state\n        // when it runs, leading to problems in, for example, a\n        // collaborative setup\n        callback: function callback(attrs) {\n          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)))\n          view.focus()\n        }\n      })\n    }\n  })\n}\n\nfunction positiveInteger(value) {\n  if (!/^[1-9]\\d*$/.test(value)) { return \"Should be a positive integer\" }\n}\n\nfunction insertTableItem(tableType) {\n  return new MenuItem({\n    title: \"Insert a table\",\n    run: function run(_, _a, view) {\n      openPrompt({\n        title: \"Insert table\",\n        fields: {\n          rows: new TextField({label: \"Rows\", validate: positiveInteger}),\n          cols: new TextField({label: \"Columns\", validate: positiveInteger})\n        },\n        callback: function callback(ref) {\n          var rows = ref.rows;\n          var cols = ref.cols;\n\n          var tr = view.state.tr.replaceSelectionWith(createTable(tableType, +rows, +cols))\n          tr.setSelection(Selection.near(tr.doc.resolve(view.state.selection.from)))\n          view.dispatch(tr.scrollIntoView())\n          view.focus()\n        }\n      })\n    },\n    select: function select(state) {\n      var $from = state.selection.$from\n      for (var d = $from.depth; d >= 0; d--) {\n        var index = $from.index(d)\n        if ($from.node(d).canReplaceWith(index, index, tableType)) { return true }\n      }\n      return false\n    },\n    label: \"Table\"\n  })\n}\n\nfunction cmdItem(cmd, options) {\n  var passedOptions = {\n    label: options.title,\n    run: cmd,\n    select: function select(state) { return cmd(state) }\n  }\n  for (var prop in options) { passedOptions[prop] = options[prop] }\n  return new MenuItem(passedOptions)\n}\n\nfunction markActive(state, type) {\n  var ref = state.selection;\n  var from = ref.from;\n  var $from = ref.$from;\n  var to = ref.to;\n  var empty = ref.empty;\n  if (empty) { return type.isInSet(state.storedMarks || $from.marks()) }\n  else { return state.doc.rangeHasMark(from, to, type) }\n}\n\nfunction markItem(markType, options) {\n  var passedOptions = {\n    active: function active(state) { return markActive(state, markType) }\n  }\n  for (var prop in options) { passedOptions[prop] = options[prop] }\n  return cmdItem(toggleMark(markType), passedOptions)\n}\n\nfunction linkItem(markType) {\n  return markItem(markType, {\n    title: \"Add or remove link\",\n    icon: icons.link,\n    run: function run(state, dispatch, view) {\n      if (markActive(state, markType)) {\n        toggleMark(markType)(state, dispatch)\n        return true\n      }\n      openPrompt({\n        title: \"Create a link\",\n        fields: {\n          href: new TextField({\n            label: \"Link target\",\n            required: true,\n            clean: function (val) {\n              if (!/^https?:\\/\\//i.test(val))\n                { val = 'http://' + val }\n              return val\n            }\n          }),\n          title: new TextField({label: \"Title\"})\n        },\n        callback: function callback(attrs) {\n          toggleMark(markType, attrs)(view.state, view.dispatch)\n          view.focus()\n        }\n      })\n    }\n  })\n}\n\nfunction wrapListItem(nodeType, options) {\n  return cmdItem(wrapInList(nodeType, options.attrs), options)\n}\n\n// :: (Schema) → Object\n// Given a schema, look for default mark and node types in it and\n// return an object with relevant menu items relating to those marks:\n//\n// **`toggleStrong`**`: MenuItem`\n//   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).\n//\n// **`toggleEm`**`: MenuItem`\n//   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).\n//\n// **`toggleCode`**`: MenuItem`\n//   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).\n//\n// **`toggleLink`**`: MenuItem`\n//   : A menu item to toggle the [link mark](#schema-basic.LinkMark).\n//\n// **`insertImage`**`: MenuItem`\n//   : A menu item to insert an [image](#schema-basic.Image).\n//\n// **`wrapBulletList`**`: MenuItem`\n//   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).\n//\n// **`wrapOrderedList`**`: MenuItem`\n//   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).\n//\n// **`wrapBlockQuote`**`: MenuItem`\n//   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).\n//\n// **`makeParagraph`**`: MenuItem`\n//   : A menu item to set the current textblock to be a normal\n//     [paragraph](#schema-basic.Paragraph).\n//\n// **`makeCodeBlock`**`: MenuItem`\n//   : A menu item to set the current textblock to be a\n//     [code block](#schema-basic.CodeBlock).\n//\n// **`insertTable`**`: MenuItem`\n//   : An item to insert a [table](#schema-table).\n//\n// **`addRowBefore`**, **`addRowAfter`**, **`removeRow`**, **`addColumnBefore`**, **`addColumnAfter`**, **`removeColumn`**`: MenuItem`\n//   : Table-manipulation items.\n//\n// **`makeHead[N]`**`: MenuItem`\n//   : Where _N_ is 1 to 6. Menu items to set the current textblock to\n//     be a [heading](#schema-basic.Heading) of level _N_.\n//\n// **`insertHorizontalRule`**`: MenuItem`\n//   : A menu item to insert a horizontal rule.\n//\n// The return value also contains some prefabricated menu elements and\n// menus, that you can use instead of composing your own menu from\n// scratch:\n//\n// **`insertMenu`**`: Dropdown`\n//   : A dropdown containing the `insertImage` and\n//     `insertHorizontalRule` items.\n//\n// **`typeMenu`**`: Dropdown`\n//   : A dropdown containing the items for making the current\n//     textblock a paragraph, code block, or heading.\n//\n// **`fullMenu`**`: [[MenuElement]]`\n//   : An array of arrays of menu elements for use as the full menu\n//     for, for example the [menu bar](#menu.MenuBarEditorView).\nfunction buildMenuItems(schema) {\n  var r = {}, type\n  if (type = schema.marks.strong)\n    { r.toggleStrong = markItem(type, {title: \"Toggle strong style\", icon: icons.strong}) }\n  if (type = schema.marks.em)\n    { r.toggleEm = markItem(type, {title: \"Toggle emphasis\", icon: icons.em}) }\n  if (type = schema.marks.code)\n    { r.toggleCode = markItem(type, {title: \"Toggle code font\", icon: icons.code}) }\n  if (type = schema.marks.link)\n    { r.toggleLink = linkItem(type) }\n\n  if (type = schema.nodes.image)\n    { r.insertImage = insertImageItem(type) }\n  if (type = schema.nodes.bullet_list)\n    { r.wrapBulletList = wrapListItem(type, {\n      title: \"Wrap in bullet list\",\n      icon: icons.bulletList\n    }) }\n  if (type = schema.nodes.ordered_list)\n    { r.wrapOrderedList = wrapListItem(type, {\n      title: \"Wrap in ordered list\",\n      icon: icons.orderedList\n    }) }\n  if (type = schema.nodes.blockquote)\n    { r.wrapBlockQuote = wrapItem(type, {\n      title: \"Wrap in block quote\",\n      icon: icons.blockquote\n    }) }\n  if (type = schema.nodes.paragraph)\n    { r.makeParagraph = blockTypeItem(type, {\n      title: \"Change to paragraph\",\n      label: \"Plain\"\n    }) }\n  if (type = schema.nodes.code_block)\n    { r.makeCodeBlock = blockTypeItem(type, {\n      title: \"Change to code block\",\n      label: \"Code\"\n    }) }\n  if (type = schema.nodes.heading)\n    { for (var i = 1; i <= 10; i++)\n      { r[\"makeHead\" + i] = blockTypeItem(type, {\n        title: \"Change to heading \" + i,\n        label: \"Level \" + i,\n        attrs: {level: i}\n      }) } }\n  if (type = schema.nodes.horizontal_rule) {\n    var hr = type\n    r.insertHorizontalRule = new MenuItem({\n      title: \"Insert horizontal rule\",\n      label: \"Horizontal rule\",\n      select: function select(state) { return canInsert(state, hr) },\n      run: function run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())) }\n    })\n  }\n  if (type = schema.nodes.table)\n    { r.insertTable = insertTableItem(type) }\n  if (type = schema.nodes.table_row) {\n    r.addRowBefore = cmdItem(addRowBefore, {title: \"Add row before\"})\n    r.addRowAfter = cmdItem(addRowAfter, {title: \"Add row after\"})\n    r.removeRow = cmdItem(removeRow, {title: \"Remove row\"})\n    r.addColumnBefore = cmdItem(addColumnBefore, {title: \"Add column before\"})\n    r.addColumnAfter = cmdItem(addColumnAfter, {title: \"Add column after\"})\n    r.removeColumn = cmdItem(removeColumn, {title: \"Remove column\"})\n  }\n\n  var cut = function (arr) { return arr.filter(function (x) { return x; }); }\n  r.insertMenu = new Dropdown(cut([r.insertImage, r.insertHorizontalRule, r.insertTable]), {label: \"Insert\"})\n  r.typeMenu = new Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new DropdownSubmenu(cut([\n    r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6\n  ]), {label: \"Heading\"})]), {label: \"Type...\"})\n  var tableItems = cut([r.addRowBefore, r.addRowAfter, r.removeRow, r.addColumnBefore, r.addColumnAfter, r.removeColumn])\n  if (tableItems.length)\n    { r.tableMenu = new Dropdown(tableItems, {label: \"Table\"}) }\n\n  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink]), [r.insertMenu]]\n  r.blockMenu = [cut([r.typeMenu, r.tableMenu, r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, joinUpItem,\n                      liftItem, selectParentNodeItem])]\n  r.fullMenu = r.inlineMenu.concat(r.blockMenu).concat([[undoItem, redoItem]])\n\n  return r\n}\nexports.buildMenuItems = buildMenuItems\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-example-setup/dist/menu.js\n// module id = 138\n// module chunks = 1","var prefix = \"ProseMirror-prompt\"\n\nfunction openPrompt(options) {\n  var wrapper = document.body.appendChild(document.createElement(\"div\"))\n  wrapper.className = prefix\n\n  var mouseOutside = function (e) { if (!wrapper.contains(e.target)) { close() } }\n  setTimeout(function () { return window.addEventListener(\"mousedown\", mouseOutside); }, 50)\n  var close = function () {\n    window.removeEventListener(\"mousedown\", mouseOutside)\n    if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper) }\n  }\n\n  var domFields = []\n  for (var name in options.fields) { domFields.push(options.fields[name].render()) }\n\n  var submitButton = document.createElement(\"button\")\n  submitButton.type = \"submit\"\n  submitButton.className = prefix + \"-submit\"\n  submitButton.textContent = \"OK\"\n  var cancelButton = document.createElement(\"button\")\n  cancelButton.type = \"button\"\n  cancelButton.className = prefix + \"-cancel\"\n  cancelButton.textContent = \"Cancel\"\n  cancelButton.addEventListener(\"click\", close)\n\n  var form = wrapper.appendChild(document.createElement(\"form\"))\n  if (options.title) { form.appendChild(document.createElement(\"h5\")).textContent = options.title }\n  domFields.forEach(function (field) {\n    form.appendChild(document.createElement(\"div\")).appendChild(field)\n  })\n  var buttons = form.appendChild(document.createElement(\"div\"))\n  buttons.className = prefix + \"-buttons\"\n  buttons.appendChild(submitButton)\n  buttons.appendChild(document.createTextNode(\" \"))\n  buttons.appendChild(cancelButton)\n\n  var box = wrapper.getBoundingClientRect()\n  wrapper.style.top = ((window.innerHeight - box.height) / 2) + \"px\"\n  wrapper.style.left = ((window.innerWidth - box.width) / 2) + \"px\"\n\n  var submit = function () {\n    var params = getValues(options.fields, domFields)\n    if (params) {\n      close()\n      options.callback(params)\n    }\n  }\n\n  form.addEventListener(\"submit\", function (e) {\n    e.preventDefault()\n    submit()\n  })\n\n  form.addEventListener(\"keydown\", function (e) {\n    if (e.keyCode == 27) {\n      e.preventDefault()\n      close()\n    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {\n      e.preventDefault()\n      submit()\n    } else if (e.keyCode == 9) {\n      window.setTimeout(function () {\n        if (!wrapper.contains(document.activeElement)) { close() }\n      }, 500)\n    }\n  })\n\n  var input = form.elements[0]\n  if (input) { input.focus() }\n}\nexports.openPrompt = openPrompt\n\nfunction getValues(fields, domFields) {\n  var result = Object.create(null), i = 0\n  for (var name in fields) {\n    var field = fields[name], dom = domFields[i++]\n    var value = field.read(dom), bad = field.validate(value)\n    if (bad) {\n      reportInvalid(dom, bad)\n      return null\n    }\n    result[name] = field.clean(value)\n  }\n  return result\n}\n\nfunction reportInvalid(dom, message) {\n  // FIXME this is awful and needs a lot more work\n  var parent = dom.parentNode\n  var msg = parent.appendChild(document.createElement(\"div\"))\n  msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + \"px\"\n  msg.style.top = (dom.offsetTop - 5) + \"px\"\n  msg.className = \"ProseMirror-invalid\"\n  msg.textContent = message\n  setTimeout(function () { return parent.removeChild(msg); }, 1500)\n}\n\n// ::- The type of field that `FieldPrompt` expects to be passed to it.\nvar Field = function Field(options) { this.options = options };\n\n// render:: (state: EditorState, props: Object) → dom.Node\n// Render the field to the DOM. Should be implemented by all subclasses.\n\n// :: (dom.Node) → any\n// Read the field's value from its DOM node.\nField.prototype.read = function read (dom) { return dom.value };\n\n// :: (any) → ?string\n// A field-type-specific validation function.\nField.prototype.validateType = function validateType (_value) {};\n\nField.prototype.validate = function validate (value) {\n  if (!value && this.options.required)\n    { return \"Required field\" }\n  return this.validateType(value) || (this.options.validate && this.options.validate(value))\n};\n\nField.prototype.clean = function clean (value) {\n  return this.options.clean ? this.options.clean(value) : value\n};\nexports.Field = Field\n\n// ::- A field class for single-line text fields.\nvar TextField = (function (Field) {\n  function TextField () {\n    Field.apply(this, arguments);\n  }\n\n  if ( Field ) TextField.__proto__ = Field;\n  TextField.prototype = Object.create( Field && Field.prototype );\n  TextField.prototype.constructor = TextField;\n\n  TextField.prototype.render = function render () {\n    var input = document.createElement(\"input\")\n    input.type = \"text\"\n    input.placeholder = this.options.label\n    input.value = this.options.value || \"\"\n    input.autocomplete = \"off\"\n    return input\n  };\n\n  return TextField;\n}(Field));\nexports.TextField = TextField\n\n\n// ::- A field class for dropdown fields based on a plain `<select>`\n// tag. Expects an option `options`, which should be an array of\n// `{value: string, label: string}` objects, or a function taking a\n// `ProseMirror` instance and returning such an array.\nvar SelectField = (function (Field) {\n  function SelectField () {\n    Field.apply(this, arguments);\n  }\n\n  if ( Field ) SelectField.__proto__ = Field;\n  SelectField.prototype = Object.create( Field && Field.prototype );\n  SelectField.prototype.constructor = SelectField;\n\n  SelectField.prototype.render = function render () {\n    var this$1 = this;\n\n    var select = document.createElement(\"select\")\n    this.options.options.forEach(function (o) {\n      var opt = select.appendChild(document.createElement(\"option\"))\n      opt.value = o.value\n      opt.selected = o.value == this$1.options.value\n      opt.label = o.label\n    })\n    return select\n  };\n\n  return SelectField;\n}(Field));\nexports.SelectField = SelectField\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-example-setup/dist/prompt.js\n// module id = 139\n// module chunks = 1","var ref = require(\"./inputrules\");\nvar InputRule = ref.InputRule;\n\n// :: InputRule Converts double dashes to an emdash.\nvar emDash = new InputRule(/--$/, \"—\")\nexports.emDash = emDash\n// :: InputRule Converts three dots to an ellipsis character.\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\nexports.ellipsis = ellipsis\n// :: InputRule “Smart” opening double quotes.\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\nexports.openDoubleQuote = openDoubleQuote\n// :: InputRule “Smart” closing double quotes.\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\")\nexports.closeDoubleQuote = closeDoubleQuote\n// :: InputRule “Smart” opening single quotes.\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\nexports.openSingleQuote = openSingleQuote\n// :: InputRule “Smart” closing single quotes.\nvar closeSingleQuote = new InputRule(/'$/, \"’\")\nexports.closeSingleQuote = closeSingleQuote\n\n// :: [InputRule] Smart-quote related input rules.\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\nexports.smartQuotes = smartQuotes\n\n// :: [InputRule] All schema-independent input rules defined in this module.\nvar allInputRules = [emDash, ellipsis].concat(smartQuotes)\nexports.allInputRules = allInputRules\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-inputrules/dist/rules.js\n// module id = 140\n// module chunks = 1","var ref = require(\"./inputrules\");\nvar InputRule = ref.InputRule;\nvar ref$1 = require(\"prosemirror-transform\");\nvar findWrapping = ref$1.findWrapping;\nvar canJoin = ref$1.canJoin;\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    var tr = state.tr.delete(start, end)\n    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) { return null }\n    tr.wrap(range, wrapping)\n    var before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      { tr.join(start - 1) }\n    return tr\n  })\n}\nexports.wrappingInputRule = wrappingInputRule\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start)\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType, attrs)) { return null }\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\nexports.textblockTypeInputRule = textblockTypeInputRule\n\n\n// :: (NodeType) → InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\nfunction blockQuoteRule(nodeType) {\n  return wrappingInputRule(/^\\s*> $/, nodeType)\n}\nexports.blockQuoteRule = blockQuoteRule\n\n// :: (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\nfunction orderedListRule(nodeType) {\n  return wrappingInputRule(/^(\\d+)\\. $/, nodeType, function (match) { return ({order: +match[1]}); },\n                           function (match, node) { return node.childCount + node.attrs.order == +match[1]; })\n}\nexports.orderedListRule = orderedListRule\n\n// :: (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\nfunction bulletListRule(nodeType) {\n  return wrappingInputRule(/^\\s*([-+*]) $/, nodeType)\n}\nexports.bulletListRule = bulletListRule\n\n// :: (NodeType) → InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\nfunction codeBlockRule(nodeType) {\n  return textblockTypeInputRule(/^```$/, nodeType)\n}\nexports.codeBlockRule = codeBlockRule\n\n// :: (NodeType, number) → InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\nfunction headingRule(nodeType, maxLevel) {\n  return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"}) $\"),\n                                nodeType, function (match) { return ({level: match[1].length}); })\n}\nexports.headingRule = headingRule\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-inputrules/dist/util.js\n// module id = 141\n// module chunks = 1","var keyName = require(\"w3c-keyname\")\nvar ref = require(\"prosemirror-state\");\nvar Plugin = ref.Plugin;\n\n// declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") { result = \" \" }\n  var alt, ctrl, shift, meta\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true }\n    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true } }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { result = \"Alt-\" + result }\n  if (ctrl) { result = \"Ctrl-\" + result }\n  if (meta) { result = \"Meta-\" + result }\n  if (shift) { result = \"Shift-\" + result }\n  return result\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null)\n  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop] }\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) { name = \"Alt-\" + name }\n  if (event.ctrlKey) { name = \"Ctrl-\" + name }\n  if (event.metaKey) { name = \"Meta-\" + name }\n  if (shift !== false && event.shiftKey) { name = \"Shift-\" + name }\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`, a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nfunction keymap(bindings) {\n  var map = normalize(bindings)\n\n  return new Plugin({\n    props: {\n      handleKeyDown: function handleKeyDown(view, event) {\n        var name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n        var direct = map[modifiers(name, event, !isChar)]\n        if (direct && direct(view.state, view.dispatch, view)) { return true }\n        if (event.shiftKey && isChar && (baseName = keyName.base[event.keyCode])) {\n          var withShift = map[modifiers(baseName, event, true)]\n          if (withShift && withShift(view.state, view.dispatch, view)) { return true }\n        }\n        return false\n      }\n    }\n  })\n}\nexports.keymap = keymap\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-keymap/dist/keymap.js\n// module id = 142\n// module chunks = 1","var SVG = \"http://www.w3.org/2000/svg\"\nvar XLINK = \"http://www.w3.org/1999/xlink\"\n\nvar prefix = \"ProseMirror-icon\"\n\nfunction hashPath(path) {\n  var hash = 0\n  for (var i = 0; i < path.length; i++)\n    { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0 }\n  return hash\n}\n\nfunction getIcon(icon) {\n  var node = document.createElement(\"div\")\n  node.className = prefix\n  if (icon.path) {\n    var name = \"pm-icon-\" + hashPath(icon.path).toString(16)\n    if (!document.getElementById(name)) { buildSVG(name, icon) }\n    var svg = node.appendChild(document.createElementNS(SVG, \"svg\"))\n    svg.style.width = (icon.width / icon.height) + \"em\"\n    var use = svg.appendChild(document.createElementNS(SVG, \"use\"))\n    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#\" + name)\n  } else if (icon.dom) {\n    node.appendChild(icon.dom.cloneNode(true))\n  } else {\n    node.appendChild(document.createElement(\"span\")).textContent = icon.text || ''\n    if (icon.css) { node.firstChild.style.cssText = icon.css }\n  }\n  return node\n}\nexports.getIcon = getIcon\n\nfunction buildSVG(name, data) {\n  var collection = document.getElementById(prefix + \"-collection\")\n  if (!collection) {\n    collection = document.createElementNS(SVG, \"svg\")\n    collection.id = prefix + \"-collection\"\n    collection.style.display = \"none\"\n    document.body.insertBefore(collection, document.body.firstChild)\n  }\n  var sym = document.createElementNS(SVG, \"symbol\")\n  sym.id = name\n  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height)\n  var path = sym.appendChild(document.createElementNS(SVG, \"path\"))\n  path.setAttribute(\"d\", data.path)\n  collection.appendChild(sym)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-menu/dist/icons.js\n// module id = 143\n// module chunks = 1",";var assign;\n((assign = require(\"./menu\"), exports.MenuItem = assign.MenuItem, exports.Dropdown = assign.Dropdown, exports.DropdownSubmenu = assign.DropdownSubmenu, exports.renderGrouped = assign.renderGrouped, exports.icons = assign.icons, exports.joinUpItem = assign.joinUpItem, exports.liftItem = assign.liftItem, exports.selectParentNodeItem = assign.selectParentNodeItem, exports.undoItem = assign.undoItem, exports.redoItem = assign.redoItem, exports.wrapItem = assign.wrapItem, exports.blockTypeItem = assign.blockTypeItem))\nexports.MenuBarEditorView = require(\"./menubar\").MenuBarEditorView\n\n// !! This module defines a number of building blocks for ProseMirror\n// menus, along with a [menu bar](#menu.MenuBarEditorView) implementation.\n\n// MenuElement:: interface\n// The types defined in this module aren't the only thing you can\n// display in your menu. Anything that conforms to this interface can\n// be put into a menu structure.\n//\n//   render:: (pm: ProseMirror) → ?dom.Node\n//   Render the element for display in the menu. Returning `null` can be\n//   used to signal that this element shouldn't be displayed for the\n//   given editor state.\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-menu/dist/index.js\n// module id = 144\n// module chunks = 1","var crel = require(\"crel\")\nvar ref = require(\"prosemirror-view\");\nvar EditorView = ref.EditorView;\n\nvar ref$1 = require(\"./menu\");\nvar renderGrouped = ref$1.renderGrouped;\n\nvar prefix = \"ProseMirror-menubar\"\n\n// ::- A wrapper around\n// [`EditorView`](http://prosemirror.net/ref.html#view.EditorView)\n// that adds a menubar above the editor.\n//\n// Supports the following additional props:\n//\n// - **`floatingMenu`**`: ?bool` determines whether the menu floats,\n//   i.e. whether it sticks to the top of the viewport when the editor\n//   is partially scrolled out of view.\n//\n// - **`menuContent`**`: [[MenuElement]]` provides the content of the\n//   menu, as a nested array to be passed to `renderGrouped`.\nvar MenuBarEditorView = function MenuBarEditorView(place, props) {\n  var this$1 = this;\n\n  // :: dom.Node The wrapping DOM element around the editor and the\n  // menu. Will get the CSS class `ProseMirror-menubar-wrapper`.\n  this.wrapper = crel(\"div\", {class: prefix + \"-wrapper\"})\n  if (place && place.appendChild) { place.appendChild(this.wrapper) }\n  else if (place) { place(this.wrapper) }\n  if (!props.dispatchTransaction)\n    { props.dispatchTransaction = function (tr) { return this$1.updateState(this$1.editor.state.apply(tr)); } }\n  // :: EditorView The wrapped editor view. _Don't_ directly call\n  // `update` or `updateState` on this, always go through the\n  // wrapping view.\n  this.editor = new EditorView(this.wrapper, props)\n\n  this.menu = crel(\"div\", {class: prefix})\n  this.menu.className = prefix\n  this.spacer = null\n\n  this.wrapper.insertBefore(this.menu, this.wrapper.firstChild)\n\n  this.maxHeight = 0\n  this.widthForMaxHeight = 0\n  this.floating = false\n\n  // :: EditorProps The current props of this view.\n  this.props = props\n  this.updateMenu()\n\n  if (this.editor.someProp(\"floatingMenu\")) {\n    this.updateFloat()\n    this.scrollFunc = function () {\n      if (!this$1.editor.root.contains(this$1.wrapper))\n        { window.removeEventListener(\"scroll\", this$1.scrollFunc) }\n      else\n        { this$1.updateFloat() }\n    }\n    window.addEventListener(\"scroll\", this.scrollFunc)\n  }\n};\n\n// :: (EditorProps) Update the view's props.\nMenuBarEditorView.prototype.update = function update (props) {\n  this.props = props\n  this.editor.update(props)\n  this.updateMenu()\n};\n\n// :: (EditorState) Update only the state of the editor.\nMenuBarEditorView.prototype.updateState = function updateState (state) {\n  this.editor.updateState(state)\n  this.updateMenu()\n};\n\nMenuBarEditorView.prototype.updateMenu = function updateMenu () {\n  this.menu.textContent = \"\"\n  this.menu.appendChild(renderGrouped(this.editor, this.editor.someProp(\"menuContent\")))\n\n  if (this.floating) {\n    this.updateScrollCursor()\n  } else {\n    if (this.menu.offsetWidth != this.widthForMaxHeight) {\n      this.widthForMaxHeight = this.menu.offsetWidth\n      this.maxHeight = 0\n    }\n    if (this.menu.offsetHeight > this.maxHeight) {\n      this.maxHeight = this.menu.offsetHeight\n      this.menu.style.minHeight = this.maxHeight + \"px\"\n    }\n  }\n};\n\n\nMenuBarEditorView.prototype.updateScrollCursor = function updateScrollCursor () {\n  var selection = this.editor.root.getSelection()\n  if (!selection.focusNode) { return }\n  var rects = selection.getRangeAt(0).getClientRects()\n  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1]\n  if (!selRect) { return }\n  var menuRect = this.menu.getBoundingClientRect()\n  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {\n    var scrollable = findWrappingScrollable(this.wrapper)\n    if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top) }\n  }\n};\n\nMenuBarEditorView.prototype.updateFloat = function updateFloat () {\n  var parent = this.wrapper, editorRect = parent.getBoundingClientRect()\n  if (this.floating) {\n    if (editorRect.top >= 0 || editorRect.bottom < this.menu.offsetHeight + 10) {\n      this.floating = false\n      this.menu.style.position = this.menu.style.left = this.menu.style.width = \"\"\n      this.menu.style.display = \"\"\n      this.spacer.parentNode.removeChild(this.spacer)\n      this.spacer = null\n    } else {\n      var border = (parent.offsetWidth - parent.clientWidth) / 2\n      this.menu.style.left = (editorRect.left + border) + \"px\"\n      this.menu.style.display = (editorRect.top > window.innerHeight ? \"none\" : \"\")\n    }\n  } else {\n    if (editorRect.top < 0 && editorRect.bottom >= this.menu.offsetHeight + 10) {\n      this.floating = true\n      var menuRect = this.menu.getBoundingClientRect()\n      this.menu.style.left = menuRect.left + \"px\"\n      this.menu.style.width = menuRect.width + \"px\"\n      this.menu.style.position = \"fixed\"\n      this.spacer = crel(\"div\", {class: prefix + \"-spacer\", style: (\"height: \" + (menuRect.height) + \"px\")})\n      parent.insertBefore(this.spacer, this.menu)\n    }\n  }\n};\n\n// :: ()\n// Destroy the editor instance.\nMenuBarEditorView.prototype.destroy = function destroy () {\n  this.editor.destroy()\n};\nexports.MenuBarEditorView = MenuBarEditorView\n\n// Not precise, but close enough\nfunction selectionIsInverted(selection) {\n  if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }\n  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING\n}\n\nfunction findWrappingScrollable(node) {\n  for (var cur = node.parentNode; cur; cur = cur.parentNode)\n    { if (cur.scrollHeight > cur.clientHeight) { return cur } }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-menu/dist/menubar.js\n// module id = 145\n// module chunks = 1","function findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++ }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize\n  }\n}\nexports.findDiffStart = findDiffStart\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size\n  }\n}\nexports.findDiffEnd = findDiffEnd\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/diff.js\n// module id = 146\n// module chunks = 1","var ref = require(\"./fragment\");\nvar Fragment = ref.Fragment;\nvar ref$1 = require(\"./replace\");\nvar Slice = ref$1.Slice;\nvar ref$2 = require(\"./mark\");\nvar Mark = ref$2.Mark;\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<bool, Object>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?string\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element.\n//\n//   getContent:: ?(dom.Node) → Fragment\n//   Can be used to override the content of a matched node. Will be\n//   called, and its result used, instead of parsing the node's child\n//   node.\n//\n//   preserveWhitespace:: ?bool\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  this.schema = schema\n  // :: [ParseRule]\n  this.rules = rules\n  this.tags = []\n  this.styles = []\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule) }\n    else if (rule.style) { this$1.styles.push(rule) }\n  })\n};\n\n// :: (dom.Node, ?Object) → Node\n// Parse a document from the content of a DOM node.\n//\n// options::- Configuration options.\n//\n//   preserveWhitespace:: ?bool\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   true here to prevent the parser from doing that.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into a `doc` node. You can\n//   pass this option to use the type and attributes from a\n//   different node as the top container.\n//\n//   topStart:: ?number\n//   Can be used to influence the content match at the start of\n//   the topnode. When given, should be a valid index into\n//   `topNode`.\nDOMParser.prototype.parse = function (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false)\n  context.addAll(dom, null, options.from, options.to)\n  return context.finish()\n};\n\n// :: (dom.Node, ?Object) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true)\n  context.addAll(dom, null, options.from, options.to)\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function (dom) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.tags.length; i++) {\n    var rule = this$1.tags[i]\n    if (matches(dom, rule.tag)) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom)\n        if (result === false) { continue }\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function (prop, value) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.styles.length; i++) {\n    var rule = this$1.styles[i]\n    if (rule.style == prop) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(value)\n        if (result === false) { continue }\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n};\n\n// :: (Schema) → [ParseRule]\n// Extract the parse rules listed in a schema's [node\n// specs](#model.NodeSpec.parseDOM).\nDOMParser.schemaRules = function (schema) {\n  var result = []\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule)\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule))\n      rule.mark = name\n    }) }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule))\n      rule.node = name$1\n    }) }\n  };\n\n    for (var name$1 in schema.nodes) loop$1( name );\n  return result\n};\n\n// :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM).\nDOMParser.fromSchema = function (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\nexports.DOMParser = DOMParser\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_OPEN_LEFT = 2\n\nvar NodeContext = function(type, attrs, solid, match, options) {\n  this.type = type\n  this.attrs = attrs\n  this.solid = solid\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentExpr.start(attrs))\n  this.options = options\n  this.content = []\n};\n\nNodeContext.prototype.findWrapping = function (type, attrs) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var found = this.type.contentExpr.atType(this.attrs, type, attrs)\n    if (!found) {\n      var start = this.type.contentExpr.start(this.attrs), wrap\n      if (wrap = start.findWrapping(type, attrs)) {\n        this.match = start\n        return wrap\n      }\n    }\n    if (found) { this.match = found }\n    else { return null }\n  }\n  return this.match.findWrapping(type, attrs)\n};\n\nNodeContext.prototype.finish = function (openRight) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m\n    if (last && last.isText && (m = /\\s+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop() }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)) }\n    }\n  }\n  var content = Fragment.from(this.content)\n  if (!openRight && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)) }\n  return this.type ? this.type.create(this.attrs, content) : content\n};\n\nvar ParseContext = function(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser\n  // : Object The options passed to this parse.\n  this.options = options\n  this.isOpen = open\n  var topNode = options.topNode, topContext\n  var topOptions = (options.preserveWhitespace ? OPT_PRESERVE_WS : 0) | (open ? OPT_OPEN_LEFT : 0)\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, true,\n                                 topNode.contentMatchAt(options.topStart || 0), topOptions) }\n  else if (open)\n    { topContext = new NodeContext(null, null, true, null, topOptions) }\n  else\n    { topContext = new NodeContext(parser.schema.nodes.doc, null, true, null, topOptions) }\n  this.nodes = [topContext]\n  // : [Mark] The current set of marks\n  this.marks = Mark.none\n  this.open = 0\n  this.find = options.findPositions\n};\n\nvar prototypeAccessors = { top: {},currentPos: {} };\n\nprototypeAccessors.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (Mark) → [Mark]\n// Add a mark to the current set of marks, return the old set.\nParseContext.prototype.addMark = function (mark) {\n  var old = this.marks\n  this.marks = mark.addToSet(this.marks)\n  return old\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom)\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\")\n    if (style) { this.addElementWithStyles(parseStyles(style), dom) }\n    else { this.addElement(dom) }\n  }\n};\n\nParseContext.prototype.addTextNode = function (dom) {\n  var value = dom.nodeValue\n  var top = this.top\n  if ((top.type && top.type.isTextblock) || /\\S/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/\\s+/g, \" \")\n      // If this starts with whitespace, and there is either no node\n      // before it or a node that ends with whitespace, strip the\n      // leading space.\n      if (/^\\s/.test(value)) {\n        var nodeBefore = top.content[top.content.length - 1]\n        if (!nodeBefore || nodeBefore.isText && /\\s$/.test(nodeBefore.text))\n          { value = value.slice(1) }\n      }\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value, this.marks)) }\n    this.findInText(dom)\n  } else {\n    this.findInside(dom)\n  }\n};\n\n// : (dom.Element)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function (dom) {\n  var name = dom.nodeName.toLowerCase()\n  if (listTags.hasOwnProperty(name)) { normalizeList(dom) }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom)\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom)\n  } else if (!rule || rule.skip) {\n    if (rule && rule.skip.nodeType) { dom = rule.skip }\n    var sync = blockTags.hasOwnProperty(name) && this.top\n    this.addAll(dom)\n    if (sync) { this.sync(sync) }\n  } else {\n    this.addElementByRule(dom, rule)\n  }\n};\n\n// Run any style parser associated with the node's styles. After\n// that, if no style parser suppressed the node's content, pass it\n// through to `addElement`.\nParseContext.prototype.addElementWithStyles = function (styles, dom) {\n    var this$1 = this;\n\n  var oldMarks = this.marks, ignore = false\n  for (var i = 0; i < styles.length; i += 2) {\n    var rule = this$1.parser.matchStyle(styles[i], styles[i + 1])\n    if (!rule) { continue }\n    if (rule.ignore) { ignore = true; break }\n    this$1.addMark(this$1.parser.schema.marks[rule.mark].create(rule.attrs))\n  }\n  if (!ignore) { this.addElement(dom) }\n  this.marks = oldMarks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function (dom, rule) {\n    var this$1 = this;\n\n  var sync, before, nodeType, markType, mark\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node]\n    if (nodeType.isLeaf) { this.insertNode(nodeType.create(rule.attrs, null, this.marks)) }\n    else { sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace) && this.top }\n  } else {\n    markType = this.parser.schema.marks[rule.mark]\n    before = this.addMark(mark = markType.create(rule.attrs))\n  }\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom)\n  } else if (rule.getContent) {\n    this.findInside(dom)\n    rule.getContent(dom).forEach(function (node) { return this$1.insertNode(mark ? node.mark(mark.addToSet(node.marks)) : node); })\n  } else {\n    var contentDOM = rule.contentElement\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM) }\n    if (!contentDOM) { contentDOM = dom }\n    this.findAround(dom, contentDOM, true)\n    this.addAll(contentDOM, sync)\n    if (sync) { this.sync(sync); this.open-- }\n    else if (before) { this.marks = before }\n    this.findAround(dom, contentDOM, true)\n  }\n  return true\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function (parent, sync, startIndex, endIndex) {\n    var this$1 = this;\n\n  var index = startIndex || 0\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this$1.findAtPoint(parent, index)\n    this$1.addDOM(dom)\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this$1.sync(sync) }\n  }\n  this.findAtPoint(parent, index)\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function (type, attrs) {\n    var this$1 = this;\n\n  var route, sync\n  for (var depth = this.open; depth >= 0; depth--) {\n    var node = this$1.nodes[depth]\n    var found = node.findWrapping(type, attrs)\n    if (found && (!route || route.length > found.length)) {\n      route = found\n      sync = node\n      if (!found.length) { break }\n    }\n    if (node.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync)\n  for (var i = 0; i < route.length; i++)\n    { this$1.enterInner(route[i].type, route[i].attrs, false) }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function (node) {\n  if (this.findPlace(node.type, node.attrs)) {\n    this.closeExtra()\n    var top = this.top\n    if (top.match) {\n      var match = top.match.matchNode(node)\n      if (!match) {\n        node = node.mark(node.marks.filter(function (mark) { return top.match.allowsMark(mark.type); }))\n        match = top.match.matchNode(node)\n      }\n      top.match = match\n    }\n    top.content.push(node)\n  }\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function (type, attrs, preserveWS) {\n  var ok = this.findPlace(type, attrs)\n  if (ok) { this.enterInner(type, attrs, true, preserveWS) }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function (type, attrs, solid, preserveWS) {\n  this.closeExtra()\n  var top = this.top\n  top.match = top.match && top.match.matchType(type, attrs)\n  var options = preserveWS == null ? top.options & OPT_PRESERVE_WS : preserveWS ? OPT_PRESERVE_WS : 0\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT }\n  this.nodes.push(new NodeContext(type, attrs, solid, null, options))\n  this.open++\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function (openRight) {\n    var this$1 = this;\n\n  var i = this.nodes.length - 1\n  if (i > this.open) {\n    this.marks = Mark.none\n    for (; i > this.open; i--) { this$1.nodes[i - 1].content.push(this$1.nodes[i].finish(openRight)) }\n    this.nodes.length = this.open + 1\n  }\n};\n\nParseContext.prototype.finish = function () {\n  this.open = 0\n  this.closeExtra(this.isOpen)\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function (to) {\n    var this$1 = this;\n\n  for (var i = this.open; i >= 0; i--) { if (this$1.nodes[i] == to) {\n    this$1.open = i\n    return\n  } }\n};\n\nprototypeAccessors.currentPos.get = function () {\n    var this$1 = this;\n\n  this.closeExtra()\n  var pos = 0\n  for (var i = this.open; i >= 0; i--) {\n    var content = this$1.nodes[i].content\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize }\n    if (i) { pos++ }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function (parent, offset) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].node == parent && this$1.find[i].offset == offset)\n      { this$1.find[i].pos = this$1.currentPos }\n  } }\n};\n\nParseContext.prototype.findInside = function (parent) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].pos == null && parent.contains(this$1.find[i].node))\n      { this$1.find[i].pos = this$1.currentPos }\n  } }\n};\n\nParseContext.prototype.findAround = function (parent, content, before) {\n    var this$1 = this;\n\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].pos == null && parent.contains(this$1.find[i].node)) {\n      var pos = content.compareDocumentPosition(this$1.find[i].node)\n      if (pos & (before ? 2 : 4))\n        { this$1.find[i].pos = this$1.currentPos }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function (textNode) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].node == textNode)\n      { this$1.find[i].pos = this$1.currentPos - (textNode.nodeValue.length - this$1.find[i].offset) }\n  } }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()) }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {}\n  for (var prop in obj) { copy[prop] = obj[prop] }\n  return copy\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/from_dom.js\n// module id = 147\n// module chunks = 1","var OrderedMap = require(\"orderedmap\")\n\nvar ref = require(\"./node\");\nvar Node = ref.Node;\nvar TextNode = ref.TextNode;\nvar ref$1 = require(\"./fragment\");\nvar Fragment = ref$1.Fragment;\nvar ref$2 = require(\"./mark\");\nvar Mark = ref$2.Mark;\nvar ref$3 = require(\"./content\");\nvar ContentExpr = ref$3.ContentExpr;\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null)\n  for (var attrName in attrs) {\n    var attr = attrs[attrName]\n    if (attr.default === undefined) { return null }\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null)\n  for (var name in attrs) {\n    var given = value && value[name]\n    if (given == null) {\n      var attr = attrs[name]\n      if (attr.default !== undefined)\n        { given = attr.default }\n      else if (attr.compute)\n        { given = attr.compute() }\n      else\n        { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null)\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]) } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// tag `Node` instances with a type. They contain information about\n// the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec\n\n  this.attrs = initAttrs(spec.attrs)\n\n  this.defaultAttrs = defaultAttrs(this.attrs)\n  this.contentExpr = null\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\")\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\"\n};\n\nvar prototypeAccessors = { isInline: {},isTextblock: {},isLeaf: {} };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors.isTextblock.get = function () { return this.isBlock && this.contentExpr.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors.isLeaf.get = function () { return this.contentExpr.isLeaf };\n\nNodeType.prototype.hasRequiredAttrs = function (ignore) {\n    var this$1 = this;\n\n  for (var n in this$1.attrs)\n    { if (this$1.attrs[n].isRequired && (!ignore || !(n in ignore))) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function (other) {\n  return this == other || this.contentExpr.compatible(other.contentExpr)\n};\n\nNodeType.prototype.computeAttrs = function (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function (attrs, content, marks) {\n  if (typeof content == \"string\") { throw new Error(\"Calling create with string\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs)\n  content = Fragment.from(content)\n  if (!this.validContent(content, attrs))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, attrs, content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs)\n  content = Fragment.from(content)\n  if (content.size) {\n    var before = this.contentExpr.start(attrs).fillBefore(content)\n    if (!before) { return null }\n    content = before.append(content)\n  }\n  var after = this.contentExpr.getMatchAt(attrs, content).fillBefore(Fragment.empty, true)\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment, ?Object) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function (content, attrs) {\n  return this.contentExpr.matches(attrs, content)\n};\n\nNodeType.compile = function (nodes, schema) {\n  var result = Object.create(null)\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); })\n\n  if (!result.doc) { throw new RangeError(\"Every schema needs a 'doc' type\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors );\nexports.NodeType = NodeType\n\n// Attribute descriptors\n\nvar Attribute = function(options) {\n  this.default = options.default\n  this.compute = options.compute\n};\n\nvar prototypeAccessors$1 = { isRequired: {} };\n\nprototypeAccessors$1.isRequired.get = function () {\n  return this.default === undefined && !this.compute\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are tagged with type\n// objects, which are instantiated once per `Schema`.\nvar MarkType = function(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec\n\n  this.attrs = initAttrs(spec.attrs)\n\n  this.rank = rank\n  var defaults = defaultAttrs(this.attrs)\n  this.instance = defaults && new Mark(this, defaults)\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function (marks, schema) {\n  var result = Object.create(null), rank = 0\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); })\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this$1)\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this$1) { return set[i] } }\n};\nexports.MarkType = MarkType\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the `Schema`\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to `NodeSpec` objects\n//   describing the node to be associated with that name. Their order\n//   is significant\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](guide/schema.html). When not given, the node does not allow\n//   any content.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs, as\n//   referred to in the content expressions for the schema.\n//\n//   inline:: ?bool\n//   Should be set to a truthy value for inline nodes. (Implied for\n//   text nodes.)\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected (as a [node\n//   selection](#state.NodeSelection)). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged. Enabling it\n//   causes ProseMirror to set a `draggable` attribute on its DOM\n//   representation, and to put its HTML serialization into the drag\n//   event's [data\n//   transfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)\n//   when dragged. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, the the _inserted_ content, when not inserting into a\n//   textblock, the defining parents of the content are preserved.\n//   Typically, non-default-paragraph textblock types, and possible\n//   list items, are marked as defining.\n//\n//   toDOM:: ?(Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema).\n//   Should return an [array structure](#model.DOMOutputSpec) that\n//   describes the resulting DOM structure, with an optional number\n//   zero (“hole”) in it to indicate where the node's content should\n//   be inserted.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusiveRight:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at the end of the mark. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to define attributes. Attributes that have no default or\n// compute property must be provided whenever a node or mark of a type\n// that has them is created.\n//\n// The following fields are supported:\n//\n//   default:: ?any\n//   The default value for this attribute, to choose when no\n//   explicit value is provided.\n//\n//   compute:: ?() → any\n//   A function that computes a default value for the attribute.\n\n// ::- A document schema.\nvar Schema = function(spec) {\n  var this$1 = this;\n\n  // :: OrderedMap<NodeSpec> The node specs that the schema is based on.\n  this.nodeSpec = OrderedMap.from(spec.nodes)\n  // :: OrderedMap<MarkSpec> The mark spec that the schema is based on.\n  this.markSpec = OrderedMap.from(spec.marks)\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.nodeSpec, this)\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.markSpec, this)\n\n  for (var prop in this$1.nodes) {\n    if (prop in this$1.marks)\n      { throw new RangeError(prop + \" can not be both a node and a mark\") }\n    var type = this$1.nodes[prop]\n    type.contentExpr = ContentExpr.parse(type, this$1.nodeSpec.get(prop).content || \"\", this$1.nodeSpec)\n  }\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null)\n  this.cached.wrappings = Object.create(null)\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this)\n  this.markFromJSON = this.markFromJSON.bind(this)\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type) }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function (text$1, marks) {\n  var type = this.nodes.text\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type] }\n  return type.create(attrs)\n};\n\n// :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function (name) {\n  var found = this.nodes[name]\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\nexports.Schema = Schema\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/schema.js\n// module id = 148\n// module chunks = 1","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, or an array.\n//\n// An array describes a DOM element. The first element in the array\n// should be a string, and is the name of the DOM element. If the\n// second element is a non-Array, non-DOM node object, it is\n// interpreted as an object providing the DOM element's attributes.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a ProseMirror node's content should be inserted.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  this.nodes = nodes || {}\n  // :: Object<(mark: Mark) → DOMOutputSpec>\n  this.marks = marks || {}\n};\n\n// :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serialize can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment() }\n\n  var top = target, active = null\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = [] }\n      var keep = 0\n      for (; keep < Math.min(active.length, node.marks.length); ++keep)\n        { if (!node.marks[keep].eq(active[keep])) { break } }\n      while (keep < active.length) {\n        active.pop()\n        top = top.parentNode\n      }\n      while (active.length < node.marks.length) {\n        var add = node.marks[active.length]\n        active.push(add)\n        top = top.appendChild(this$1.serializeMark(add, options))\n      }\n    }\n    top.appendChild(this$1.serializeNode(node, options))\n  })\n\n  return target\n};\n\n// :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [`content`](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function (node, options) {\n    if ( options === void 0 ) options = {};\n\n  return this.renderStructure(this.nodes[node.type.name](node), node, options)\n};\n\nDOMSerializer.prototype.serializeNodeAndMarks = function (node, options) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNode(node, options)\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this$1.serializeMark(node.marks[i], options)\n    wrap.appendChild(dom)\n    dom = wrap\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function (mark, options) {\n    if ( options === void 0 ) options = {};\n\n  return this.renderStructure(this.marks[mark.type.name](mark), null, options)\n};\n\n// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](##model.DOMOutputSpec).\nDOMSerializer.renderSpec = function (doc, structure) {\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  var dom = doc.createElement(structure[0]), contentDOM = null\n  var attrs = structure[1], start = 1\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2\n    for (var name in attrs) {\n      if (name == \"style\") { dom.style.cssText = attrs[name] }\n      else if (attrs[name] != null) { dom.setAttribute(name, attrs[name]) }\n    }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i]\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner)\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\nDOMSerializer.prototype.renderStructure = function (structure, node, options) {\n  var ref = DOMSerializer.renderSpec(doc(options), structure);\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (node && !node.isLeaf) {\n    if (!contentDOM) { throw new RangeError(\"No content hole in template for non-leaf node\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options) }\n    else\n      { this.serializeFragment(node.content, options, contentDOM) }\n  } else if (contentDOM) {\n    throw new RangeError(\"Content hole not allowed in a mark or leaf node spec\")\n  }\n  return dom\n};\n\n// :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// :: (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function (schema) {\n  return gatherToDOM(schema.nodes)\n};\n\n// :: (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function (schema) {\n  return gatherToDOM(schema.marks)\n};\nexports.DOMSerializer = DOMSerializer\n\nfunction gatherToDOM(obj) {\n  var result = {}\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM\n    if (toDOM) { result[name] = toDOM }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-model/dist/to_dom.js\n// module id = 149\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Schema = ref.Schema;\n\n// :: Object\n//\n//   doc:: NodeSpec The top level document node.\n//\n//   paragraph:: NodeSpec A plain paragraph textblock.\n//\n//   blockquote:: NodeSpec A blockquote wrapping one or more blocks.\n//\n//   horizontal_rule:: NodeSpec A horizontal rule.\n//\n//   heading:: NodeSpec A heading textblock, with a `level`\n//   attribute that should hold the number 1 to 6.\n//\n//   code_block:: NodeSpec A code listing. Disallows marks or\n//   non-text inline nodes by default.\n//\n//   text:: NodeSpec The text node.\n//\n//   image:: NodeSpec An inline image node. Supports `src`, `alt`, and\n//   `href` attributes. The latter two default to the empty string.\n//\n//   hard_break:: NodeSpec A hard line break.\nvar nodes = {\n  doc: {\n    content: \"block+\"\n  },\n\n  paragraph: {\n    content: \"inline<_>*\",\n    group: \"block\",\n    parseDOM: [{tag: \"p\"}],\n    toDOM: function toDOM() { return [\"p\", 0] }\n  },\n\n  blockquote: {\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"blockquote\"}],\n    toDOM: function toDOM() { return [\"blockquote\", 0] }\n  },\n\n  horizontal_rule: {\n    group: \"block\",\n    parseDOM: [{tag: \"hr\"}],\n    toDOM: function toDOM() { return [\"hr\"] }\n  },\n\n  heading: {\n    attrs: {level: {default: 1}},\n    content: \"inline<_>*\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n               {tag: \"h2\", attrs: {level: 2}},\n               {tag: \"h3\", attrs: {level: 3}},\n               {tag: \"h4\", attrs: {level: 4}},\n               {tag: \"h5\", attrs: {level: 5}},\n               {tag: \"h6\", attrs: {level: 6}}],\n    toDOM: function toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n  },\n\n  code_block: {\n    content: \"text*\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    parseDOM: [{tag: \"pre\", preserveWhitespace: true}],\n    toDOM: function toDOM() { return [\"pre\", [\"code\", 0]] }\n  },\n\n  text: {\n    group: \"inline\",\n    toDOM: function toDOM(node) { return node.text }\n  },\n\n  image: {\n    inline: true,\n    attrs: {\n      src: {},\n      alt: {default: null},\n      title: {default: null}\n    },\n    group: \"inline\",\n    draggable: true,\n    parseDOM: [{tag: \"img[src]\", getAttrs: function getAttrs(dom) {\n      return {\n        src: dom.getAttribute(\"src\"),\n        title: dom.getAttribute(\"title\"),\n        alt: dom.getAttribute(\"alt\")\n      }\n    }}],\n    toDOM: function toDOM(node) { return [\"img\", node.attrs] }\n  },\n\n  hard_break: {\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    parseDOM: [{tag: \"br\"}],\n    toDOM: function toDOM() { return [\"br\"] }\n  }\n}\nexports.nodes = nodes\n\n// :: Object\n//\n//  em:: MarkSpec An emphasis mark.\n//\n//  strong:: MarkSpec A strong mark.\n//\n//  link:: MarkSpec A link. Has `href` and `title` attributes.\n//  `title` defaults to the empty string.\n//\n//  code:: MarkSpec Code font mark.\nvar marks = {\n  em: {\n    parseDOM: [{tag: \"i\"}, {tag: \"em\"},\n               {style: \"font-style\", getAttrs: function (value) { return value == \"italic\" && null; }}],\n    toDOM: function toDOM() { return [\"em\"] }\n  },\n\n  strong: {\n    parseDOM: [{tag: \"strong\"},\n               // This works around a Google Docs misbehavior where\n               // pasted content will be inexplicably wrapped in `<b>`\n               // tags with a font-weight normal.\n               {tag: \"b\", getAttrs: function (node) { return node.style.fontWeight != \"normal\" && null; }},\n               {style: \"font-weight\", getAttrs: function (value) { return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null; }}],\n    toDOM: function toDOM() { return [\"strong\"] }\n  },\n\n  link: {\n    attrs: {\n      href: {},\n      title: {default: null}\n    },\n    parseDOM: [{tag: \"a[href]\", getAttrs: function getAttrs(dom) {\n      return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n    }}],\n    toDOM: function toDOM(node) { return [\"a\", node.attrs] }\n  },\n\n  code: {\n    parseDOM: [{tag: \"code\"}],\n    toDOM: function toDOM() { return [\"code\"] }\n  }\n}\nexports.marks = marks\n\n// :: Schema\n// This schema rougly corresponds to the document schema used by\n// CommonMark, minus the list elements, which are defined in the\n// [schema-list](#schema-list) module.\n//\n// To reuse elements from this schema, extend or read from its\n// [`nodeSpec`](#model.Schema.nodeSpec) and\n// [`markSpec`](#model.Schema.markSpec) properties.\nvar schema = new Schema({nodes: nodes, marks: marks})\nexports.schema = schema\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-schema-basic/dist/schema-basic.js\n// module id = 150\n// module chunks = 1","// ::- Plugins wrap extra functionality that can be added to an\n// editor. They can define new [state fields](#state.StateField), and\n// add [view props](#view.EditorProps).\nvar Plugin = function Plugin(options) {\n  var this$1 = this;\n\n  // :: EditorProps\n  // The props exported by this plugin.\n  this.props = {}\n  if (options.props) { for (var prop in options.props) {\n    var val = options.props[prop]\n    if (val instanceof Function) { val = val.bind(this$1) }\n    this$1.props[prop] = val\n  } }\n  // :: Object\n  // The plugin's configuration object.\n  this.options = options\n  this.key = options.key ? options.key.key : createKey(\"plugin\")\n};\n\n// :: (EditorState) → any\n// Get the state field for this plugin.\nPlugin.prototype.getState = function getState (state) { return state[this.key] };\nexports.Plugin = Plugin\n\n// StateField:: interface<T>\n// A plugin may provide a state field (under its `state` property) of\n// this type, which describes the state it wants to keep. Functions\n// provided here are always called with the plugin instance as their\n// `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of this field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for any fields initialzed after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this plugin.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nvar keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) { return name + \"$\" + ++keys[name] }\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.Plugin.constructor^options.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nvar PluginKey = function PluginKey(name) {\nif ( name === void 0 ) name = \"key\";\n this.key = createKey(name) };\n\n// :: (EditorState) → ?Plugin\n// Get the active plugin with this key, if any, from an editor\n// state.\nPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\n// :: (EditorState) → ?any\n// Get the plugin's state from an editor state.\nPluginKey.prototype.getState = function getState (state) { return state[this.key] };\nexports.PluginKey = PluginKey\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-state/dist/plugin.js\n// module id = 151\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Node = ref.Node;\n\nvar ref$1 = require(\"./selection\");\nvar Selection = ref$1.Selection;\nvar ref$2 = require(\"./transaction\");\nvar Transaction = ref$2.Transaction;\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name\n  this.init = bind(desc.init, self)\n  this.apply = bind(desc.apply, self)\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.nodes.doc.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init() { return null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.empty ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1 = this;\n\n  this.schema = schema\n  this.fields = baseFields.concat()\n  this.plugins = []\n  this.pluginsByKey = Object.create(null)\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1.plugins.push(plugin)\n    this$1.pluginsByKey[plugin.key] = plugin\n    if (plugin.options.state)\n      { this$1.fields.push(new FieldDesc(plugin.key, plugin.options.state, plugin)) }\n  }) }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. This is a persistent data structure—it isn't updated,\n// but rather a new state value is computed from an old one with the\n// [`apply`](#state.EditorState.apply) method.\n//\n// In addition to the built-in state fields, plugins can define\n// additional pieces of state.\nvar EditorState = function EditorState(config) {\n  this.config = config\n};\n\nvar prototypeAccessors = { schema: {},plugins: {},tr: {} };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next character that's typed. Will\n// be null whenever no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → ?Transaction\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    var this$1 = this;\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this$1.config.plugins[i]\n    if (plugin.options.filterTransaction && !plugin.options.filterTransaction.call(plugin, tr, this$1))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](##state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](##state.Plugin.constructor^options.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (tr) {\n    var this$1 = this;\n\n  if (!this.filterTransaction(tr)) { return {state: this, transactions: []} }\n\n  var trs = [tr], newState = this.applyInner(tr), seen = null\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n  outer: for (;;) {\n    var haveNew = false\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this$1.config.plugins[i]\n      if (plugin.options.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this$1\n        var tr$1 = n < trs.length &&\n            plugin.options.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n        if (tr$1 && newState.filterTransaction(tr$1, i)) {\n          if (!seen) {\n            seen = []\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this$1, n: 0}) }\n          }\n          trs.push(tr$1)\n          newState = newState.applyInner(tr$1)\n          haveNew = true\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length} }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n    var this$1 = this;\n\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i]\n    newInstance[field.name] = field.apply(tr, this$1[field.name], this$1, newInstance)\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this$1, tr, newInstance) }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a state. `config` must be an object containing at least a\n// `schema` (the schema to use) or `doc` (the starting document)\n// property. When it has a `selection` property, that should be a\n// valid [selection](#state.Selection) in the given document, to use\n// as starting selection. Plugins, which are specified as an array\n// in the `plugins` property, may read additional fields from the\n// config object.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.schema || config.doc.type.schema, config.plugins)\n  var instance = new EditorState($config)\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance) }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\nEditorState.prototype.reconfigure = function reconfigure (config) {\n    var this$1 = this;\n\n  var $config = new Configuration(config.schema || this.schema, config.plugins)\n  var fields = $config.fields, instance = new EditorState($config)\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name\n    instance[name] = this$1.hasOwnProperty(name) ? this$1[name] : fields[i].init(config, instance)\n  }\n  return instance\n};\n\n// :: (?Object<Plugin>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n    var this$1 = this;\n\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n  if (pluginFields) { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.options.state\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this$1[plugin.key]) }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins)\n  var instance = new EditorState($config)\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = Node.fromJSON(config.schema, json.doc)\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection)\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.options.state\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance)\n    }\n  })\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f)\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f)\n  if (found > -1) { applyListeners.splice(found, 1) }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors );\nexports.EditorState = EditorState\n\nvar applyListeners = []\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-state/dist/state.js\n// module id = 152\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar MarkType = ref.MarkType;\nvar Slice = ref.Slice;\nvar Fragment = ref.Fragment;\n\nvar ref$1 = require(\"./transform\");\nvar Transform = ref$1.Transform;\nvar ref$2 = require(\"./mark_step\");\nvar AddMarkStep = ref$2.AddMarkStep;\nvar RemoveMarkStep = ref$2.RemoveMarkStep;\nvar ref$3 = require(\"./replace_step\");\nvar ReplaceStep = ref$3.ReplaceStep;\n\n// :: (number, number, Mark) → Transform\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, function (node, pos, parent, index) {\n    if (!node.isInline) { return }\n    var marks = node.marks\n    if (mark.isInSet(marks) || !parent.contentMatchAt(index + 1).allowsMark(mark.type)) {\n      adding = removing = null\n    } else {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      var rm = mark.type.isInSet(marks)\n\n      if (!rm)\n        { removing = null }\n      else if (removing && removing.mark.eq(rm))\n        { removing.to = end }\n      else\n        { removed.push(removing = new RemoveMarkStep(start, end, rm)) }\n\n      if (adding)\n        { adding.to = end }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)) }\n    }\n  })\n\n  removed.forEach(function (s) { return this$1.step(s); })\n  added.forEach(function (s) { return this$1.step(s); })\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → Transform\n// Remove the given mark, or all marks of the given type, from inline\n// nodes between `from` and `to`.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++\n    var toRemove = null\n    if (mark instanceof MarkType) {\n      var found = mark.isInSet(node.marks)\n      if (found) { toRemove = [found] }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark] }\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to)\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0)\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m }\n        }\n        if (found$1) {\n          found$1.to = end\n          found$1.step = step\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step})\n        }\n      }\n    }\n  })\n  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); })\n  return this\n}\n\n// :: (number, number) → Transform\n// Remove all marks and non-text inline nodes from the given range.\nTransform.prototype.clearMarkup = function(from, to) {\n  var this$1 = this;\n\n  var delSteps = [] // Must be accumulated and applied in inverse order\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    if (!node.type.isText) {\n      delSteps.push(new ReplaceStep(pos, pos + node.nodeSize, Slice.empty))\n      return\n    }\n    for (var i = 0; i < node.marks.length; i++)\n      { this$1.step(new RemoveMarkStep(Math.max(pos, from), Math.min(pos + node.nodeSize, to), node.marks[i])) }\n  })\n  for (var i = delSteps.length - 1; i >= 0; i--) { this$1.step(delSteps[i]) }\n  return this\n}\n\nTransform.prototype.clearNonMatching = function(pos, match) {\n  var this$1 = this;\n\n  var node = this.doc.nodeAt(pos)\n  var delSteps = [], cur = pos + 1\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize\n    var allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (var j = 0; j < child.marks.length; j++) { if (!match.allowsMark(child.marks[j]))\n        { this$1.step(new RemoveMarkStep(cur, end, child.marks[j])) } }\n    }\n    cur = end\n  }\n  if (!match.validEnd()) {\n    var fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this$1.step(delSteps[i$1]) }\n  return this\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/mark.js\n// module id = 153\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Fragment = ref.Fragment;\nvar Slice = ref.Slice;\n\nvar ref$1 = require(\"./replace_step\");\nvar ReplaceStep = ref$1.ReplaceStep;\nvar ReplaceAroundStep = ref$1.ReplaceAroundStep;\nvar ref$2 = require(\"./transform\");\nvar Transform = ref$2.Transform;\nvar ref$3 = require(\"./structure\");\nvar insertPoint = ref$3.insertPoint;\n\n// :: (number, number, Slice) → Transform\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openLeft`](#model.Slice.openLeft) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  var this$1 = this;\n\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from)\n  if (fitsTrivially($from, this.doc.resolve(to), slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var canExpand = coveredDepths($from, this.doc.resolve(to)), preferredExpand = 0\n  canExpand.unshift($from.depth + 1)\n  for (var d = $from.depth; d > 0; d--) {\n    if ($from.node(d).type.spec.defining) { break }\n    var found = canExpand.indexOf(d, 1)\n    if (found > -1) { preferredExpand = found }\n  }\n\n  var leftNodes = [], preferredDepth = slice.openLeft\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openLeft) { break }\n    content = node.content\n  }\n  // Back up if the node directly above openLeft, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining)\n    { preferredDepth -= 1 }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining)\n    { preferredDepth -= 2 }\n\n  for (var j = slice.openLeft; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openLeft + 1)\n    var insert = leftNodes[openDepth]\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < canExpand.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var expandDepth = canExpand[(i$1 + preferredExpand) % canExpand.length]\n      var parent = $from.node(expandDepth - 1), index = $from.index(expandDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.attrs, insert.marks))\n        { return this$1.replace($from.before(expandDepth), expandDepth > $from.depth ? to : $from.after(expandDepth),\n                            new Slice(closeFragment(slice.content, 0, slice.openLeft, openDepth),\n                                      openDepth, slice.openRight)) }\n    }\n  }\n\n  return this.replace(from, to, slice)\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen)\n    { fragment = parent.contentMatchAt(0).fillBefore(fragment).append(fragment) }\n  return fragment\n}\n\n// :: (number, number, Node) → Transform\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type, node.attrs)\n    if (point != null) { from = to = point }\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → Transform\n// Delete the given range, and any fully covered parent nodes that are\n// not allowed to be empty.\nTransform.prototype.deleteRange = function(from, to) {\n  var $from = this.doc.resolve(from)\n  var covered = coveredDepths($from, this.doc.resolve(to)), grown = false\n  // Find the innermost covered node that allows its whole content to\n  // be deleted\n  for (var i = 0; i < covered.length; i++) {\n    if ($from.node(covered[i]).contentMatchAt(0).validEnd()) {\n      from = $from.start(covered[i])\n      to = $from.end(covered[i])\n      grown = true\n      break\n    }\n  }\n  // If no such node was found and the outermose covered node can be\n  // deleted entirely, do that\n  if (!grown && covered.length) {\n    var depth = covered[covered.length - 1]\n    if ($from.node(depth - 1).canReplace($from.index(depth - 1), $from.indexAfter(depth - 1))) {\n      from = $from.before(depth)\n      to = $from.after(depth)\n    }\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the node at that depth.\nfunction coveredDepths($from, $to) {\n  var result = []\n  for (var i = 0; i < $from.depth; i++) {\n    var depth = $from.depth - i\n    if ($from.pos - i > $from.start(depth)) { break }\n    if ($to.depth >= depth && $to.pos + ($to.depth - depth) == $from.end(depth)) { result.push(depth) }\n  }\n  return result\n}\n\n// :: (number, number) → Transform\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// \"Fit\" a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it.\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  var placed = placeSlice($from, slice)\n\n  var fittedLeft = fitLeft($from, placed)\n  var fitted = fitRight($from, $to, fittedLeft)\n  if (!fitted) { return null }\n  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {\n    var d = $to.depth, after = $to.after(d)\n    while (d > 1 && after == $to.end(--d)) { ++after }\n    var fittedAfter = fitRight($from, doc.resolve(after), fittedLeft)\n    if (fittedAfter)\n      { return new ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size) }\n  }\n  return new ReplaceStep(from, to, fitted)\n}\nexports.replaceStep = replaceStep\n\n// :: (number, ?number, ?Slice) → Transform\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice)\n  if (step) { this.step(step) }\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → Transform\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → Transform\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\n\n\nfunction fitLeftInner($from, depth, placed, placedBelow) {\n  var content = Fragment.empty, openRight = 0, placedHere = placed[depth]\n  if ($from.depth > depth) {\n    var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere)\n    openRight = inner.openRight + 1\n    content = Fragment.from($from.node(depth + 1).copy(inner.content))\n  }\n\n  if (placedHere) {\n    content = content.append(placedHere.content)\n    openRight = placedHere.openRight\n  }\n  if (placedBelow) {\n    content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(Fragment.empty, true))\n    openRight = 0\n  }\n\n  return {content: content, openRight: openRight}\n}\n\nfunction fitLeft($from, placed) {\n  var ref = fitLeftInner($from, 0, placed, false);\n  var content = ref.content;\n  var openRight = ref.openRight;\n  return new Slice(content, $from.depth, openRight || 0)\n}\n\nfunction fitRightJoin(content, parent, $from, $to, depth, openLeft, openRight) {\n  var match, count = content.childCount, matchCount = count - (openRight > 0 ? 1 : 0)\n  if (openLeft < 0)\n    { match = parent.contentMatchAt(matchCount) }\n  else if (count == 1 && openRight > 0)\n    { match = $from.node(depth).contentMatchAt(openLeft ? $from.index(depth) : $from.indexAfter(depth)) }\n  else\n    { match = $from.node(depth).contentMatchAt($from.indexAfter(depth))\n      .matchFragment(content, count > 0 && openLeft ? 1 : 0, matchCount) }\n\n  var toNode = $to.node(depth)\n  if (openRight > 0 && depth < $to.depth) {\n    var after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild)\n    var joinable$1 = match.fillBefore(after, true)\n    // Can't insert content if there's a single node stretched across this gap\n    if (joinable$1 && joinable$1.size && openLeft > 0 && count == 1) { joinable$1 = null }\n\n    if (joinable$1) {\n      var inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to,\n                               depth + 1, count == 1 ? openLeft - 1 : -1, openRight - 1)\n      if (inner) {\n        var last = content.lastChild.copy(inner)\n        if (joinable$1.size)\n          { return content.cutByIndex(0, count - 1).append(joinable$1).addToEnd(last) }\n        else\n          { return content.replaceChild(count - 1, last) }\n      }\n    }\n  }\n  if (openRight > 0)\n    { match = match.matchNode(count == 1 && openLeft > 0 ? $from.node(depth + 1) : content.lastChild) }\n\n  // If we're here, the next level can't be joined, so we see what\n  // happens if we leave it open.\n  var toIndex = $to.index(depth)\n  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) { return null }\n  var joinable = match.fillBefore(toNode.content, true, toIndex)\n  if (!joinable) { return null }\n\n  if (openRight > 0) {\n    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1,\n                                count == 1 ? openLeft - 1 : -1)\n    content = content.replaceChild(count - 1, closed)\n  }\n  content = content.append(joinable)\n  if ($to.depth > depth)\n    { content = content.addToEnd(fitRightSeparate($to, depth + 1)) }\n  return content\n}\n\nfunction fitRightClosed(node, openRight, $from, depth, openLeft) {\n  var match, content = node.content, count = content.childCount\n  if (openLeft >= 0)\n    { match = $from.node(depth).contentMatchAt($from.indexAfter(depth))\n      .matchFragment(content, openLeft > 0 ? 1 : 0, count) }\n  else\n    { match = node.contentMatchAt(count) }\n\n  if (openRight > 0) {\n    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1,\n                                count == 1 ? openLeft - 1 : -1)\n    content = content.replaceChild(count - 1, closed)\n  }\n\n  return node.copy(content.append(match.fillBefore(Fragment.empty, true)))\n}\n\nfunction fitRightSeparate($to, depth) {\n  var node = $to.node(depth)\n  var fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth))\n  if ($to.depth > depth) { fill = fill.addToEnd(fitRightSeparate($to, depth + 1)) }\n  return node.copy(fill)\n}\n\nfunction normalizeSlice(content, openLeft, openRight) {\n  while (openLeft > 0 && openRight > 0 && content.childCount == 1) {\n    content = content.firstChild.content\n    openLeft--\n    openRight--\n  }\n  return new Slice(content, openLeft, openRight)\n}\n\n// : (ResolvedPos, ResolvedPos, number, Slice) → Slice\nfunction fitRight($from, $to, slice) {\n  var fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openLeft, slice.openRight)\n  if (!fitted) { return null }\n  return normalizeSlice(fitted, slice.openLeft, $to.depth)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openLeft && !slice.openRight && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\nfunction canMoveText($from, $to, slice) {\n  if (!$to.parent.isTextblock) { return false }\n\n  var match\n  if (!slice.openRight) {\n    var parent = $from.node($from.depth - (slice.openLeft - slice.openRight))\n    if (!parent.isTextblock) { return false }\n    match = parent.contentMatchAt(parent.childCount)\n    if (slice.size)\n      { match = match.matchFragment(slice.content, slice.openLeft ? 1 : 0) }\n  } else {\n    var parent$1 = nodeRight(slice.content, slice.openRight)\n    if (!parent$1.isTextblock) { return false }\n    match = parent$1.contentMatchAt(parent$1.childCount)\n  }\n  match = match.matchFragment($to.parent.content, $to.index())\n  return match && match.validEnd()\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// So placeSlice splits up a slice into a number of sub-slices,\n// along with information on where they can be placed on the given\n// left-side edge. It works by walking the open side of the slice,\n// from the inside out, and trying to find a landing spot for each\n// element, by simultaneously scanning over the gap side. When no\n// place is found for an open node's content, it is left in that node.\n//\n// If the outer content can't be placed, a set of wrapper nodes is\n// made up for it (by rooting it in the document node type using\n// findWrapping), and the algorithm continues to iterate over those.\n// This is guaranteed to find a fit, since both stacks now start with\n// the same node type (doc).\n\nfunction nodeLeft(content, depth) {\n  for (var i = 1; i < depth; i++) { content = content.firstChild.content }\n  return content.firstChild\n}\n\nfunction nodeRight(content, depth) {\n  for (var i = 1; i < depth; i++) { content = content.lastChild.content }\n  return content.lastChild\n}\n\n// : (ResolvedPos, Slice) → [{content: Fragment, openRight: number, depth: number}]\nfunction placeSlice($from, slice) {\n  var dFrom = $from.depth, unplaced = null\n  var placed = [], parents = null\n\n  // Loop over the open side of the slice, trying to find a place for\n  // each open fragment.\n  for (var dSlice = slice.openLeft;; --dSlice) {\n    // Get the components of the node at this level\n    var curType = (void 0), curAttrs = (void 0), curFragment = (void 0)\n    if (dSlice >= 0) {\n      if (dSlice > 0) { // Inside slice\n        ;var assign;\n        ((assign = nodeLeft(slice.content, dSlice), curType = assign.type, curAttrs = assign.attrs, curFragment = assign.content))\n      } else if (dSlice == 0) { // Top of slice\n        curFragment = slice.content\n      }\n      if (dSlice < slice.openLeft) { curFragment = curFragment.cut(curFragment.firstChild.nodeSize) }\n    } else { // Outside slice, in generated wrappers (see below)\n      curFragment = Fragment.empty\n      var parent = parents[parents.length + dSlice - 1]\n      curType = parent.type\n      curAttrs = parent.attrs\n    }\n    // If the last iteration left unplaced content, include it in the fragment\n    if (unplaced) { curFragment = curFragment.addToStart(unplaced) }\n\n    // If there's nothing left to place, we're done\n    if (curFragment.size == 0 && dSlice <= 0) { break }\n\n    // This will go through the positions in $from, down from dFrom,\n    // to find a fit\n    var found = findPlacement(curFragment, $from, dFrom, placed)\n    if (found) {\n      // If there was a fit, store it, and consider this content placed\n      if (found.fragment.size > 0) { placed[found.depth] = {\n        content: found.fragment,\n        openRight: endOfContent(slice, dSlice) ? slice.openRight - dSlice : 0,\n        depth: found.depth\n      } }\n      // If that was the last of the content, we're done\n      if (dSlice <= 0) { break }\n      unplaced = null\n      dFrom = found.depth - (curType == $from.node(found.depth).type ? 1 : 0)\n    } else {\n      if (dSlice == 0) {\n        // This is the top of the slice, and we haven't found a place to insert it.\n        var top = $from.node(0)\n        // Try to find a wrapping that makes its first child fit in the top node.\n        var wrap = top.contentMatchAt($from.index(0)).findWrappingFor(curFragment.firstChild)\n        // If no such thing exists, give up.\n        if (!wrap || wrap.length == 0) { break }\n        var last = wrap[wrap.length - 1]\n        // Check that the fragment actually fits in the wrapping.\n        if (!last.type.contentExpr.matches(last.attrs, curFragment)) { break }\n        // Store the result for subsequent iterations.\n        parents = [{type: top.type, attrs: top.attrs}].concat(wrap)\n        ;var assign$1;\n        ((assign$1 = last, curType = assign$1.type, curAttrs = assign$1.attrs))\n      }\n      if (curFragment.size) {\n        curFragment = curType.contentExpr.start(curAttrs).fillBefore(curFragment, true).append(curFragment)\n        unplaced = curType.create(curAttrs, curFragment)\n      } else {\n        unplaced = null\n      }\n    }\n  }\n\n  return placed\n}\n\nfunction endOfContent(slice, depth) {\n  for (var i = 0, content = slice.content; i < depth; i++) {\n    if (content.childCount > 1) { return false }\n    content = content.firstChild.content\n  }\n  return true\n}\n\nfunction findPlacement(fragment, $from, start, placed) {\n  var hasMarks = false\n  for (var i = 0; i < fragment.childCount; i++)\n    { if (fragment.child(i).marks.length) { hasMarks = true } }\n  for (var d = start; d >= 0; d--) {\n    var startMatch = $from.node(d).contentMatchAt($from.indexAfter(d))\n    var existing = placed[d]\n    if (existing) { startMatch = startMatch.matchFragment(existing.content) }\n    var match = startMatch.fillBefore(fragment)\n    if (match) { return {depth: d, fragment: (existing ? existing.content.append(match) : match).append(fragment)} }\n    if (hasMarks) {\n      var stripped = matchStrippingMarks(startMatch, fragment)\n      if (stripped) { return {depth: d, fragment: existing ? existing.content.append(stripped) : stripped} }\n    }\n  }\n}\n\nfunction matchStrippingMarks(match, fragment) {\n  var newNodes = []\n  for (var i = 0; i < fragment.childCount; i++) {\n    var node = fragment.child(i), stripped = node.mark(node.marks.filter(function (m) { return match.allowsMark(m.type); }))\n    match = match.matchNode(stripped)\n    if (!match) { return null }\n    newNodes.push(stripped)\n  }\n  return Fragment.from(newNodes)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-transform/dist/replace.js\n// module id = 154\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar Selection = ref.Selection;\nvar NodeSelection = ref.NodeSelection;\nvar TextSelection = ref.TextSelection;\nvar browser = require(\"./browser\")\n\nfunction moveSelectionBlock(state, dir) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var node = ref.node;\n  var $side = dir > 0 ? $to : $from\n  var $start = node && node.isBlock ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView())\n  return true\n}\n\nfunction selectHorizontally(view, dir) {\n  var ref = view.state.selection;\n  var empty = ref.empty;\n  var node = ref.node;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (!empty && !node) { return false }\n\n  if (node && node.isInline)\n    { return apply(view, new TextSelection(dir > 0 ? $to : $from)) }\n\n  if (!node && !view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n    var ref$1 = dir > 0\n        ? $from.parent.childAfter($from.parentOffset)\n        : $from.parent.childBefore($from.parentOffset);\n    var nextNode = ref$1.node;\n    var offset = ref$1.offset;\n    if (nextNode && NodeSelection.isSelectable(nextNode) && offset == $from.parentOffset - (dir > 0 ? 0 : nextNode.nodeSize))\n      { return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($from.pos - nextNode.nodeSize) : $from)) }\n    return false\n  }\n\n  var next = moveSelectionBlock(view.state, dir)\n  if (next && (next instanceof NodeSelection || node))\n    { return apply(view, next) }\n\n  return false\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  var desc = dom.pmViewDesc\n  return desc && desc.size == 0\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  var sel = view.root.getSelection()\n  var node = sel.anchorNode, offset = sel.anchorOffset\n  var moveNode, moveOffset\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) { break }\n      var before = node.childNodes[offset - 1]\n      if (isIgnorable(before)) {\n        moveNode = node\n        moveOffset = --offset\n      }\n      else { break }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var prev = node.previousSibling\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode\n        moveOffset = Array.prototype.indexOf.call(moveNode.childNodes, prev)\n        prev = prev.previousSibling\n      }\n      if (!prev) {\n        node = node.parentNode\n        if (node == view.content) { break }\n        offset = 0\n      } else {\n        node = prev\n        offset = nodeLen(node)\n      }\n    }\n  }\n  if (moveNode) { setSel(sel, moveNode, moveOffset) }\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  var sel = view.root.getSelection()\n  var node = sel.anchorNode, offset = sel.anchorOffset, len = nodeLen(node)\n  var moveNode, moveOffset\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) { break }\n      var after = node.childNodes[offset]\n      if (isIgnorable(after)) {\n        moveNode = node\n        moveOffset = ++offset\n      }\n      else { break }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var next = node.nextSibling\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode\n        moveOffset = Array.prototype.indexOf.call(moveNode.childNodes, next) + 1\n        next = next.nextSibling\n      }\n      if (!next) {\n        node = node.parentNode\n        if (node == view.content) { break }\n        offset = len = 0\n      } else {\n        node = next\n        offset = 0\n        len = nodeLen(node)\n      }\n    }\n  }\n  if (moveNode) { setSel(sel, moveNode, moveOffset) }\n}\n\nfunction isBlockNode(dom) {\n  var desc = dom.pmViewDesc\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSel(sel, node, offset) {\n  var range = document.createRange()\n  range.setEnd(node, offset)\n  range.setStart(node, offset)\n  sel.removeAllRanges()\n  sel.addRange(range)\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir) {\n  var ref = view.state.selection;\n  var empty = ref.empty;\n  var node = ref.node;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (!empty && !node) { return false }\n\n  var leavingTextblock = true, $start = dir < 0 ? $from : $to\n  if (!node || node.isInline)\n    { leavingTextblock = view.endOfTextblock(dir < 0 ? \"up\" : \"down\") }\n\n  if (leavingTextblock) {\n    var next = moveSelectionBlock(view.state, dir)\n    if (next && (next instanceof NodeSelection))\n      { return apply(view, next) }\n  }\n\n  if (!node || node.isInline) { return false }\n\n  var beyond = Selection.findFrom($start, dir)\n  return beyond ? apply(view, beyond) : true\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  var empty = ref.empty;\n  if (!$head || !$head.sameParent($anchor) || !$head.parent.isTextblock) { return true }\n  if (!empty) { return false }\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) { return true }\n  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter)\n  if (nextNode && !nextNode.isText) {\n    var tr = view.state.tr\n    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos) }\n    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize) }\n    view.dispatch(tr)\n    return true\n  }\n  return false\n}\n\n// A backdrop keymap used to make sure we always suppress keys that\n// have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction captureKeyDown(view, event) {\n  var code = event.keyCode, mod = browser.mac ? event.metaKey : event.ctrlKey\n  if (code == 8) { // Backspace\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46) { // Delete\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1)\n  } else if (code == 40) { // Down arrow\n    return selectVertically(view, 1)\n  } else if (mod && !event.altKey && !event.shiftKey) { // Mod-\n    if (code == 66 || code == 73 || code == 89 || code == 90) // Mod-[biyz]\n      { return true }\n    if (browser.mac && code == 68) // Mod-d\n      { return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view) }\n    if (browser.mac && code == 72) // Mod-h\n      { return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view) }\n  } else if (browser.mac && code == 68 && event.altKey && !mod && !event.shiftKey) { // Alt-d\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  }\n  return false\n}\nexports.captureKeyDown = captureKeyDown\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/capturekeys.js\n// module id = 155\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Slice = ref.Slice;\nvar Fragment = ref.Fragment;\nvar DOMParser = ref.DOMParser;\nvar DOMSerializer = ref.DOMSerializer;\n\n// : (EditorView, Selection, dom.DataTransfer) → Slice\n// Store the content of a selection in the clipboard (or whatever the\n// given data transfer refers to)\nfunction toClipboard(view, range, dataTransfer) {\n  // Node selections are copied using just the node, text selection include parents\n  var doc = view.state.doc, fullSlice = doc.slice(range.from, range.to, !range.node)\n  var slice = fullSlice, context\n  if (!range.node) {\n    // Shrink slices for non-node selections to hold only the parent\n    // node, store rest in context string, so that other tools don't\n    // get confused\n    var cut = Math.max(0, range.$from.sharedDepth(range.to) - 1)\n    context = sliceContext(slice, cut)\n    var content = slice.content\n    for (var i = 0; i < cut; i++) { content = content.firstChild.content }\n    slice = new Slice(content, slice.openLeft - cut, slice.openRight - cut)\n  }\n\n  var serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema)\n  var dom = serializer.serializeFragment(slice.content), wrap = document.createElement(\"div\")\n  wrap.appendChild(dom)\n  var child = wrap.firstChild.nodeType == 1 && wrap.firstChild\n  if (child) {\n    if (range.node)\n      { child.setAttribute(\"data-pm-node-selection\", true) }\n    else\n      { child.setAttribute(\"data-pm-context\", context) }\n  }\n\n  dataTransfer.clearData()\n  dataTransfer.setData(\"text/html\", wrap.innerHTML)\n  dataTransfer.setData(\"text/plain\", slice.content.textBetween(0, slice.content.size, \"\\n\\n\"))\n  return fullSlice\n}\nexports.toClipboard = toClipboard\n\nvar cachedCanUpdateClipboard = null\nfunction canUpdateClipboard(dataTransfer) {\n  if (cachedCanUpdateClipboard != null) { return cachedCanUpdateClipboard }\n  dataTransfer.setData(\"text/html\", \"<hr>\")\n  return cachedCanUpdateClipboard = dataTransfer.getData(\"text/html\") == \"<hr>\"\n}\nexports.canUpdateClipboard = canUpdateClipboard\n\n// : (EditorView, dom.DataTransfer, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nfunction fromClipboard(view, dataTransfer, plainText, $context) {\n  var txt = dataTransfer.getData(\"text/plain\")\n  var html = dataTransfer.getData(\"text/html\")\n  if (!html && !txt) { return null }\n  var dom, inCode = $context.parent.type.spec.code\n  if ((plainText || inCode || !html) && txt) {\n    view.someProp(\"transformPastedText\", function (f) { return txt = f(txt); })\n    if (inCode) { return new Slice(Fragment.from(view.state.schema.text(txt)), 0, 0) }\n    dom = document.createElement(\"div\")\n    txt.split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n      dom.appendChild(document.createElement(\"p\")).textContent = block\n    })\n  } else {\n    view.someProp(\"transformPastedHTML\", function (f) { return html = f(html); })\n    dom = readHTML(html)\n  }\n\n  var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n  var slice = parser.parseSlice(dom, {preserveWhitespace: true}), context\n  if (dom.querySelector(\"[data-pm-node-selection]\"))\n    { slice = new Slice(slice.content, 0, 0) }\n  else if (context = dom.querySelector(\"[data-pm-context]\"))\n    { slice = addContext(slice, context.getAttribute(\"data-pm-context\")) }\n  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    { slice = normalizeSiblings(slice, $context) }\n  return slice\n}\nexports.fromClipboard = fromClipboard\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(slice, $context) {\n  if (slice.content.childCount < 2) { return slice }\n  var loop = function ( d ) {\n    var parent = $context.node(d)\n    var match = parent.contentMatchAt($context.index(d))\n    var lastWrap = (void 0), result = []\n    slice.content.forEach(function (node) {\n      if (!result) { return }\n      var wrap = match.findWrappingFor(node), inLast\n      if (!wrap) { return result = null }\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast\n      } else {\n        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length) }\n        var wrapped = withWrappers(node, wrap)\n        result.push(wrapped)\n        match = match.matchType(wrapped.type, wrapped.attrs)\n        lastWrap = wrap\n      }\n    })\n    if (result) { return { v: Slice.maxOpen(Fragment.from(result)) } }\n  };\n\n  for (var d = $context.depth; d >= 0; d--) {\n    var returned = loop( d );\n\n    if ( returned ) return returned.v;\n  }\n  return slice\n}\n\nfunction withWrappers(node, wrap, from) {\n  if ( from === void 0 ) from = 0;\n\n  for (var i = wrap.length - 1; i >= from; i--)\n    { node = wrap[i].type.create(wrap[i].attrs, Fragment.from(node)) }\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth].type == lastWrap[depth].type) {\n    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1)\n    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }\n    var match = sibling.contentMatchAt(sibling.childCount)\n    if (depth == wrap.length - 1 ? match.matchNode(node) : match.matchType(wrap[depth + 1].type, wrap[depth + 1].attrs))\n      { return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1)))) }\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) { return node }\n  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1))\n  var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)\n  return node.copy(fragment.append(fill))\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nvar wrapMap = {thead: \"table\", colgroup: \"table\", col: \"table colgroup\",\n                 tr: \"table tbody\", td: \"table tbody tr\", th: \"table tbody tr\"}\nvar detachedDoc = null\nfunction readHTML(html) {\n  var metas = /(\\s*<meta [^>]*>)*/.exec(html)\n  if (metas) { html = html.slice(metas[0].length) }\n  var doc = detachedDoc || (detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n  var elt = doc.createElement(\"div\")\n  var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\\s]+)/i.exec(html), wrap, depth = 0\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {\n    var nodes = wrap.split(\" \")\n    html = nodes.map(function (n) { return \"<\" + n + \">\"; }).join(\"\") + html + nodes.map(function (n) { return \"</\" + n + \">\"; }).reverse().join(\"\")\n    depth = nodes.length\n  }\n  elt.innerHTML = html\n  for (var i = 0; i < depth; i++) { elt = elt.firstChild }\n  return elt\n}\n\nfunction sliceContext(slice, depth) {\n  var result = [], content = slice.content\n  for (var i = 0; i < depth; i++) {\n    var node = content.firstChild\n    result.push(node.type.name, node.type.hasRequiredAttrs() ? node.attrs : null)\n    content = node.content\n  }\n  return JSON.stringify(result)\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) { return slice }\n  var schema = slice.content.firstChild.type.schema, array\n  try { array = JSON.parse(context) }\n  catch(e) { return slice }\n  var content = slice.content;\n  var openLeft = slice.openLeft;\n  var openRight = slice.openRight;\n  for (var i = array.length - 2; i >= 0; i -= 2) {\n    var type = schema.nodes[array[i]]\n    if (!type || type.hasRequiredAttrs()) { break }\n    content = Fragment.from(type.create(array[i + 1], content))\n    openLeft++; openRight++\n  }\n  return new Slice(content, openLeft, openRight)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/clipboard.js\n// module id = 156\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar Fragment = ref.Fragment;\nvar DOMParser = ref.DOMParser;\nvar ref$1 = require(\"prosemirror-state\");\nvar Selection = ref$1.Selection;\n\nvar ref$2 = require(\"./trackmappings\");\nvar TrackMappings = ref$2.TrackMappings;\n\nvar DOMChange = function(view, id, composing) {\n  var this$1 = this;\n\n  this.view = view\n  this.id = id\n  this.state = view.state\n  this.composing = composing\n  this.from = this.to = null\n  this.timeout = composing ? null : setTimeout(function () { return this$1.finish(); }, 20)\n  this.mappings = new TrackMappings(view.state)\n};\n\nDOMChange.prototype.addRange = function (from, to) {\n  if (this.from == null) {\n    this.from = from\n    this.to = to\n  } else {\n    this.from = Math.min(from, this.from)\n    this.to = Math.max(to, this.to)\n  }\n};\n\nDOMChange.prototype.changedRange = function () {\n  if (this.from == null) { return rangeAroundSelection(this.state.selection) }\n  var $from = this.state.doc.resolve(this.from), $to = this.state.doc.resolve(this.to)\n  var shared = $from.sharedDepth(this.to)\n  return {from: $from.before(shared + 1), to: $to.after(shared + 1)}\n};\n\nDOMChange.prototype.finish = function (force) {\n  clearTimeout(this.timeout)\n  if (this.composing && !force) { return }\n  var range = this.changedRange()\n  if (this.from == null) { this.view.docView.markDirty(range.from, range.to) }\n  else { this.view.docView.markDirty(this.from, this.to) }\n\n  // If there have been changes since this DOM update started, we must\n  // map our start and end positions, as well as the new selection\n  // positions, through them.\n  var mapping = this.mappings.getMapping(this.view.state)\n  this.destroy()\n  if (mapping) { readDOMChange(this.view, mapping, this.state, range) }\n\n  // If the reading didn't result in a view update, force one by\n  // resetting the view to its current state.\n  if (this.view.docView.dirty) { this.view.updateState(this.view.state) }\n};\n\nDOMChange.prototype.destroy = function () {\n  this.mappings.destroy()\n  this.view.inDOMChange = null\n};\n\nDOMChange.prototype.compositionEnd = function () {\n    var this$1 = this;\n\n  if (this.composing) {\n    this.composing = false\n    this.timeout = setTimeout(function () { return this$1.finish(); }, 50)\n  }\n};\n\nDOMChange.start = function (view, composing) {\n  if (view.inDOMChange) {\n    if (composing) {\n      clearTimeout(view.inDOMChange.timeout)\n      view.inDOMChange.composing = true\n    }\n  } else {\n    var id = Math.floor(Math.random() * 0xffffffff)\n    view.inDOMChange = new DOMChange(view, id, composing)\n  }\n};\nexports.DOMChange = DOMChange\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, oldState, from, to) {\n  var ref = view.docView.domFromPos(from, -1);\n  var parent = ref.node;\n  var startOff = ref.offset;\n  var ref$1 = view.docView.domFromPos(to, 1);\n  var parentRight = ref$1.node;\n  var endOff = ref$1.offset;\n  if (parent != parentRight) { return null }\n  // If there's non-view nodes directly after the end of this region,\n  // fail and let the caller try again with a wider range.\n  if (endOff == parent.childNodes.length) { for (var scan = parent; scan != view.content;) {\n    if (scan.nextSibling) {\n      if (!scan.nextSibling.pmViewDesc) { return null }\n      break\n    }\n    scan = scan.parentNode\n  } }\n\n  var domSel = view.root.getSelection(), find = null\n  if (domSel.anchorNode && view.content.contains(domSel.anchorNode)) {\n    find = [{node: domSel.anchorNode, offset: domSel.anchorOffset}]\n    if (!domSel.isCollapsed)\n      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}) }\n  }\n  var startDoc = oldState.doc\n  var parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n  var $from = startDoc.resolve(from)\n  var sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent.copy(),\n    topStart: $from.index(),\n    topOpen: true,\n    from: startOff,\n    to: endOff,\n    preserveWhitespace: true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode: ruleFromNode\n  })\n  if (find && find[0].pos != null) {\n    var anchor = find[0].pos, head = find[1] && find[1].pos\n    if (head == null) { head = anchor }\n    sel = {anchor: anchor + from, head: head + from}\n  }\n  return {doc: doc, sel: sel}\n}\n\nfunction ruleFromNode(dom) {\n  var desc = dom.pmViewDesc\n  if (desc) { return desc.parseRule() }\n  else if (dom.nodeName == \"BR\" && dom.parentNode && dom.parentNode.lastChild == dom) { return {ignore: true} }\n}\n\nfunction isAtEnd($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++)\n    { if ($pos.index(i) + 1 < $pos.node(i).childCount) { return false } }\n  return $pos.parentOffset == $pos.parent.content.size\n}\nfunction isAtStart($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++)\n    { if ($pos.index(0) > 0) { return false } }\n  return $pos.parentOffset == 0\n}\n\nfunction rangeAroundSelection(selection) {\n  var $from = selection.$from;\n  var $to = selection.$to;\n\n  if ($from.sameParent($to) && $from.parent.isTextblock && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {\n    var startOff = Math.max(0, $from.parentOffset)\n    var size = $from.parent.content.size\n    var endOff = Math.min(size, $to.parentOffset)\n\n    if (startOff > 0)\n      { startOff = $from.parent.childBefore(startOff).offset }\n    if (endOff < size) {\n      var after = $from.parent.childAfter(endOff)\n      endOff = after.offset + after.node.nodeSize\n    }\n    var nodeStart = $from.start()\n    return {from: nodeStart + startOff, to: nodeStart + endOff}\n  } else {\n    for (var depth = 0;; depth++) {\n      var fromStart = isAtStart($from, depth + 1), toEnd = isAtEnd($to, depth + 1)\n      if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {\n        var from = $from.before(depth + 1), to = $to.after(depth + 1)\n        if (fromStart && $from.index(depth) > 0)\n          { from -= $from.node(depth).child($from.index(depth) - 1).nodeSize }\n        if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount)\n          { to += $to.node(depth).child($to.index(depth) + 1).nodeSize }\n        return {from: from, to: to}\n      }\n    }\n  }\n}\n\nfunction keyEvent(keyCode, key) {\n  var event = document.createEvent(\"Event\")\n  event.initEvent(\"keydown\", true, true)\n  event.keyCode = keyCode\n  event.key = event.code = key\n  return event\n}\n\nfunction readDOMChange(view, mapping, oldState, range) {\n  var parseResult, doc = oldState.doc\n\n  for (;;) {\n    parseResult = parseBetween(view, oldState, range.from, range.to)\n    if (parseResult) { break }\n    var $from$1 = doc.resolve(range.from), $to$1 = doc.resolve(range.to)\n    range = {from: $from$1.depth ? $from$1.before() : 0,\n             to: $to$1.depth ? $to$1.after() : doc.content.size}\n  }\n  var parsed = parseResult.doc;\n  var parsedSel = parseResult.sel;\n\n  var compare = doc.slice(range.from, range.to)\n  var change = findDiff(compare.content, parsed.content, range.from, oldState.selection.from)\n\n  if (!change) {\n    if (parsedSel) {\n      var sel = resolveSelection(view.state.doc, mapping, parsedSel)\n      if (!sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)) }\n    }\n    return\n  }\n\n  var $from = parsed.resolveNoCache(change.start - range.from)\n  var $to = parsed.resolveNoCache(change.endB - range.from)\n  var nextSel\n  // If this looks like the effect of pressing Enter, just dispatch an\n  // Enter key instead.\n  if (!$from.sameParent($to) && $from.pos < parsed.content.size &&\n      (nextSel = Selection.findFrom(parsed.resolve($from.pos + 1), 1, true)) &&\n      nextSel.head == $to.pos &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); }))\n    { return }\n  if (oldState.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); }))\n    { return }\n\n  var from = mapping.map(change.start), to = mapping.map(change.endA, -1)\n\n  var tr, storedMarks, markChange, $from1\n  if ($from.sameParent($to) && $from.parent.isTextblock) {\n    if ($from.pos == $to.pos) { // Deletion\n      tr = view.state.tr.delete(from, to)\n      var $start = doc.resolve(change.start)\n      if ($start.parentOffset < $start.parent.content.size) { storedMarks = $start.marks(true) }\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr\n      if (markChange.type == \"add\") { tr.addMark(from, to, markChange.mark) }\n      else { tr.removeMark(from, to, markChange.mark) }\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset)\n      if (view.someProp(\"handleTextInput\", function (f) { return f(view, from, to, text); })) { return }\n      tr = view.state.tr.insertText(text, from, to)\n    }\n  }\n\n  if (!tr)\n    { tr = view.state.tr.replace(from, to, parsed.slice(change.start - range.from, change.endB - range.from)) }\n  if (parsedSel) { tr.setSelection(resolveSelection(tr.doc, mapping, parsedSel)) }\n  if (storedMarks) { tr.setStoredMarks(storedMarks) }\n  view.dispatch(tr.scrollIntoView())\n}\n\nfunction resolveSelection(doc, mapping, parsedSel) {\n  return Selection.between(doc.resolve(mapping.map(parsedSel.anchor)),\n                           doc.resolve(mapping.map(parsedSel.head)))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks\n  var added = curMarks, removed = prevMarks, type, mark, update\n  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added) }\n  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed) }\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0]\n    type = \"add\"\n    update = function (node) { return node.mark(mark.addToSet(node.marks)); }\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0]\n    type = \"remove\"\n    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); }\n  } else {\n    return null\n  }\n  var updated = []\n  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))) }\n  if (Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    { return false }\n\n  var $start = old.resolve(start)\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    { return false }\n  var $next = old.resolve(skipClosingAndOpening($start, true, true))\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    { return false }\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--\n    end++\n    fromEnd = false\n  }\n  if (mayOpen) {\n    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth))\n    while (next && !next.isLeaf) {\n      next = next.firstChild\n      end++\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferedStart) {\n  var start = a.findDiffStart(b, pos)\n  if (!start) { return null }\n  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  var endA = ref.a;\n  var endB = ref.b;\n  if (endA < start && a.size < b.size) {\n    var move = preferedStart <= start && preferedStart >= endA ? start - preferedStart : 0\n    start -= move\n    endB = start + (endB - endA)\n    endA = start\n  } else if (endB < start) {\n    var move$1 = preferedStart <= start && preferedStart >= endB ? start - preferedStart : 0\n    start -= move$1\n    endA = start + (endA - endB)\n    endB = start\n  }\n  return {start: start, endA: endA, endB: endB}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/domchange.js\n// module id = 157\n// module chunks = 1","function windowRect() {\n  return {left: 0, right: window.innerWidth,\n          top: 0, bottom: window.innerHeight}\n}\n\nfunction parentNode(node) {\n  var parent = node.parentNode\n  return parent.nodeType == 11 ? parent.host : parent\n}\n\nfunction scrollRectIntoView(view, rect) {\n  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\")\n  if (scrollMargin == null) { scrollMargin = 5 }\n  for (var parent = view.content;; parent = parentNode(parent)) {\n    var atBody = parent == document.body\n    var bounding = atBody ? windowRect() : parent.getBoundingClientRect()\n    var moveX = 0, moveY = 0\n    if (rect.top < bounding.top + scrollThreshold)\n      { moveY = -(bounding.top - rect.top + scrollMargin) }\n    else if (rect.bottom > bounding.bottom - scrollThreshold)\n      { moveY = rect.bottom - bounding.bottom + scrollMargin }\n    if (rect.left < bounding.left + scrollThreshold)\n      { moveX = -(bounding.left - rect.left + scrollMargin) }\n    else if (rect.right > bounding.right - scrollThreshold)\n      { moveX = rect.right - bounding.right + scrollMargin }\n    if (moveX || moveY) {\n      if (atBody) {\n        window.scrollBy(moveX, moveY)\n      } else {\n        if (moveY) { parent.scrollTop += moveY }\n        if (moveX) { parent.scrollLeft += moveX }\n      }\n    }\n    if (atBody) { break }\n  }\n}\nexports.scrollRectIntoView = scrollRectIntoView\n\nfunction findOffsetInNode(node, coords) {\n  var closest, dxClosest = 2e8, coordsClosest, offset = 0\n  var rowBot = coords.top, rowTop = coords.top\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = (void 0)\n    if (child.nodeType == 1) { rects = child.getClientRects() }\n    else if (child.nodeType == 3) { rects = textRange(child).getClientRects() }\n    else { continue }\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i]\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot)\n        rowTop = Math.min(rect.top, rowTop)\n        var dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0\n        if (dx < dxClosest) {\n          closest = child\n          dxClosest = dx\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords\n          if (child.nodeType == 1 && dx)\n            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) }\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        { offset = childIndex + 1 }\n    }\n  }\n  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }\n  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length\n  var range = document.createRange()\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1)\n    range.setStart(node, i)\n    var rect = singleRect(range, 1)\n    if (rect.top == rect.bottom) { continue }\n    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left &&\n        rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top)\n      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }\n  }\n  return {node: node, offset: 0}\n}\n\nfunction targetKludge(dom, coords) {\n  if (/^[uo]l$/i.test(dom.nodeName)) {\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      if (!child.pmViewDesc || !/^li$/i.test(child.nodeName)) { continue }\n      var childBox = child.getBoundingClientRect()\n      if (coords.left > childBox.left - 2) { break }\n      if (childBox.top <= coords.top && childBox.bottom >= coords.top) { return child }\n    }\n  }\n  return dom\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n  var elt = targetKludge(view.root.elementFromPoint(coords.left, coords.top + 1), coords)\n  if (!view.content.contains(elt.nodeType == 3 ? elt.parentNode : elt)) { return null }\n\n  var ref = findOffsetInNode(elt, coords);\n  var node = ref.node;\n  var offset = ref.offset;\n  var bias = -1\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect()\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1\n  }\n\n  var desc = view.docView.nearestDesc(elt, true)\n  return {pos: view.docView.posFromDOM(node, offset, bias),\n          inside: desc && (desc.posAtStart - desc.border)}\n}\nexports.posAtCoords = posAtCoords\n\nfunction textRange(node, from, to) {\n  var range = document.createRange()\n  range.setEnd(node, to == null ? node.nodeValue.length : to)\n  range.setStart(node, from || 0)\n  return range\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects()\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\n// : (ProseMirror, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos) {\n  var ref = view.docView.domFromPos(pos);\n  var node = ref.node;\n  var offset = ref.offset;\n  var side, rect\n  if (node.nodeType == 3) {\n    if (offset < node.nodeValue.length) {\n      rect = singleRect(textRange(node, offset, offset + 1), -1)\n      side = \"left\"\n    }\n    if ((!rect || rect.left == rect.right) && offset) {\n      rect = singleRect(textRange(node, offset - 1, offset), 1)\n      side = \"right\"\n    }\n  } else if (node.firstChild) {\n    if (offset < node.childNodes.length) {\n      var child = node.childNodes[offset]\n      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, -1)\n      side = \"left\"\n    }\n    if ((!rect || rect.top == rect.bottom) && offset) {\n      var child$1 = node.childNodes[offset - 1]\n      rect = singleRect(child$1.nodeType == 3 ? textRange(child$1) : child$1, 1)\n      side = \"right\"\n    }\n  } else {\n    rect = node.getBoundingClientRect()\n    side = \"left\"\n  }\n  var x = rect[side]\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\nexports.coordsAtPos = coordsAtPos\n\nfunction withFlushedState(view, state, f) {\n  var viewState = view.state, active = view.root.activeElement\n  if (viewState != state || !view.inDOMChange) { view.updateState(state) }\n  if (active != view.content) { view.focus() }\n  try {\n    return f()\n  } finally {\n    if (viewState != state) { view.updateState(viewState) }\n    if (active != view.content) { active.focus() }\n  }\n}\n\n// : (ProseMirror, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  var $pos = dir == \"up\" ? state.selection.$from : state.selection.$to\n  if (!$pos.depth) { return false }\n  return withFlushedState(view, state, function () {\n    var dom = view.docView.domAfterPos($pos.before())\n    var coords = coordsAtPos(view, $pos.pos)\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      var boxes = (void 0)\n      if (child.nodeType == 1) { boxes = child.getClientRects() }\n      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects() }\n      else { continue }\n      for (var i = 0; i < boxes.length; i++) {\n        var box = boxes[i]\n        if (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)\n          { return false }\n      }\n    }\n    return true\n  })\n}\n\nvar maybeRTL = /[\\u0590-\\u08ac]/\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  if (!empty || !$head.parent.isTextblock || !$head.depth) { return false }\n  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size\n  // If the textblock is all LTR and the cursor isn't at the sides, we don't need to touch the DOM\n  if (!atStart && !atEnd && !maybeRTL.test($head.parent.textContent)) { return false }\n  var sel = getSelection()\n  // Fall back to a primitive approach if the necessary selection method isn't supported (Edge)\n  if (!sel.modify) { return dir == \"left\" || dir == \"backward\" ? atStart : atEnd }\n\n  return withFlushedState(view, state, function () {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    var oldRange = sel.getRangeAt(0)\n    sel.modify(\"move\", dir, \"character\")\n    var parentDOM = view.docView.domAfterPos($head.before())\n    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        view.docView.posFromDOM(sel.focusNode, sel.focusOffset) == $head.pos\n    // Restore the previous selection\n    sel.removeAllRanges()\n    sel.addRange(oldRange)\n    return result\n  })\n}\n\nvar cachedState = null, cachedDir = null, cachedResult = false\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) { return cachedResult }\n  cachedState = state; cachedDir = dir\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\nexports.endOfTextblock = endOfTextblock\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/domcoords.js\n// module id = 158\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar Selection = ref.Selection;\nvar NodeSelection = ref.NodeSelection;\nvar TextSelection = ref.TextSelection;\n\nvar browser = require(\"./browser\")\nvar ref$1 = require(\"./capturekeys\");\nvar captureKeyDown = ref$1.captureKeyDown;\nvar ref$2 = require(\"./domchange\");\nvar DOMChange = ref$2.DOMChange;\nvar ref$3 = require(\"./clipboard\");\nvar fromClipboard = ref$3.fromClipboard;\nvar toClipboard = ref$3.toClipboard;\nvar canUpdateClipboard = ref$3.canUpdateClipboard;\nvar ref$4 = require(\"./trackmappings\");\nvar TrackMappings = ref$4.TrackMappings;\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nvar handlers = {}, editHandlers = {}\n\nfunction initInput(view) {\n  view.shiftKey = false\n  view.mouseDown = null\n  view.dragging = null\n  view.inDOMChange = null\n  view.mutationObserver = window.MutationObserver &&\n    new window.MutationObserver(function (mutations) { return registerMutations(view, mutations); })\n  startObserving(view)\n\n  var loop = function ( event ) {\n    var handler = handlers[event]\n    view.content.addEventListener(event, function (event) {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        { handler(view, event) }\n    })\n  };\n\n  for (var event in handlers) loop( event );\n  view.extraHandlers = Object.create(null)\n  ensureListeners(view)\n}\nexports.initInput = initInput\n\nfunction destroyInput(view) {\n  stopObserving(view)\n  if (view.inDOMChange) { view.inDOMChange.destroy() }\n  if (view.dragging) { view.dragging.destroy() }\n}\nexports.destroyInput = destroyInput\n\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", function (handlers) {\n    for (var type in handlers) { if (!view.extraHandlers[type] && !handlers.hasOwnProperty(type)) {\n      view.extraHandlers[type] = true\n      view.content.addEventListener(type, function (event) { return runCustomHandler(view, event); })\n    } }\n  })\n}\nexports.ensureListeners = ensureListeners\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", function (handlers) {\n    var handler = handlers[event.type]\n    return handler ? handler(view, event) : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) { return true }\n  if (event.defaultPrevented) { return false }\n  for (var node = event.target; node != view.content; node = node.parentNode)\n    { if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      { return false } }\n  return true\n}\n\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    { handlers[event.type](view, event) }\n}\nexports.dispatchEvent = dispatchEvent\n\neditHandlers.keydown = function (view, event) {\n  if (event.keyCode == 16) { view.shiftKey = true }\n  if (view.inDOMChange) { return }\n  if (view.someProp(\"handleKeyDown\", function (f) { return f(view, event); }) || captureKeyDown(view, event))\n    { event.preventDefault() }\n  else\n    { view.selectionReader.poll() }\n}\n\neditHandlers.keyup = function (view, e) {\n  if (e.keyCode == 16) { view.shiftKey = false }\n}\n\neditHandlers.keypress = function (view, event) {\n  if (view.inDOMChange || !event.charCode ||\n      event.ctrlKey && !event.altKey || browser.mac && event.metaKey) { return }\n\n  if (view.someProp(\"handleKeyPress\", function (f) { return f(view, event); })) {\n    event.preventDefault()\n    return\n  }\n\n  var ref = view.state.selection;\n  var node = ref.node;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (node || !$from.sameParent($to)) {\n    var text = String.fromCharCode(event.charCode)\n    if (!view.someProp(\"handleTextInput\", function (f) { return f(view, $from.pos, $to.pos, text); }))\n      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()) }\n    event.preventDefault()\n  }\n}\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nvar lastClick = {time: 0, x: 0, y: 0}, oneButLastClick = lastClick\n\nfunction isNear(event, click) {\n  var dx = click.x - event.clientX, dy = click.y - event.clientY\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside)\n  var loop = function ( i ) {\n    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))\n      { return { v: true } }\n  };\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  view.focus()\n  var tr = view.state.tr.setSelection(selection)\n  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true) }\n  view.dispatch(tr)\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter\n  if (node && node.isLeaf && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\")\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) { return false }\n  var ref = view.state.selection;\n  var selectedNode = ref.node;\n  var $from = ref.$from;\n  var selectAt\n\n  var $pos = view.state.doc.resolve(inside)\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    if (NodeSelection.isSelectable(node)) {\n     if (selectedNode && $from.depth > 0 &&\n          i >= $from.depth && $pos.before($from.depth + 1) == $from.pos)\n        { selectAt = $pos.before($from.depth) }\n      else\n        { selectAt = $pos.before(i) }\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\")\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", function (f) { return f(view, pos, event); }) ||\n    selectClickedLeaf(view, inside)\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", function (f) { return f(view, pos, event); })\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", function (f) { return f(view, pos, event); }) ||\n    defaultTripleClick(view, inside)\n}\n\nfunction defaultTripleClick(view, inside) {\n  var doc = view.state.doc\n  if (inside == -1) {\n    if (doc.isTextblock) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\")\n      return true\n    }\n    return false\n  }\n\n  var $pos = doc.resolve(inside)\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    var nodePos = $pos.before(i)\n    if (node.isTextblock)\n      { updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\") }\n    else if (NodeSelection.isSelectable(node))\n      { updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\") }\n    else\n      { continue }\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  if (!view.inDOMChange) { return false }\n  view.inDOMChange.finish(true)\n  return true\n}\n\nvar selectNodeModifier = browser.mac ? \"metaKey\" : \"ctrlKey\"\n\nhandlers.mousedown = function (view, event) {\n  var flushed = forceDOMFlush(view)\n  var now = Date.now(), type\n  if (now - lastClick.time >= 500 || !isNear(event, lastClick) || event[selectNodeModifier]) { type = \"singleClick\" }\n  else if (now - oneButLastClick.time >= 600 || !isNear(event, oneButLastClick)) { type = \"doubleClick\" }\n  else { type = \"tripleClick\" }\n  oneButLastClick = lastClick\n  lastClick = {time: now, x: event.clientX, y: event.clientY}\n\n  var pos = view.posAtCoords(eventCoords(event))\n  if (!pos) { return }\n\n  if (type == \"singleClick\")\n    { view.mouseDown = new MouseDown(view, pos, event, flushed) }\n  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n    { event.preventDefault() }\n  else\n    { view.selectionReader.poll(\"pointer\") }\n}\n\nvar MouseDown = function(view, pos, event, flushed) {\n  var this$1 = this;\n\n  this.view = view\n  this.pos = pos\n  this.flushed = flushed\n  this.selectNode = event[selectNodeModifier]\n  this.allowDefault = event.shiftKey\n\n  var targetNode, targetPos\n  if (pos.inside > -1) {\n    targetNode = view.state.doc.nodeAt(pos.inside)\n    targetPos = pos.inside\n  } else {\n    var $pos = view.state.doc.resolve(pos.pos)\n    targetNode = $pos.parent\n    targetPos = $pos.depth ? $pos.before() : 0\n  }\n\n  this.mightDrag = (targetNode.type.spec.draggable || targetNode == view.state.selection.node) ? {node: targetNode, pos: targetPos} : null\n  this.target = flushed ? null : event.target\n  if (this.target && this.mightDrag) {\n    stopObserving(this.view)\n    this.target.draggable = true\n    if (browser.gecko && (this.setContentEditable = !this.target.hasAttribute(\"contentEditable\")))\n      { setTimeout(function () { return this$1.target.setAttribute(\"contentEditable\", \"false\"); }, 20) }\n    startObserving(this.view)\n  }\n\n  view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this))\n  view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this))\n  view.selectionReader.poll(\"pointer\")\n};\n\nMouseDown.prototype.done = function () {\n  this.view.root.removeEventListener(\"mouseup\", this.up)\n  this.view.root.removeEventListener(\"mousemove\", this.move)\n  if (this.mightDrag && this.target) {\n    stopObserving(this.view)\n    this.target.draggable = false\n    if (browser.gecko && this.setContentEditable)\n      { this.target.removeAttribute(\"contentEditable\") }\n    startObserving(this.view)\n  }\n};\n\nMouseDown.prototype.up = function (event) {\n  this.done()\n\n  if (!this.view.content.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n    { return }\n\n  if (this.allowDefault) {\n    this.view.selectionReader.poll(\"pointer\")\n  } else if (this.selectNode\n             ? selectClickedNode(this.view, this.pos.inside)\n             : handleSingleClick(this.view, this.pos.pos, this.pos.inside, event)) {\n    event.preventDefault()\n  } else if (this.flushed) {\n    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(this.pos.pos)), \"pointer\")\n    event.preventDefault()\n  } else {\n    this.view.selectionReader.poll(\"pointer\")\n  }\n};\n\nMouseDown.prototype.move = function (event) {\n  if (!this.allowDefault && (Math.abs(this.x - event.clientX) > 4 ||\n                             Math.abs(this.y - event.clientY) > 4))\n    { this.allowDefault = true }\n  this.view.selectionReader.poll(\"pointer\")\n};\n\nhandlers.touchdown = function (view) {\n  forceDOMFlush(view)\n  view.selectionReader.poll(\"pointer\")\n}\n\nhandlers.contextmenu = function (view, e) {\n  forceDOMFlush(view)\n  var pos = view.posAtCoords(eventCoords(e))\n  if (pos && view.someProp(\"handleContextMenu\", function (f) { return f(view, pos.pos, e); }))\n    { e.preventDefault() }\n}\n\n// Input compositions are hard. Mostly because the events fired by\n// browsers are A) very unpredictable and inconsistent, and B) not\n// cancelable.\n//\n// ProseMirror has the problem that it must not update the DOM during\n// a composition, or the browser will cancel it. What it does is keep\n// long-running operations (delayed DOM updates) when a composition is\n// active.\n//\n// We _do not_ trust the information in the composition events which,\n// apart from being very uninformative to begin with, is often just\n// plain wrong. Instead, when a composition ends, we parse the dom\n// around the original selection, and derive an update from that.\n\neditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n  DOMChange.start(view, true)\n  if (view.state.storedMarks) { view.inDOMChange.finish(true) }\n}\n\neditHandlers.compositionend = function (view, e) {\n  if (!view.inDOMChange) {\n    // We received a compositionend without having seen any previous\n    // events for the composition. If there's data in the event\n    // object, we assume that it's a real change, and start a\n    // composition. Otherwise, we just ignore it.\n    if (e.data) { DOMChange.start(view, true) }\n    else { return }\n  }\n\n  view.inDOMChange.compositionEnd()\n}\n\nvar observeOptions = {childList: true, characterData: true, attributes: true, subtree: true}\nfunction startObserving(view) {\n  if (view.mutationObserver) { view.mutationObserver.observe(view.content, observeOptions) }\n}\nexports.startObserving = startObserving\n\nfunction stopObserving(view) {\n  if (view.mutationObserver) { view.mutationObserver.disconnect() }\n}\nexports.stopObserving = stopObserving\n\nfunction registerMutations(view, mutations) {\n  if (view.editable) { for (var i = 0; i < mutations.length; i++) {\n    var mut = mutations[i], desc = view.docView.nearestDesc(mut.target)\n    if (mut.type == \"attributes\" &&\n        (desc == view.docView || mut.attributeName == \"contenteditable\")) { continue }\n    if (!desc || desc.ignoreMutation(mut)) { continue }\n\n    var from = (void 0), to = (void 0)\n    if (mut.type == \"childList\") {\n      var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target\n          ? Array.prototype.indexOf.call(mut.target.childNodes, desc.previousSibling) + 1 : 0\n      from = desc.localPosFromDOM(mut.target, fromOffset, -1)\n      var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target\n          ? Array.prototype.indexOf.call(mut.target.childNodes, desc.nextSibling) : mut.target.childNodes.length\n      to = desc.localPosFromDOM(mut.target, toOffset, 1)\n    } else if (mut.type == \"attributes\") {\n      from = desc.posAtStart - desc.border\n      to = desc.posAtEnd + desc.border\n    } else { // \"characterData\"\n      from = desc.posAtStart\n      to = desc.posAtEnd\n    }\n\n    DOMChange.start(view)\n    view.inDOMChange.addRange(from, to)\n  } }\n}\n\neditHandlers.input = function (view) { return DOMChange.start(view); }\n\nhandlers.copy = editHandlers.cut = function (view, e) {\n  var sel = view.state.selection, cut = e.type == \"cut\"\n  if (sel.empty) { return }\n  if (!e.clipboardData || !canUpdateClipboard(e.clipboardData)) {\n    if (cut && browser.ie && browser.ie_version <= 11) { DOMChange.start(view) }\n    return\n  }\n  toClipboard(view, sel, e.clipboardData)\n  e.preventDefault()\n  if (cut) { view.dispatch(view.state.tr.deleteRange(sel.from, sel.to).scrollIntoView()) }\n}\n\nfunction sliceSingleNode(slice) {\n  return slice.openLeft == 0 && slice.openRight == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\neditHandlers.paste = function (view, e) {\n  if (!e.clipboardData) {\n    if (browser.ie && browser.ie_version <= 11) { DOMChange.start(view) }\n    return\n  }\n  var slice = fromClipboard(view, e.clipboardData, view.shiftKey, view.state.selection.$from)\n  if (slice) {\n    e.preventDefault()\n    view.someProp(\"transformPasted\", function (f) { slice = f(slice) })\n    var singleNode = sliceSingleNode(slice)\n    var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode) : view.state.tr.replaceSelection(slice)\n    view.dispatch(tr.scrollIntoView())\n  }\n}\n\nvar Dragging = function(state, slice, range, move) {\n  this.slice = slice\n  this.range = range\n  this.move = move && new TrackMappings(state)\n};\n\nDragging.prototype.destroy = function () {\n  if (this.move) { this.move.destroy() }\n};\n\nfunction clearDragging(view) {\n  if (view.dragging) {\n    view.dragging.destroy()\n    view.dragging = null\n  }\n}\n\nfunction dropPos(slice, $pos) {\n  if (!slice || !slice.content.size) { return $pos.pos }\n  var content = slice.content\n  for (var i = 0; i < slice.openLeft; i++) { content = content.firstChild.content }\n  for (var d = $pos.depth; d >= 0; d--) {\n    var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n    if ($pos.node(d).canReplace(insertPos, insertPos, content))\n      { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n  }\n  return $pos.pos\n}\n\nhandlers.dragstart = function (view, e) {\n  var mouseDown = view.mouseDown\n  if (mouseDown) { mouseDown.done() }\n  if (!e.dataTransfer) { return }\n\n  var sel = view.state.selection, draggedRange\n  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e))\n  if (pos != null && pos.pos >= sel.from && pos.pos <= sel.to)\n    { draggedRange = sel }\n  else if (mouseDown && mouseDown.mightDrag)\n    { draggedRange = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos) }\n\n  if (draggedRange) {\n    var slice = toClipboard(view, draggedRange, e.dataTransfer)\n    view.dragging = new Dragging(view.state, slice, draggedRange, !e.ctrlKey)\n  }\n}\n\nhandlers.dragend = function (view) {\n  window.setTimeout(function () { return clearDragging(view); }, 50)\n}\n\neditHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); }\n\neditHandlers.drop = function (view, e) {\n  var dragging = view.dragging\n  clearDragging(view)\n\n  if (!e.dataTransfer) { return }\n\n  var $mouse = view.state.doc.resolve(view.posAtCoords(eventCoords(e)).pos)\n  if (!$mouse) { return }\n  var slice = dragging && dragging.slice || fromClipboard(view, e.dataTransfer, false, $mouse)\n  if (!slice) { return }\n  var insertPos = dropPos(slice, view.state.doc.resolve($mouse.pos))\n\n  e.preventDefault()\n  var tr = view.state.tr\n  if (dragging && dragging.move) {\n    var ref = dragging.range;\n    var from = ref.from;\n    var to = ref.to;\n    var mapping = dragging.move.getMapping(view.state)\n    if (mapping) { tr.deleteRange(mapping.map(from, 1), mapping.map(to, -1)) }\n  }\n  view.someProp(\"transformPasted\", function (f) { slice = f(slice) })\n  var pos = tr.mapping.map(insertPos)\n  var isNode = slice.openLeft == 0 && slice.openRight == 0 && slice.content.childCount == 1\n  if (isNode)\n    { tr.replaceRangeWith(pos, pos, slice.content.firstChild) }\n  else\n    { tr.replaceRange(pos, pos, slice) }\n  var $pos = tr.doc.resolve(pos)\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild))\n    { tr.setSelection(new NodeSelection($pos)) }\n  else\n    { tr.setSelection(Selection.between($pos, tr.doc.resolve(tr.mapping.map(insertPos)))) }\n  view.focus()\n  view.dispatch(tr)\n}\n\nhandlers.focus = function (view, event) {\n  if (!view.focused) {\n    view.content.classList.add(\"ProseMirror-focused\")\n    view.focused = true\n  }\n  view.someProp(\"onFocus\", function (f) { f(view, event) })\n}\n\nhandlers.blur = function (view, event) {\n  if (view.focused) {\n    view.content.classList.remove(\"ProseMirror-focused\")\n    view.focused = false\n  }\n  view.someProp(\"onBlur\", function (f) { f(view, event) })\n}\n\n// Make sure all handlers get registered\nfor (var prop in editHandlers) { handlers[prop] = editHandlers[prop] }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/input.js\n// module id = 159\n// module chunks = 1","var ref = require(\"prosemirror-state\");\nvar Selection = ref.Selection;\nvar NodeSelection = ref.NodeSelection;\n\nvar browser = require(\"./browser\")\n\n// Track the state of the current editor selection. Keeps the editor\n// selection in sync with the DOM selection by polling for changes,\n// as there is no DOM event for DOM selection changes.\nvar SelectionReader = function(view) {\n  var this$1 = this;\n\n  this.view = view\n\n  // Track the state of the DOM selection.\n  this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null\n  this.lastSelection = view.state.selection\n  this.poller = poller(this)\n\n  view.content.addEventListener(\"focus\", function () { return this$1.poller.start(); })\n  view.content.addEventListener(\"blur\", function () { return this$1.poller.stop(); })\n\n  if (!view.editable) { this.poller.start() }\n};\n\nSelectionReader.prototype.destroy = function () { this.poller.stop() };\n\nSelectionReader.prototype.poll = function (origin) { this.poller.poll(origin) };\n\nSelectionReader.prototype.editableChanged = function () {\n  if (!this.view.editable) { this.poller.start() }\n  else if (!this.view.hasFocus()) { this.poller.stop() }\n};\n\n// : () → bool\n// Whether the DOM selection has changed from the last known state.\nSelectionReader.prototype.domChanged = function () {\n  var sel = this.view.root.getSelection()\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset\n};\n\n// Store the current state of the DOM selection.\nSelectionReader.prototype.storeDOMState = function (selection) {\n  var sel = this.view.root.getSelection()\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset\n  this.lastHeadNode = sel.focusNode; this.lastHeadOffset = sel.focusOffset\n  this.lastSelection = selection\n};\n\n// : (?string) → bool\n// When the DOM selection changes in a notable manner, modify the\n// current selection state to match.\nSelectionReader.prototype.readFromDOM = function (origin) {\n  if (!this.view.hasFocus() || this.view.inDOMChange || !this.domChanged()) { return }\n\n  var domSel = this.view.root.getSelection(), doc = this.view.state.doc\n  var nearestDesc = this.view.docView.nearestDesc(domSel.focusNode)\n  // If the selection is in a non-document part of the view, ignore it\n  if (!nearestDesc.size) {\n    this.storeDOMState()\n    return\n  }\n  var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)\n  var $head = doc.resolve(head), $anchor, selection\n  if (domSel.isCollapsed) {\n    $anchor = $head\n    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent }\n    if (nearestDesc && nearestDesc.node.isLeaf && NodeSelection.isSelectable(nearestDesc.node)) {\n      var pos = nearestDesc.posAtStart\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos))\n    }\n  } else {\n    $anchor = doc.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset))\n  }\n\n  if (!selection) {\n    var bias = this.view.state.selection.head != null && this.view.state.selection.head < $head.pos ? 1 : -1\n    selection = Selection.between($anchor, $head, bias)\n    if (bias == -1 && selection.node)\n      { selection = Selection.between($anchor, $head, 1) }\n  }\n  if ($head.pos == selection.head && $anchor.pos == selection.anchor)\n    { this.storeDOMState(selection) }\n  var tr = this.view.state.tr.setSelection(selection)\n  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true) }\n  this.view.dispatch(tr)\n};\nexports.SelectionReader = SelectionReader\n\n// There's two polling models. On browsers that support the\n// selectionchange event (everything except Firefox, basically), we\n// register a listener for that whenever the editor is focused.\nvar SelectionChangePoller = function(reader) {\n  var this$1 = this;\n\n  this.listening = false\n  this.curOrigin = null\n  this.originTime = 0\n\n  this.readFunc = function () { return reader.readFromDOM(this$1.originTime > Date.now() - 50 ? this$1.curOrigin : null); }\n};\n\nSelectionChangePoller.prototype.poll = function (origin) {\n  this.curOrigin = origin\n  this.originTime = Date.now()\n};\n\nSelectionChangePoller.prototype.start = function () {\n  if (!this.listening) {\n    document.addEventListener(\"selectionchange\", this.readFunc)\n    this.listening = true\n  }\n};\n\nSelectionChangePoller.prototype.stop = function () {\n  if (this.listening) {\n    document.removeEventListener(\"selectionchange\", this.readFunc)\n    this.listening = false\n  }\n};\n\n// On Firefox, we use timeout-based polling.\nvar TimeoutPoller = function(reader) {\n  // The timeout ID for the poller when active.\n  this.polling = null\n  this.reader = reader\n  this.pollFunc = this.doPoll.bind(this, null)\n};\n\nTimeoutPoller.prototype.doPoll = function (origin) {\n  var view = this.reader.view\n  if (view.focused || !view.editable) {\n    this.reader.readFromDOM(origin)\n    this.polling = setTimeout(this.pollFunc, 100)\n  } else {\n    this.polling = null\n  }\n};\n\nTimeoutPoller.prototype.poll = function (origin) {\n  clearTimeout(this.polling)\n  this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0)\n};\n\nTimeoutPoller.prototype.start = function () {\n  if (this.polling == null) { this.poll() }\n};\n\nTimeoutPoller.prototype.stop = function () {\n  clearTimeout(this.polling)\n  this.polling = null\n};\n\nfunction poller(reader) {\n  return new (\"onselectionchange\" in document ? SelectionChangePoller : TimeoutPoller)(reader)\n}\n\nfunction selectionToDOM(view, sel, takeFocus) {\n  syncNodeSelection(view, sel)\n\n  if (!view.hasFocus()) {\n    if (!takeFocus) { return }\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n    else if (browser.gecko && view.editable) { view.content.focus() }\n  }\n\n  var reader = view.selectionReader\n  if (sel == reader.lastSelection && !reader.domChanged()) { return }\n  var anchor = sel.anchor;\n  var head = sel.head;\n  var resetEditable\n  if (anchor == null) {\n    anchor = sel.from\n    head = sel.to\n    if (browser.webkit && sel.node.isBlock) {\n      var desc = view.docView.descAt(sel.from)\n      if (!desc.contentDOM && desc.dom.contentEditable == \"false\") {\n        resetEditable = desc.dom\n        desc.dom.contentEditable = \"true\"\n      }\n    }\n  }\n  view.docView.setSelection(anchor, head, view.root)\n  if (resetEditable) { resetEditable.contentEditable = \"false\" }\n  reader.storeDOMState(sel)\n}\nexports.selectionToDOM = selectionToDOM\n\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    var desc = view.docView.descAt(sel.from)\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view)\n      if (desc) { desc.selectNode() }\n      view.lastSelectedViewDesc = desc\n    }\n  } else {\n    clearNodeSelection(view)\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    view.lastSelectedViewDesc.deselectNode()\n    view.lastSelectedViewDesc = null\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/selection.js\n// module id = 160\n// module chunks = 1","var ref = require(\"prosemirror-model\");\nvar DOMSerializer = ref.DOMSerializer;\n\nvar browser = require(\"./browser\")\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#view.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, when you need more control over\n// the behavior of a node's in-editor representation, and can\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration]) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), and an\n//   array of active decorations (which are automatically drawn, and\n//   the node view may ignore if it isn't interested in them), and\n//   should return true if it was able to update to that node, and\n//   false otherwise. If the node view has a `contentDOM` property (or\n//   no `dom` property), updating its child nodes will be handled by\n//   ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to disable it again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. By default, a DOM selection will be created between the DOM\n//   positions corresponding to the given anchor and head positions,\n//   but if you override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   happens within the view. Return false if the editor should\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is detached.\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nvar NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nvar ViewDesc = function(parent, children, dom, contentDOM) {\n  this.parent = parent\n  this.children = children\n  this.dom = dom\n  // An expando property on the DOM node provides a link back to its\n  // description.\n  dom.pmViewDesc = this\n  // This is the node that holds the child views. It may be null for\n  // descs that don't have children.\n  this.contentDOM = contentDOM\n  this.dirty = NOT_DIRTY\n};\n\nvar prototypeAccessors = { size: {},border: {},posAtStart: {},posAtEnd: {} };\n\n// Used to check whether a given description corresponds to a\n// widget/mark/node.\nViewDesc.prototype.matchesWidget = function () { return false };\nViewDesc.prototype.matchesMark = function () { return false };\nViewDesc.prototype.matchesNode = function () { return false };\nViewDesc.prototype.matchesHack = function () { return false };\n\n// : () → ?ParseRule\n// When parsing in-editor content (in domchange.js), we allow\n// descriptions to determine the parse rules that should be used to\n// parse them.\nViewDesc.prototype.parseRule = function () { return null };\n\n// : (dom.Event) → bool\n// Used by the editor's event handler to ignore events that come\n// from certain descs.\nViewDesc.prototype.stopEvent = function () { return false };\n\n// The size of the content represented by this desc.\nprototypeAccessors.size.get = function () {\n    var this$1 = this;\n\n  var size = 0\n  for (var i = 0; i < this.children.length; i++) { size += this$1.children[i].size }\n  return size\n};\n\n// For block nodes, this represents the space taken up by their\n// start/end tokens.\nprototypeAccessors.border.get = function () { return 0 };\n\nViewDesc.prototype.destroy = function () {\n    var this$1 = this;\n\n  this.parent = this.dom.pmViewDesc = null\n  for (var i = 0; i < this.children.length; i++)\n    { this$1.children[i].destroy() }\n};\n\nViewDesc.prototype.posBeforeChild = function (child) {\n    var this$1 = this;\n\n  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n    var cur = this$1.children[i]\n    if (cur == child) { return pos }\n    pos += cur.size\n  }\n};\n\nprototypeAccessors.posAtStart.get = function () {\n  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n};\n\nprototypeAccessors.posAtEnd.get = function () {\n  return this.posAtStart + this.size - 2 * this.border\n};\n\n// : (dom.Node, number, ?number) → number\nViewDesc.prototype.localPosFromDOM = function (dom, offset, bias) {\n    var this$1 = this;\n\n  // If the DOM position is in the content, use the child desc after\n  // it to figure out a position.\n  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n    if (bias < 0) {\n      var domBefore, desc\n      if (dom == this.contentDOM) {\n        domBefore = dom.childNodes[offset - 1]\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode }\n        domBefore = dom.previousSibling\n      }\n      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling }\n      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n    } else {\n      var domAfter, desc$1\n      if (dom == this.contentDOM) {\n        domAfter = dom.childNodes[offset]\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode }\n        domAfter = dom.nextSibling\n      }\n      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling }\n      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd\n    }\n  }\n  // Otherwise, use various heuristics, falling back on the bias\n  // parameter, to determine whether to return the position at the\n  // start or at the end of this view desc.\n  var atEnd\n  if (this.contentDOM) {\n    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2\n  } else if (this.dom.firstChild) {\n    if (offset == 0) { for (var search = dom;; search = search.parentNode) {\n      if (search == this$1.dom) { atEnd = false; break }\n      if (search.parentNode.firstChild != search) { break }\n    } }\n    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {\n      if (search$1 == this$1.dom) { atEnd = true; break }\n      if (search$1.parentNode.lastChild != search$1) { break }\n    } }\n  }\n  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n};\n\n// Scan up the dom finding the first desc that is a descendant of\n// this one.\nViewDesc.prototype.nearestDesc = function (dom, onlyNodes) {\n    var this$1 = this;\n\n  for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n    var desc = this$1.getDesc(cur)\n    if (desc && (!onlyNodes || desc.node)) {\n      if (first && desc.nodeDOM && !desc.nodeDOM.contains(dom)) { first = false }\n      else { return desc }\n    }\n  }\n};\n\nViewDesc.prototype.getDesc = function (dom) {\n    var this$1 = this;\n\n  var desc = dom.pmViewDesc\n  for (var cur = desc; cur; cur = cur.parent) { if (cur == this$1) { return desc } }\n};\n\nViewDesc.prototype.posFromDOM = function (dom, offset, bias) {\n    var this$1 = this;\n\n  for (var scan = dom;; scan = scan.parentNode) {\n    var desc = this$1.getDesc(scan)\n    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }\n  }\n};\n\n// : (number) → ?NodeViewDesc\n// Find the desc for the node after the given pos, if any. (When a\n// parent node overrode rendering, there might not be one.)\nViewDesc.prototype.descAt = function (pos) {\n    var this$1 = this;\n\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size\n    if (offset == pos && end != offset) {\n      while (!child.border && child.children.length) { child = child.children[0] }\n      return child\n    }\n    if (pos < end) { return child.descAt(pos - offset - child.border) }\n    offset = end\n  }\n};\n\n// : (number, ?bool) → {node: dom.Node, offset: number}\nViewDesc.prototype.domFromPos = function (pos, searchDOM) {\n    var this$1 = this;\n\n  if (!this.contentDOM) { return {node: this.dom, offset: 0} }\n  for (var offset = 0, i = 0;; i++) {\n    if (offset == pos)\n      { return {node: this$1.contentDOM,\n              offset: searchDOM ? this$1.findDOMOffset(i, searchDOM) : i} }\n    if (i == this$1.children.length) { throw new Error(\"Invalid position \" + pos) }\n    var child = this$1.children[i], end = offset + child.size\n    if (pos < end) { return child.domFromPos(pos - offset - child.border, searchDOM) }\n    offset = end\n  }\n};\n\n// If the DOM was directly edited, we can't trust the child view\n// desc offsets anymore, so we search the actual DOM to figure out\n// the offset that corresponds to a given child.\nViewDesc.prototype.findDOMOffset = function (i, searchDOM) {\n    var this$1 = this;\n\n  var content = this.contentDOM\n  if (searchDOM < 0) {\n    for (var j = i - 1; j >= 0; j--) {\n      var child = this$1.children[j]\n      if (!child.size) { continue }\n      var found = Array.prototype.indexOf.call(content.childNodes, child.dom)\n      if (found > -1) { return found + 1 }\n    }\n    return 0\n  } else {\n    for (var j$1 = i; j$1 < this.children.length; j$1++) {\n      var child$1 = this$1.children[j$1]\n      if (!child$1.size) { continue }\n      var found$1 = Array.prototype.indexOf.call(content.childNodes, child$1.dom)\n      if (found$1 > -1) { return found$1 }\n    }\n    return content.childNodes.length\n  }\n};\n\n// : (number) → dom.Node\nViewDesc.prototype.domAfterPos = function (pos) {\n  var ref = this.domFromPos(pos);\n    var node = ref.node;\n    var offset = ref.offset;\n  if (node.nodeType != 1 || offset == node.childNodes.length)\n    { throw new RangeError(\"No node after pos \" + pos) }\n  return node.childNodes[offset]\n};\n\n// : (number, number, dom.Document)\n// View descs are responsible for setting any selection that falls\n// entirely inside of them, so that custom implementations can do\n// custom things with the selection. Note that this falls apart when\n// a selection starts in such a node and ends in another, in which\n// case we just use whatever domFromPos produces as a best effort.\nViewDesc.prototype.setSelection = function (anchor, head, root) {\n    var this$1 = this;\n\n  // If the selection falls entirely in a child, give it to that child\n  var from = Math.min(anchor, head), to = Math.max(anchor, head)\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size\n    if (from > offset && to < end)\n      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root) }\n    offset = end\n  }\n\n  var anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head)\n  var domSel = root.getSelection(), range = document.createRange()\n\n  // Selection.extend can be used to create an 'inverted' selection\n  // (one where the focus is before the anchor), but not all\n  // browsers support it yet.\n  if (domSel.extend) {\n    range.setEnd(anchorDOM.node, anchorDOM.offset)\n    range.collapse(false)\n  } else {\n    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp }\n    range.setEnd(headDOM.node, headDOM.offset)\n    range.setStart(anchorDOM.node, anchorDOM.offset)\n  }\n  domSel.removeAllRanges()\n  domSel.addRange(range)\n  if (domSel.extend)\n    { domSel.extend(headDOM.node, headDOM.offset) }\n};\n\n// : (dom.MutationRecord) → bool\nViewDesc.prototype.ignoreMutation = function (_mutation) {\n  return !this.contentDOM\n};\n\n// Remove a subtree of the element tree that has been touched\n// by a DOM change, so that the next update will redraw it.\nViewDesc.prototype.markDirty = function (from, to) {\n    var this$1 = this;\n\n  for (var offset = 0, i = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size\n    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n      var startInside = offset + child.border, endInside = end - child.border\n      if (from >= startInside && to <= endInside) {\n        this$1.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY\n        child.markDirty(from - startInside, to - startInside)\n        return\n      } else {\n        child.dirty = NODE_DIRTY\n      }\n    }\n    offset = end\n  }\n  this.dirty = CONTENT_DIRTY\n};\n\nObject.defineProperties( ViewDesc.prototype, prototypeAccessors );\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nvar nothing = []\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nvar WidgetViewDesc = (function (ViewDesc) {\n  function WidgetViewDesc(parent, widget) {\n    ViewDesc.call(this, parent, nothing, widget.type.widget, null)\n    this.widget = widget\n  }\n\n  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;\n  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  WidgetViewDesc.prototype.constructor = WidgetViewDesc;\n\n  WidgetViewDesc.prototype.matchesWidget = function (widget) { return this.dirty == NOT_DIRTY && widget.type == this.widget.type };\n\n  WidgetViewDesc.prototype.parseRule = function () { return {ignore: true} };\n\n  WidgetViewDesc.prototype.stopEvent = function (event) {\n    var stop = this.widget.type.options.stopEvent\n    return stop ? stop(event) : false\n  };\n\n  return WidgetViewDesc;\n}(ViewDesc));\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nvar MarkViewDesc = (function (ViewDesc) {\n  function MarkViewDesc(parent, mark, dom) {\n    ViewDesc.call(this, parent, [], dom, dom)\n    this.mark = mark\n  }\n\n  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;\n  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  MarkViewDesc.prototype.constructor = MarkViewDesc;\n\n  MarkViewDesc.create = function (parent, mark, view) {\n    var custom = customNodeViews(view)[mark.type.name]\n    var spec = custom && custom(mark, view)\n    var dom = spec && spec.dom || DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark)).dom\n    return new MarkViewDesc(parent, mark, dom)\n  };\n\n  MarkViewDesc.prototype.parseRule = function () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };\n\n  MarkViewDesc.prototype.matchesMark = function (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };\n\n  return MarkViewDesc;\n}(ViewDesc));\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nvar NodeViewDesc = (function (ViewDesc) {\n  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view) {\n    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM)\n    this.nodeDOM = nodeDOM\n    this.node = node\n    this.outerDeco = outerDeco\n    this.innerDeco = innerDeco\n    if (contentDOM) { this.updateChildren(view) }\n  }\n\n  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;\n  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  NodeViewDesc.prototype.constructor = NodeViewDesc;\n\n  var prototypeAccessors$1 = { size: {},border: {} };\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finnicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  NodeViewDesc.create = function (parent, node, outerDeco, innerDeco, view) {\n    var custom = customNodeViews(view)[node.type.name], descObj\n    var spec = custom && custom(node, view, function () {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (descObj && descObj.parent) { return descObj.parent.posBeforeChild(descObj) }\n    }, outerDeco)\n\n    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM\n    if (!dom) { var assign;\n      ((assign = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM)) }\n    if (!contentDOM && !node.isText) { dom.contentEditable = false }\n\n    var nodeDOM = dom\n    dom = applyOuterDeco(dom, outerDeco, node)\n\n    if (spec)\n      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) }\n    else if (node.isText)\n      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }\n    else\n      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view) }\n  };\n\n  NodeViewDesc.prototype.parseRule = function () { return {node: this.node.type.name, attrs: this.node.attrs, contentElement: this.contentDOM} };\n\n  NodeViewDesc.prototype.matchesNode = function (node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  };\n\n  prototypeAccessors$1.size.get = function () { return this.node.nodeSize };\n\n  prototypeAccessors$1.border.get = function () { return this.node.isLeaf ? 0 : 1 };\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  NodeViewDesc.prototype.updateChildren = function (view) {\n    var this$1 = this;\n\n    var updater = new ViewTreeUpdater(this)\n    iterDeco(this.node, this.innerDeco, function (widget) {\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget)\n    }, function (child, outerDeco, innerDeco, i) {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, view)\n      // Either find an existing desc that exactly matches this node,\n      // and drop the descs before it.\n      updater.findNodeMatch(child, outerDeco, innerDeco) ||\n        // Or try updating the next desc to reflect this node.\n        updater.updateNextNode(child, outerDeco, innerDeco, view, this$1.node.content, i) ||\n        // Or just add it as a new desc.\n        updater.addNode(child, outerDeco, innerDeco, view)\n    })\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, view)\n    if (this.node.isTextblock) { updater.addTextblockHacks() }\n    updater.destroyRest()\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) { this.renderChildren() }\n  };\n\n  NodeViewDesc.prototype.renderChildren = function () {\n    renderDescs(this.contentDOM, this.children, NodeViewDesc.is)\n    if (browser.ios) { iosHacks(this.dom) }\n  };\n\n  // : (Node, [Decoration], DecorationSet, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  NodeViewDesc.prototype.update = function (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateOuterDeco(outerDeco)\n    this.node = node\n    this.innerDeco = innerDeco\n    if (!node.isLeaf) { this.updateChildren(view) }\n    this.dirty = NOT_DIRTY\n    return true\n  };\n\n  NodeViewDesc.prototype.updateOuterDeco = function (outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }\n    var needsWrap = this.nodeDOM.nodeType != 1\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap))\n    this.outerDeco = outerDeco\n  };\n\n  // Mark this node as being the selected node.\n  NodeViewDesc.prototype.selectNode = function () {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\")\n  };\n\n  // Remove selected node marking from this node.\n  NodeViewDesc.prototype.deselectNode = function () {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\")\n  };\n\n  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$1 );\n\n  return NodeViewDesc;\n}(ViewDesc));\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc, true)\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view)\n}\nexports.docViewDesc = docViewDesc\n\nvar TextViewDesc = (function (NodeViewDesc) {\n  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view)\n  }\n\n  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;\n  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  TextViewDesc.prototype.constructor = TextViewDesc;\n\n  TextViewDesc.prototype.parseRule = function () {\n    return {skip: this.nodeDOM.parentNode}\n  };\n\n  TextViewDesc.prototype.update = function (node, outerDeco) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent) ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateOuterDeco(outerDeco)\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue)\n      { this.nodeDOM.nodeValue = node.text }\n    this.node = node\n    this.dirty = NOT_DIRTY\n    return true\n  };\n\n  TextViewDesc.prototype.inParent = function () {\n    var parentDOM = this.parent.contentDOM\n    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }\n    return false\n  };\n\n  TextViewDesc.prototype.domFromPos = function (pos, searchDOM) {\n    return {node: this.nodeDOM, offset: searchDOM ? Math.max(pos, this.nodeDOM.nodeValue.length) : pos}\n  };\n\n  TextViewDesc.prototype.localPosFromDOM = function (dom, offset, bias) {\n    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }\n    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)\n  };\n\n  TextViewDesc.prototype.ignoreMutation = function (mutation) {\n    return mutation.type != \"characterData\"\n  };\n\n  return TextViewDesc;\n}(NodeViewDesc));\n\n// A dummy desc used to tag trailing BR or span nodes created to work\n// around contentEditable terribleness.\nvar BRHackViewDesc = (function (ViewDesc) {\n  function BRHackViewDesc () {\n    ViewDesc.apply(this, arguments);\n  }\n\n  if ( ViewDesc ) BRHackViewDesc.__proto__ = ViewDesc;\n  BRHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  BRHackViewDesc.prototype.constructor = BRHackViewDesc;\n\n  BRHackViewDesc.prototype.parseRule = function () { return {ignore: true} };\n  BRHackViewDesc.prototype.matchesHack = function () { return this.dirty == NOT_DIRTY };\n\n  return BRHackViewDesc;\n}(ViewDesc));\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nvar CustomNodeViewDesc = (function (NodeViewDesc) {\n  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view)\n    this.spec = spec\n  }\n\n  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;\n  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  CustomNodeViewDesc.prototype.update = function (node, outerDeco, innerDeco, view) {\n    if (this.spec.update) {\n      var result = this.spec.update(node, outerDeco)\n      if (result) {\n        this.node = node\n        if (this.contentDOM) { this.updateChildren(view) }\n      }\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return NodeViewDesc.prototype.update.call(this, node, outerDeco, this.contentDOM ? this.innerDeco : innerDeco, view)\n    }\n  };\n\n  CustomNodeViewDesc.prototype.selectNode = function () {\n    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this)\n  };\n\n  CustomNodeViewDesc.prototype.deselectNode = function () {\n    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this)\n  };\n\n  CustomNodeViewDesc.prototype.setSelection = function (anchor, head, root) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root)\n  };\n\n  CustomNodeViewDesc.prototype.destroy = function () {\n    if (this.spec.destroy) { this.spec.destroy() }\n    NodeViewDesc.prototype.destroy.call(this)\n  };\n\n  CustomNodeViewDesc.prototype.stopEvent = function (event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  };\n\n  CustomNodeViewDesc.prototype.ignoreMutation = function (mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)\n  };\n\n  return CustomNodeViewDesc;\n}(NodeViewDesc));\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs) {\n  var dom = parentDOM.firstChild\n  for (var i = 0; i < descs.length; i++) {\n    var desc = descs[i], childDOM = desc.dom\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom) }\n      dom = dom.nextSibling\n    } else {\n      parentDOM.insertBefore(childDOM, dom)\n    }\n    if (desc instanceof MarkViewDesc)\n      { renderDescs(desc.contentDOM, desc.children) }\n  }\n  while (dom) { dom = rm(dom) }\n}\n\nvar OuterDecoLevel = function(nodeName) {\n  if (nodeName) { this.nodeName = nodeName }\n};\nOuterDecoLevel.prototype = Object.create(null)\n\nvar noDeco = [new OuterDecoLevel]\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) { return noDeco }\n\n  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top]\n\n  for (var i = 0; i < outerDeco.length; i++) {\n    var attrs = outerDeco[i].type.attrs, cur = top\n    if (!attrs) { continue }\n    if (attrs.nodeName)\n      { result.push(cur = new OuterDecoLevel(attrs.nodeName)) }\n\n    for (var name in attrs) {\n      var val = attrs[name]\n      if (val == null) { continue }\n      if (needsWrap && result.length == 1)\n        { result.push(cur = top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\")) }\n      if (name == \"class\") { cur.class = (cur.class ? cur.class + \" \" : \"\") + val }\n      else if (name == \"style\") { cur.style = (cur.style ? cur.style + \";\" : \"\") + val }\n      else if (name != \"nodeName\") { cur[name] = val }\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }\n\n  var curDOM = nodeDOM\n  for (var i = 0; i < curComputed.length; i++) {\n    var deco = curComputed[i], prev = prevComputed[i]\n    if (i) {\n      var parent = (void 0)\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent\n      } else {\n        parent = document.createElement(deco.nodeName)\n        parent.appendChild(curDOM)\n        curDOM = parent\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco)\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (var name in prev)\n    { if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      { dom.removeAttribute(name) } }\n  for (var name$1 in cur)\n    { if (name$1 != \"class\" && name$1 != \"style\" && name$1 != \"nodeName\" && cur[name$1] != prev[name$1])\n      { dom.setAttribute(name$1, cur[name$1]) } }\n  if (prev.class != cur.class) {\n    var prevList = prev.class ? prev.class.split(\" \") : nothing\n    var curList = cur.class ? cur.class.split(\" \") : nothing\n    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)\n      { dom.classList.remove(prevList[i]) } }\n    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)\n      { dom.classList.add(curList[i$1]) } }\n  }\n  if (prev.style != cur.style) {\n    var text = dom.style.cssText, found\n    if (prev.style && (found = text.indexOf(prev.style)) > -1)\n      { text = text.slice(0, found) + text.slice(found + prev.style.length) }\n    dom.style.cssText = text + (cur.style || \"\")\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  var next = dom.nextSibling\n  dom.parentNode.removeChild(dom)\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nvar ViewTreeUpdater = function(top) {\n  this.top = top\n  // Index into `this.top`'s child array, represents the current\n  // update position.\n  this.index = 0\n  // When entering a mark, the current top and index are pushed\n  // onto this.\n  this.stack = []\n  // Tracks whether anything was changed\n  this.changed = false\n};\n\n// Destroy and remove the children between the given indices in\n// `this.top`.\nViewTreeUpdater.prototype.destroyBetween = function (start, end) {\n    var this$1 = this;\n\n  if (start == end) { return }\n  for (var i = start; i < end; i++) { this$1.top.children[i].destroy() }\n  this.top.children.splice(start, end - start)\n  this.changed = true\n};\n\n// Destroy all remaining children in `this.top`.\nViewTreeUpdater.prototype.destroyRest = function () {\n  this.destroyBetween(this.index, this.top.children.length)\n};\n\n// : ([Mark], EditorView)\n// Sync the current stack of mark descs with the given array of\n// marks, reusing existing mark descs when possible.\nViewTreeUpdater.prototype.syncToMarks = function (marks, view) {\n    var this$1 = this;\n\n  var keep = 0, depth = this.stack.length >> 1\n  var maxKeep = Math.min(depth, marks.length), next\n  while (keep < maxKeep &&\n         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]))\n    { keep++ }\n\n  while (keep < depth) {\n    this$1.destroyRest()\n    this$1.top.dirty = NOT_DIRTY\n    this$1.index = this$1.stack.pop()\n    this$1.top = this$1.stack.pop()\n    depth--\n  }\n  while (depth < marks.length) {\n    this$1.stack.push(this$1.top, this$1.index + 1)\n    if (this$1.index < this$1.top.children.length &&\n        (next = this$1.top.children[this$1.index]).matchesMark(marks[depth])) {\n      this$1.top = next\n    } else {\n      var markDesc = MarkViewDesc.create(this$1.top, marks[depth], view)\n      this$1.top.children.splice(this$1.index, 0, markDesc)\n      this$1.top = markDesc\n      this$1.changed = true\n    }\n    this$1.index = 0\n    depth++\n  }\n};\n\n// : (Node, [Decoration], DecorationSet) → bool\n// Try to find a node desc matching the given data. Skip over it and\n// return true when successful.\nViewTreeUpdater.prototype.findNodeMatch = function (node, outerDeco, innerDeco) {\n    var this$1 = this;\n\n  for (var i = this.index, children = this.top.children, e = Math.min(children.length, i + 5); i < e; i++) {\n    if (children[i].matchesNode(node, outerDeco, innerDeco)) {\n      this$1.destroyBetween(this$1.index, i)\n      this$1.index++\n      return true\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSet, EditorView, Fragment, number) → bool\n// Try to update the next node, if any, to the given data. First\n// tries scanning ahead in the siblings fragment to see if the next\n// node matches any of those, and if so, doesn't touch it, to avoid\n// overwriting nodes that could still be used.\nViewTreeUpdater.prototype.updateNextNode = function (node, outerDeco, innerDeco, view, siblings, index) {\n  if (this.index == this.top.children.length) { return false }\n  var next = this.top.children[this.index]\n  if (next instanceof NodeViewDesc) {\n    for (var i = index + 1, e = Math.min(siblings.childCount, i + 5); i < e; i++)\n      { if (next.node == siblings.child(i)) { return false } }\n    var nextDOM = next.dom\n    if (next.update(node, outerDeco, innerDeco, view)) {\n      if (next.dom != nextDOM) { this.changed = true }\n      this.index++\n      return true\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSet, EditorView)\n// Insert the node as a newly created node desc.\nViewTreeUpdater.prototype.addNode = function (node, outerDeco, innerDeco, view) {\n  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view))\n  this.changed = true\n};\n\nViewTreeUpdater.prototype.placeWidget = function (widget) {\n  if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget)) {\n    this.index++\n  } else {\n    this.top.children.splice(this.index++, 0, new WidgetViewDesc(this.top, widget))\n    this.changed = true\n  }\n};\n\n// Make sure a textblock looks and behaves correctly in\n// contentEditable.\nViewTreeUpdater.prototype.addTextblockHacks = function () {\n  var lastChild = this.top.children[this.index - 1]\n  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1] }\n\n  if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) ||\n      /\\n$/.test(lastChild.node.text)) {\n    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n      this.index++\n    } else {\n      var dom = document.createElement(\"br\")\n      this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null))\n      this.changed = true\n    }\n  }\n};\n\n// : (ViewDesc, DecorationSet, (Decoration), (Node, [Decoration], DecorationSet))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  var locals = deco.locals(parent), offset = 0\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (var i = 0; i < parent.childCount; i++) {\n      var child = parent.child(i)\n      onNode(child, locals, deco.forChild(offset, child), i)\n      offset += child.nodeSize\n    }\n    return\n  }\n\n  var decoIndex = 0, active = [], restNode = null\n  for (var parentIndex = 0;;) {\n    while (decoIndex < locals.length && locals[decoIndex].to == offset)\n      { onWidget(locals[decoIndex++]) }\n\n    var child$1 = (void 0)\n    if (restNode) {\n      child$1 = restNode\n      restNode = null\n    } else if (parentIndex < parent.childCount) {\n      child$1 = parent.child(parentIndex++)\n    } else {\n      break\n    }\n\n    for (var i$1 = 0; i$1 < active.length; i$1++) { if (active[i$1].to <= offset) { active.splice(i$1--, 1) } }\n    while (decoIndex < locals.length && locals[decoIndex].from == offset) { active.push(locals[decoIndex++]) }\n\n    var end = offset + child$1.nodeSize\n    if (child$1.isText) {\n      var cutAt = end\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from }\n      for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to < cutAt) { cutAt = active[i$2].to } }\n      if (cutAt < end) {\n        restNode = child$1.cut(cutAt - offset)\n        child$1 = child$1.cut(0, cutAt - offset)\n        end = cutAt\n      }\n    }\n\n    onNode(child$1, active.length ? active.slice() : nothing, deco.forChild(offset, child$1), parentIndex - 1)\n    offset = end\n  }\n}\n\n// Pre-calculate and cache the set of custom view specs for a given\n// prop object.\nvar cachedCustomViews, cachedCustomFor\nfunction customNodeViews(view) {\n  if (cachedCustomFor == view.props) { return cachedCustomViews }\n  cachedCustomFor = view.props\n  return cachedCustomViews = buildCustomViews(view)\n}\nfunction buildCustomViews(view) {\n  var result = {}\n  view.someProp(\"nodeViews\", function (obj) {\n    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))\n      { result[prop] = obj[prop] } }\n  })\n  return result\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText\n    dom.style.cssText = oldCSS + \"; list-style: square !important\"\n    window.getComputedStyle(dom).listStyle\n    dom.style.cssText = oldCSS\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prosemirror-view/dist/viewdesc.js\n// module id = 161\n// module chunks = 1","var GOOD_LEAF_SIZE = 200\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other)\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0) }\n  else\n    { this.forEachInvertedInner(f, from, to, 0) }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = []\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to)\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = (function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this)\n    this.values = values\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: {},depth: {} };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var this$1 = this;\n\n    for (var i = from; i < to; i++)\n      { if (f(this$1.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var this$1 = this;\n\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this$1.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([])\n\nvar Append = (function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this)\n    this.left = left\n    this.right = right\n    this.length = left.length + right.length\n    this.depth = Math.max(left.depth, right.depth) + 1\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other)\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other)\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nmodule.exports = RopeSequence\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rope-sequence/dist/index.js\n// module id = 162\n// module chunks = 1","/*!\n * vue-resource v1.0.3\n * https://github.com/vuejs/vue-resource\n * Released under the MIT License.\n */\n\n'use strict';\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING = 2;\n\nfunction Promise$1(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise$1.reject = function (r) {\n    return new Promise$1(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise$1.resolve = function (x) {\n    return new Promise$1(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise$1.all = function all(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        var count = 0,\n            result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromise$1.race = function race(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nvar p$1 = Promise$1.prototype;\n\np$1.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np$1.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np$1.notify = function notify() {\n    var promise = this;\n\n    nextTick(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np$1.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise$1(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\np$1.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/**\n * Promise adapter.\n */\n\nif (typeof Promise === 'undefined') {\n    window.Promise = Promise$1;\n}\n\nfunction PromiseObj(executor, context) {\n\n    if (executor instanceof Promise) {\n        this.promise = executor;\n    } else {\n        this.promise = new Promise(executor.bind(context));\n    }\n\n    this.context = context;\n}\n\nPromiseObj.all = function (iterable, context) {\n    return new PromiseObj(Promise.all(iterable), context);\n};\n\nPromiseObj.resolve = function (value, context) {\n    return new PromiseObj(Promise.resolve(value), context);\n};\n\nPromiseObj.reject = function (reason, context) {\n    return new PromiseObj(Promise.reject(reason), context);\n};\n\nPromiseObj.race = function (iterable, context) {\n    return new PromiseObj(Promise.race(iterable), context);\n};\n\nvar p = PromiseObj.prototype;\n\np.bind = function (context) {\n    this.context = context;\n    return this;\n};\n\np.then = function (fulfilled, rejected) {\n\n    if (fulfilled && fulfilled.bind && this.context) {\n        fulfilled = fulfilled.bind(this.context);\n    }\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\n};\n\np.catch = function (rejected) {\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.catch(rejected), this.context);\n};\n\np.finally = function (callback) {\n\n    return this.then(function (value) {\n        callback.call(this);\n        return value;\n    }, function (reason) {\n        callback.call(this);\n        return Promise.reject(reason);\n    });\n};\n\n/**\n * Utility functions.\n */\n\nvar debug = false;var util = {};var slice = [].slice;\n\n\nfunction Util (Vue) {\n    util = Vue.util;\n    debug = Vue.config.debug || !Vue.config.silent;\n}\n\nfunction warn(msg) {\n    if (typeof console !== 'undefined' && debug) {\n        console.warn('[VueResource warn]: ' + msg);\n    }\n}\n\nfunction error(msg) {\n    if (typeof console !== 'undefined') {\n        console.error(msg);\n    }\n}\n\nfunction nextTick(cb, ctx) {\n    return util.nextTick(cb, ctx);\n}\n\nfunction trim(str) {\n    return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nfunction toLower(str) {\n    return str ? str.toLowerCase() : '';\n}\n\nfunction toUpper(str) {\n    return str ? str.toUpperCase() : '';\n}\n\nvar isArray = Array.isArray;\n\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\nfunction isBoolean(val) {\n    return val === true || val === false;\n}\n\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n}\n\nfunction isBlob(obj) {\n    return typeof Blob !== 'undefined' && obj instanceof Blob;\n}\n\nfunction isFormData(obj) {\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\n}\n\nfunction when(value, fulfilled, rejected) {\n\n    var promise = PromiseObj.resolve(value);\n\n    if (arguments.length < 2) {\n        return promise;\n    }\n\n    return promise.then(fulfilled, rejected);\n}\n\nfunction options(fn, obj, opts) {\n\n    opts = opts || {};\n\n    if (isFunction(opts)) {\n        opts = opts.call(obj);\n    }\n\n    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\n}\n\nfunction each(obj, iterator) {\n\n    var i, key;\n\n    if (obj && typeof obj.length == 'number') {\n        for (i = 0; i < obj.length; i++) {\n            iterator.call(obj[i], obj[i], i);\n        }\n    } else if (isObject(obj)) {\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                iterator.call(obj[key], obj[key], key);\n            }\n        }\n    }\n\n    return obj;\n}\n\nvar assign = Object.assign || _assign;\n\nfunction merge(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source, true);\n    });\n\n    return target;\n}\n\nfunction defaults(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n\n        for (var key in source) {\n            if (target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    });\n\n    return target;\n}\n\nfunction _assign(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source);\n    });\n\n    return target;\n}\n\nfunction _merge(target, source, deep) {\n    for (var key in source) {\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n                target[key] = {};\n            }\n            if (isArray(source[key]) && !isArray(target[key])) {\n                target[key] = [];\n            }\n            _merge(target[key], source[key], deep);\n        } else if (source[key] !== undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n\n/**\n * Root Prefix Transform.\n */\n\nfunction root (options, next) {\n\n    var url = next(options);\n\n    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\n        url = options.root + '/' + url;\n    }\n\n    return url;\n}\n\n/**\n * Query Parameter Transform.\n */\n\nfunction query (options, next) {\n\n    var urlParams = Object.keys(Url.options.params),\n        query = {},\n        url = next(options);\n\n    each(options.params, function (value, key) {\n        if (urlParams.indexOf(key) === -1) {\n            query[key] = value;\n        }\n    });\n\n    query = Url.params(query);\n\n    if (query) {\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n    }\n\n    return url;\n}\n\n/**\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n */\n\nfunction expand(url, params, variables) {\n\n    var tmpl = parse(url),\n        expanded = tmpl.expand(params);\n\n    if (variables) {\n        variables.push.apply(variables, tmpl.vars);\n    }\n\n    return expanded;\n}\n\nfunction parse(template) {\n\n    var operators = ['+', '#', '.', '/', ';', '?', '&'],\n        variables = [];\n\n    return {\n        vars: variables,\n        expand: function (context) {\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n                if (expression) {\n\n                    var operator = null,\n                        values = [];\n\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n                        operator = expression.charAt(0);\n                        expression = expression.substr(1);\n                    }\n\n                    expression.split(/,/g).forEach(function (variable) {\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n                        variables.push(tmp[1]);\n                    });\n\n                    if (operator && operator !== '+') {\n\n                        var separator = ',';\n\n                        if (operator === '?') {\n                            separator = '&';\n                        } else if (operator !== '#') {\n                            separator = operator;\n                        }\n\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\n                    } else {\n                        return values.join(',');\n                    }\n                } else {\n                    return encodeReserved(literal);\n                }\n            });\n        }\n    };\n}\n\nfunction getValues(context, operator, key, modifier) {\n\n    var value = context[key],\n        result = [];\n\n    if (isDefined(value) && value !== '') {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n            value = value.toString();\n\n            if (modifier && modifier !== '*') {\n                value = value.substring(0, parseInt(modifier, 10));\n            }\n\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n        } else {\n            if (modifier === '*') {\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            result.push(encodeValue(operator, value[k], k));\n                        }\n                    });\n                }\n            } else {\n                var tmp = [];\n\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        tmp.push(encodeValue(operator, value));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            tmp.push(encodeURIComponent(k));\n                            tmp.push(encodeValue(operator, value[k].toString()));\n                        }\n                    });\n                }\n\n                if (isKeyOperator(operator)) {\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n                } else if (tmp.length !== 0) {\n                    result.push(tmp.join(','));\n                }\n            }\n        }\n    } else {\n        if (operator === ';') {\n            result.push(encodeURIComponent(key));\n        } else if (value === '' && (operator === '&' || operator === '?')) {\n            result.push(encodeURIComponent(key) + '=');\n        } else if (value === '') {\n            result.push('');\n        }\n    }\n\n    return result;\n}\n\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n}\n\nfunction encodeValue(operator, value, key) {\n\n    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n        return encodeURIComponent(key) + '=' + value;\n    } else {\n        return value;\n    }\n}\n\nfunction encodeReserved(str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n        if (!/%[0-9A-Fa-f]/.test(part)) {\n            part = encodeURI(part);\n        }\n        return part;\n    }).join('');\n}\n\n/**\n * URL Template (RFC 6570) Transform.\n */\n\nfunction template (options) {\n\n    var variables = [],\n        url = expand(options.url, options.params, variables);\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n}\n\n/**\n * Service for URL templating.\n */\n\nvar ie = document.documentMode;\nvar el = document.createElement('a');\n\nfunction Url(url, params) {\n\n    var self = this || {},\n        options = url,\n        transform;\n\n    if (isString(url)) {\n        options = { url: url, params: params };\n    }\n\n    options = merge({}, Url.options, self.$options, options);\n\n    Url.transforms.forEach(function (handler) {\n        transform = factory(handler, transform, self.$vm);\n    });\n\n    return transform(options);\n}\n\n/**\n * Url options.\n */\n\nUrl.options = {\n    url: '',\n    root: null,\n    params: {}\n};\n\n/**\n * Url transforms.\n */\n\nUrl.transforms = [template, query, root];\n\n/**\n * Encodes a Url parameter string.\n *\n * @param {Object} obj\n */\n\nUrl.params = function (obj) {\n\n    var params = [],\n        escape = encodeURIComponent;\n\n    params.add = function (key, value) {\n\n        if (isFunction(value)) {\n            value = value();\n        }\n\n        if (value === null) {\n            value = '';\n        }\n\n        this.push(escape(key) + '=' + escape(value));\n    };\n\n    serialize(params, obj);\n\n    return params.join('&').replace(/%20/g, '+');\n};\n\n/**\n * Parse a URL and return its components.\n *\n * @param {String} url\n */\n\nUrl.parse = function (url) {\n\n    if (ie) {\n        el.href = url;\n        url = el.href;\n    }\n\n    el.href = url;\n\n    return {\n        href: el.href,\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n        port: el.port,\n        host: el.host,\n        hostname: el.hostname,\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n    };\n};\n\nfunction factory(handler, next, vm) {\n    return function (options) {\n        return handler.call(vm, options, next);\n    };\n}\n\nfunction serialize(params, obj, scope) {\n\n    var array = isArray(obj),\n        plain = isPlainObject(obj),\n        hash;\n\n    each(obj, function (value, key) {\n\n        hash = isObject(value) || isArray(value);\n\n        if (scope) {\n            key = scope + '[' + (plain || hash ? key : '') + ']';\n        }\n\n        if (!scope && array) {\n            params.add(value.name, value.value);\n        } else if (hash) {\n            serialize(params, value, key);\n        } else {\n            params.add(key, value);\n        }\n    });\n}\n\n/**\n * XDomain client (Internet Explorer).\n */\n\nfunction xdrClient (request) {\n    return new PromiseObj(function (resolve) {\n\n        var xdr = new XDomainRequest(),\n            handler = function (_ref) {\n            var type = _ref.type;\n\n\n            var status = 0;\n\n            if (type === 'load') {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            resolve(request.respondWith(xdr.responseText, { status: status }));\n        };\n\n        request.abort = function () {\n            return xdr.abort();\n        };\n\n        xdr.open(request.method, request.getUrl());\n        xdr.timeout = 0;\n        xdr.onload = handler;\n        xdr.onerror = handler;\n        xdr.ontimeout = handler;\n        xdr.onprogress = function () {};\n        xdr.send(request.getBody());\n    });\n}\n\n/**\n * CORS Interceptor.\n */\n\nvar ORIGIN_URL = Url.parse(location.href);\nvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\n\nfunction cors (request, next) {\n\n    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\n        request.crossOrigin = true;\n    }\n\n    if (request.crossOrigin) {\n\n        if (!SUPPORTS_CORS) {\n            request.client = xdrClient;\n        }\n\n        delete request.emulateHTTP;\n    }\n\n    next();\n}\n\nfunction crossOrigin(request) {\n\n    var requestUrl = Url.parse(Url(request));\n\n    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\n}\n\n/**\n * Body Interceptor.\n */\n\nfunction body (request, next) {\n\n    if (isFormData(request.body)) {\n\n        request.headers.delete('Content-Type');\n    } else if (isObject(request.body) || isArray(request.body)) {\n\n        if (request.emulateJSON) {\n            request.body = Url.params(request.body);\n            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');\n        } else {\n            request.body = JSON.stringify(request.body);\n        }\n    }\n\n    next(function (response) {\n\n        Object.defineProperty(response, 'data', {\n            get: function () {\n                return this.body;\n            },\n            set: function (body) {\n                this.body = body;\n            }\n        });\n\n        return response.bodyText ? when(response.text(), function (text) {\n\n            var type = response.headers.get('Content-Type');\n\n            if (isString(type) && type.indexOf('application/json') === 0) {\n\n                try {\n                    response.body = JSON.parse(text);\n                } catch (e) {\n                    response.body = null;\n                }\n            } else {\n                response.body = text;\n            }\n\n            return response;\n        }) : response;\n    });\n}\n\n/**\n * JSONP client.\n */\n\nfunction jsonpClient (request) {\n    return new PromiseObj(function (resolve) {\n\n        var name = request.jsonp || 'callback',\n            callback = '_jsonp' + Math.random().toString(36).substr(2),\n            body = null,\n            handler,\n            script;\n\n        handler = function (_ref) {\n            var type = _ref.type;\n\n\n            var status = 0;\n\n            if (type === 'load' && body !== null) {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            resolve(request.respondWith(body, { status: status }));\n\n            delete window[callback];\n            document.body.removeChild(script);\n        };\n\n        request.params[name] = callback;\n\n        window[callback] = function (result) {\n            body = JSON.stringify(result);\n        };\n\n        script = document.createElement('script');\n        script.src = request.getUrl();\n        script.type = 'text/javascript';\n        script.async = true;\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n}\n\n/**\n * JSONP Interceptor.\n */\n\nfunction jsonp (request, next) {\n\n    if (request.method == 'JSONP') {\n        request.client = jsonpClient;\n    }\n\n    next(function (response) {\n\n        if (request.method == 'JSONP') {\n\n            return when(response.json(), function (json) {\n\n                response.body = json;\n\n                return response;\n            });\n        }\n    });\n}\n\n/**\n * Before Interceptor.\n */\n\nfunction before (request, next) {\n\n    if (isFunction(request.before)) {\n        request.before.call(this, request);\n    }\n\n    next();\n}\n\n/**\n * HTTP method override Interceptor.\n */\n\nfunction method (request, next) {\n\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n        request.headers.set('X-HTTP-Method-Override', request.method);\n        request.method = 'POST';\n    }\n\n    next();\n}\n\n/**\n * Header Interceptor.\n */\n\nfunction header (request, next) {\n\n    var headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[toLower(request.method)]);\n\n    each(headers, function (value, name) {\n        if (!request.headers.has(name)) {\n            request.headers.set(name, value);\n        }\n    });\n\n    next();\n}\n\n/**\n * Timeout Interceptor.\n */\n\nfunction timeout (request, next) {\n\n    var timeout;\n\n    if (request.timeout) {\n        timeout = setTimeout(function () {\n            request.abort();\n        }, request.timeout);\n    }\n\n    next(function (response) {\n\n        clearTimeout(timeout);\n    });\n}\n\n/**\n * XMLHttp client.\n */\n\nfunction xhrClient (request) {\n    return new PromiseObj(function (resolve) {\n\n        var xhr = new XMLHttpRequest(),\n            handler = function (event) {\n\n            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\n                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\n            });\n\n            each(trim(xhr.getAllResponseHeaders()).split('\\n'), function (row) {\n                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\n            });\n\n            resolve(response);\n        };\n\n        request.abort = function () {\n            return xhr.abort();\n        };\n\n        if (request.progress) {\n            if (request.method === 'GET') {\n                xhr.addEventListener('progress', request.progress);\n            } else if (/^(POST|PUT)$/i.test(request.method)) {\n                xhr.upload.addEventListener('progress', request.progress);\n            }\n        }\n\n        xhr.open(request.method, request.getUrl(), true);\n\n        if ('responseType' in xhr) {\n            xhr.responseType = 'blob';\n        }\n\n        if (request.credentials === true) {\n            xhr.withCredentials = true;\n        }\n\n        request.headers.forEach(function (value, name) {\n            xhr.setRequestHeader(name, value);\n        });\n\n        xhr.timeout = 0;\n        xhr.onload = handler;\n        xhr.onerror = handler;\n        xhr.send(request.getBody());\n    });\n}\n\n/**\n * Base client.\n */\n\nfunction Client (context) {\n\n    var reqHandlers = [sendRequest],\n        resHandlers = [],\n        handler;\n\n    if (!isObject(context)) {\n        context = null;\n    }\n\n    function Client(request) {\n        return new PromiseObj(function (resolve) {\n\n            function exec() {\n\n                handler = reqHandlers.pop();\n\n                if (isFunction(handler)) {\n                    handler.call(context, request, next);\n                } else {\n                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\n                    next();\n                }\n            }\n\n            function next(response) {\n\n                if (isFunction(response)) {\n\n                    resHandlers.unshift(response);\n                } else if (isObject(response)) {\n\n                    resHandlers.forEach(function (handler) {\n                        response = when(response, function (response) {\n                            return handler.call(context, response) || response;\n                        });\n                    });\n\n                    when(response, resolve);\n\n                    return;\n                }\n\n                exec();\n            }\n\n            exec();\n        }, context);\n    }\n\n    Client.use = function (handler) {\n        reqHandlers.push(handler);\n    };\n\n    return Client;\n}\n\nfunction sendRequest(request, resolve) {\n\n    var client = request.client || xhrClient;\n\n    resolve(client(request));\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n/**\n * HTTP Headers.\n */\n\nvar Headers = function () {\n    function Headers(headers) {\n        var _this = this;\n\n        classCallCheck(this, Headers);\n\n\n        this.map = {};\n\n        each(headers, function (value, name) {\n            return _this.append(name, value);\n        });\n    }\n\n    Headers.prototype.has = function has(name) {\n        return getName(this.map, name) !== null;\n    };\n\n    Headers.prototype.get = function get(name) {\n\n        var list = this.map[getName(this.map, name)];\n\n        return list ? list[0] : null;\n    };\n\n    Headers.prototype.getAll = function getAll(name) {\n        return this.map[getName(this.map, name)] || [];\n    };\n\n    Headers.prototype.set = function set(name, value) {\n        this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\n    };\n\n    Headers.prototype.append = function append(name, value) {\n\n        var list = this.getAll(name);\n\n        if (list.length) {\n            list.push(trim(value));\n        } else {\n            this.set(name, value);\n        }\n    };\n\n    Headers.prototype.delete = function _delete(name) {\n        delete this.map[getName(this.map, name)];\n    };\n\n    Headers.prototype.forEach = function forEach(callback, thisArg) {\n        var _this2 = this;\n\n        each(this.map, function (list, name) {\n            each(list, function (value) {\n                return callback.call(thisArg, value, name, _this2);\n            });\n        });\n    };\n\n    return Headers;\n}();\n\nfunction getName(map, name) {\n    return Object.keys(map).reduce(function (prev, curr) {\n        return toLower(name) === toLower(curr) ? curr : prev;\n    }, null);\n}\n\nfunction normalizeName(name) {\n\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n    }\n\n    return trim(name);\n}\n\n/**\n * HTTP Response.\n */\n\nvar Response = function () {\n    function Response(body, _ref) {\n        var url = _ref.url;\n        var headers = _ref.headers;\n        var status = _ref.status;\n        var statusText = _ref.statusText;\n        classCallCheck(this, Response);\n\n\n        this.url = url;\n        this.ok = status >= 200 && status < 300;\n        this.status = status || 0;\n        this.statusText = statusText || '';\n        this.headers = new Headers(headers);\n        this.body = body;\n\n        if (isString(body)) {\n\n            this.bodyText = body;\n        } else if (isBlob(body)) {\n\n            this.bodyBlob = body;\n\n            if (isBlobText(body)) {\n                this.bodyText = blobText(body);\n            }\n        }\n    }\n\n    Response.prototype.blob = function blob() {\n        return when(this.bodyBlob);\n    };\n\n    Response.prototype.text = function text() {\n        return when(this.bodyText);\n    };\n\n    Response.prototype.json = function json() {\n        return when(this.text(), function (text) {\n            return JSON.parse(text);\n        });\n    };\n\n    return Response;\n}();\n\nfunction blobText(body) {\n    return new PromiseObj(function (resolve) {\n\n        var reader = new FileReader();\n\n        reader.readAsText(body);\n        reader.onload = function () {\n            resolve(reader.result);\n        };\n    });\n}\n\nfunction isBlobText(body) {\n    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\n}\n\n/**\n * HTTP Request.\n */\n\nvar Request = function () {\n    function Request(options) {\n        classCallCheck(this, Request);\n\n\n        this.body = null;\n        this.params = {};\n\n        assign(this, options, {\n            method: toUpper(options.method || 'GET')\n        });\n\n        if (!(this.headers instanceof Headers)) {\n            this.headers = new Headers(this.headers);\n        }\n    }\n\n    Request.prototype.getUrl = function getUrl() {\n        return Url(this);\n    };\n\n    Request.prototype.getBody = function getBody() {\n        return this.body;\n    };\n\n    Request.prototype.respondWith = function respondWith(body, options) {\n        return new Response(body, assign(options || {}, { url: this.getUrl() }));\n    };\n\n    return Request;\n}();\n\n/**\n * Service for sending network requests.\n */\n\nvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\nvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\nvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\n\nfunction Http(options) {\n\n    var self = this || {},\n        client = Client(self.$vm);\n\n    defaults(options || {}, self.$options, Http.options);\n\n    Http.interceptors.forEach(function (handler) {\n        client.use(handler);\n    });\n\n    return client(new Request(options)).then(function (response) {\n\n        return response.ok ? response : PromiseObj.reject(response);\n    }, function (response) {\n\n        if (response instanceof Error) {\n            error(response);\n        }\n\n        return PromiseObj.reject(response);\n    });\n}\n\nHttp.options = {};\n\nHttp.headers = {\n    put: JSON_CONTENT_TYPE,\n    post: JSON_CONTENT_TYPE,\n    patch: JSON_CONTENT_TYPE,\n    delete: JSON_CONTENT_TYPE,\n    custom: CUSTOM_HEADERS,\n    common: COMMON_HEADERS\n};\n\nHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\n\n['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\n\n    Http[method] = function (url, options) {\n        return this(assign(options || {}, { url: url, method: method }));\n    };\n});\n\n['post', 'put', 'patch'].forEach(function (method) {\n\n    Http[method] = function (url, body, options) {\n        return this(assign(options || {}, { url: url, method: method, body: body }));\n    };\n});\n\n/**\n * Service for interacting with RESTful services.\n */\n\nfunction Resource(url, params, actions, options) {\n\n    var self = this || {},\n        resource = {};\n\n    actions = assign({}, Resource.actions, actions);\n\n    each(actions, function (action, name) {\n\n        action = merge({ url: url, params: assign({}, params) }, options, action);\n\n        resource[name] = function () {\n            return (self.$http || Http)(opts(action, arguments));\n        };\n    });\n\n    return resource;\n}\n\nfunction opts(action, args) {\n\n    var options = assign({}, action),\n        params = {},\n        body;\n\n    switch (args.length) {\n\n        case 2:\n\n            params = args[0];\n            body = args[1];\n\n            break;\n\n        case 1:\n\n            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n                body = args[0];\n            } else {\n                params = args[0];\n            }\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\n    }\n\n    options.body = body;\n    options.params = assign({}, options.params, params);\n\n    return options;\n}\n\nResource.actions = {\n\n    get: { method: 'GET' },\n    save: { method: 'POST' },\n    query: { method: 'GET' },\n    update: { method: 'PUT' },\n    remove: { method: 'DELETE' },\n    delete: { method: 'DELETE' }\n\n};\n\n/**\n * Install plugin.\n */\n\nfunction plugin(Vue) {\n\n    if (plugin.installed) {\n        return;\n    }\n\n    Util(Vue);\n\n    Vue.url = Url;\n    Vue.http = Http;\n    Vue.resource = Resource;\n    Vue.Promise = PromiseObj;\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function () {\n                return options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function () {\n                return options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function () {\n                return Vue.resource.bind(this);\n            }\n        },\n\n        $promise: {\n            get: function () {\n                var _this = this;\n\n                return function (executor) {\n                    return new Vue.Promise(executor, _this);\n                };\n            }\n        }\n\n    });\n}\n\nif (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n}\n\nmodule.exports = plugin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-resource/dist/vue-resource.common.js\n// module id = 198\n// module chunks = 1","/**\n  * vue-router v2.1.1\n  * (c) 2016 Evan You\n  * @license MIT\n  */\n'use strict';\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true\n\n    var route = parent.$route\n    var cache = parent._routerViewCache || (parent._routerViewCache = {})\n    var depth = 0\n    var inactive = false\n\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++\n      }\n      if (parent._inactive) {\n        inactive = true\n      }\n      parent = parent.$parent\n    }\n\n    data.routerViewDepth = depth\n    var matched = route.matched[depth]\n    if (!matched) {\n      return h()\n    }\n\n    var name = props.name\n    var component = inactive\n      ? cache[name]\n      : (cache[name] = matched.components[name])\n\n    if (!inactive) {\n      var hooks = data.hook || (data.hook = {})\n      hooks.init = function (vnode) {\n        matched.instances[name] = vnode.child\n      }\n      hooks.prepatch = function (oldVnode, vnode) {\n        matched.instances[name] = vnode.child\n      }\n      hooks.destroy = function (vnode) {\n        if (matched.instances[name] === vnode.child) {\n          matched.instances[name] = undefined\n        }\n      }\n    }\n\n    return h(component, data, children)\n  }\n}\n\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message))\n  }\n}\n\n/*  */\n\nvar encode = encodeURIComponent\nvar decode = decodeURIComponent\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery\n    try {\n      parsedQuery = parseQuery(query)\n    } catch (e) {\n      process.env.NODE_ENV !== 'production' && warn(false, e.message)\n      parsedQuery = {}\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key]\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {}\n\n  query = query.trim().replace(/^(\\?|#|&)/, '')\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=')\n    var key = decode(parts.shift())\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null\n\n    if (res[key] === undefined) {\n      res[key] = val\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val)\n    } else {\n      res[key] = [res[key], val]\n    }\n  })\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key]\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = []\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key))\n        } else {\n          result.push(encode(key) + '=' + encode(val2))\n        }\n      })\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  }\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom)\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n})\n\nfunction formatMatch (record) {\n  var res = []\n  while (record) {\n    res.unshift(record)\n    record = record.parent\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nvar trailingSlashRE = /\\/$/\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a)\n  var bKeys = Object.keys(b)\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.indexOf(target.path.replace(/\\/$/, '')) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object]\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: [String, Array],\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router\n    var current = this.$route\n    var ref = router.resolve(this.to, current, this.append);\n    var normalizedTo = ref.normalizedTo;\n    var resolved = ref.resolved;\n    var href = ref.href;\n    var classes = {}\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active'\n    var compareTarget = normalizedTo.path ? createRoute(null, normalizedTo) : resolved\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget)\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(normalizedTo)\n        } else {\n          router.push(normalizedTo)\n        }\n      }\n    }\n\n    var on = { click: guardEvent }\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler })\n    } else {\n      on[this.event] = handler\n    }\n\n    var data = {\n      class: classes\n    }\n\n    if (this.tag === 'a') {\n      data.on = on\n      data.attrs = { href: href }\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default)\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false\n        var extend = _Vue.util.extend\n        var aData = a.data = extend({}, a.data)\n        aData.on = on\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs)\n        aAttrs.href = href\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n}\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  /* istanbul ignore if */\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  /* istanbul ignore if */\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  /* istanbul ignore if */\n  if (e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  /* istanbul ignore if */\n  var target = e.target.getAttribute('target')\n  if (/\\b_blank\\b/i.test(target)) { return }\n\n  e.preventDefault()\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child\n    for (var i = 0; i < children.length; i++) {\n      child = children[i]\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true\n\n  _Vue = Vue\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  })\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get$1 () { return this.$root._route }\n  })\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router\n        this._router.init(this)\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      }\n    }\n  })\n\n  Vue.component('router-view', View)\n  Vue.component('router-link', Link)\n\n  var strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created\n}\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/')\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop()\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/')\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i]\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop()\n    } else {\n      stack.push(segment)\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('')\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = ''\n  var query = ''\n\n  var hashIndex = path.indexOf('#')\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex)\n    path = path.slice(0, hashIndex)\n  }\n\n  var queryIndex = path.indexOf('?')\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1)\n    path = path.slice(0, queryIndex)\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (routes) {\n  var pathMap = Object.create(null)\n  var nameMap = Object.create(null)\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route)\n  })\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\")\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    )\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {}\n  }\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(false, (\"Named Route '\" + (route.name) + \"' has a default child route.\\n          When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), the default child route will not be rendered.\\n          Remove the name from this route and use the name of the default child route for named links instead.\")\n        )\n      }\n    }\n    route.children.forEach(function (child) {\n      addRouteRecord(pathMap, nameMap, child, record)\n    })\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        addRouteRecord(pathMap, nameMap, { path: alias }, parent, record.path)\n      })\n    } else {\n      addRouteRecord(pathMap, nameMap, { path: route.alias }, parent, record.path)\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record\n  }\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"Duplicate named routes definition: { name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"))\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '')\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar __moduleExports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = __moduleExports\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp\nvar parse_1 = parse\nvar compile_1 = compile\nvar tokensToFunction_1 = tokensToFunction\nvar tokensToRegExp_1 = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null)\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path]\n  var keys, regexp\n\n  if (hit) {\n    keys = hit.keys\n    regexp = hit.regexp\n  } else {\n    keys = []\n    regexp = index(path, keys)\n    regexpCache[path] = { keys: keys, regexp: regexp }\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null)\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path))\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)))\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next)\n    next._normalized = true\n    var params = assign(assign({}, current.params), next.params)\n    if (current.name) {\n      next.name = current.name\n      next.params = params\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)))\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\")\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '')\n  var basePath = (current && current.path) || '/'\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/'\n  var query = resolveQuery(parsedPath.query, next.query)\n  var hash = next.hash || parsedPath.hash\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key]\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute)\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name]\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; })\n\n      if (typeof location.params !== 'object') {\n        location.params = {}\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key]\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"))\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {}\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect }\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      process.env.NODE_ENV !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      )\n      return _createRoute(null, location)\n    }\n\n    var re = redirect\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query\n    hash = re.hasOwnProperty('hash') ? re.hash : hash\n    params = re.hasOwnProperty('params') ? re.params : params\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name]\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"))\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record)\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"))\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))))\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"))\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    })\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched\n      var aliasedRecord = matched[matched.length - 1]\n      location.params = aliasedMatch.params\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return match\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp)\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1]\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]\n    if (key) { params[key.name] = val }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined'\n\nvar supportsHistory = inBrowser && (function () {\n  var ua = window.navigator.userAgent\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})()\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router\n  this.base = normalizeBase(base)\n  // start with a route object that stands for \"nowhere\"\n  this.current = START\n  this.pending = null\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current)\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route)\n    onComplete && onComplete(route)\n    this$1.ensureURL()\n  }, onAbort)\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current\n  var abort = function () { onAbort && onAbort() }\n  if (isSameRoute(route, current)) {\n    this.ensureURL()\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true)\n        abort()\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to)\n        abort()\n      } else {\n        // confirm transition and pass on the value\n        next(to)\n      }\n    })\n  }\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = []\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, function () {\n      return this$1.current === route\n    })\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null\n      onComplete(route)\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); })\n        })\n      }\n    })\n  })\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current\n  this.current = route\n  this.cb && this.cb(route)\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev)\n  })\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base')\n      base = baseEl ? baseEl.getAttribute('href') : '/'\n    } else {\n      base = '/'\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i\n  var max = Math.max(current.length, next.length)\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (matched) {\n  return flatten(flatMapComponents(matched, function (def, instance) {\n    var guard = extractGuard(def, 'beforeRouteLeave')\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return wrapLeaveGuard(guard, instance); })\n        : wrapLeaveGuard(guard, instance)\n    }\n  }).reverse())\n}\n\nfunction wrapLeaveGuard (\n  guard,\n  instance\n) {\n  return function routeLeaveGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  matched,\n  cbs,\n  isValid\n) {\n  return flatten(flatMapComponents(matched, function (def, _, match, key) {\n    var guard = extractGuard(def, 'beforeRouteEnter')\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return wrapEnterGuard(guard, cbs, match, key, isValid); })\n        : wrapEnterGuard(guard, cbs, match, key, isValid)\n    }\n  }))\n}\n\nfunction wrapEnterGuard (\n  guard,\n  cbs,\n  match,\n  key,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb)\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid)\n        })\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key])\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid)\n    }, 16)\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = function (resolvedDef) {\n          match.components[key] = resolvedDef\n          next()\n        }\n\n        var reject = function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason))\n          next(false)\n        }\n\n        var res = def(resolve, reject)\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject)\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n/*  */\n\nvar positionStore = Object.create(null)\n\nfunction saveScrollPosition (key) {\n  if (!key) { return }\n  positionStore[key] = {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  }\n}\n\nfunction getScrollPosition (key) {\n  if (!key) { return }\n  return positionStore[key]\n}\n\nfunction getElementPosition (el) {\n  var docRect = document.documentElement.getBoundingClientRect()\n  var elRect = el.getBoundingClientRect()\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\n\nvar genKey = function () { return String(Date.now()); }\nvar _key = genKey()\n\nvar HTML5History = (function (History) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History.call(this, router, base)\n\n    var expectScroll = router.options.scrollBehavior\n    window.addEventListener('popstate', function (e) {\n      _key = e.state && e.state.key\n      var current = this$1.current\n      this$1.transitionTo(getLocation(this$1.base), function (next) {\n        if (expectScroll) {\n          this$1.handleScroll(next, current, true)\n        }\n      })\n    })\n\n    if (expectScroll) {\n      window.addEventListener('scroll', function () {\n        saveScrollPosition(_key)\n      })\n    }\n  }\n\n  if ( History ) HTML5History.__proto__ = History;\n  HTML5History.prototype = Object.create( History && History.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n)\n  };\n\n  HTML5History.prototype.push = function push (location) {\n    var this$1 = this;\n\n    var current = this.current\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath))\n      this$1.handleScroll(route, current, false)\n    })\n  };\n\n  HTML5History.prototype.replace = function replace (location) {\n    var this$1 = this;\n\n    var current = this.current\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath))\n      this$1.handleScroll(route, current, false)\n    })\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath)\n      push ? pushState(current) : replaceState(current)\n    }\n  };\n\n  HTML5History.prototype.handleScroll = function handleScroll (to, from, isPop) {\n    var router = this.router\n    if (!router.app) {\n      return\n    }\n\n    var behavior = router.options.scrollBehavior\n    if (!behavior) {\n      return\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      assert(typeof behavior === 'function', \"scrollBehavior must be a function\")\n    }\n\n    // wait until re-render finishes before scrolling\n    router.app.$nextTick(function () {\n      var position = getScrollPosition(_key)\n      var shouldScroll = behavior(to, from, isPop ? position : null)\n      if (!shouldScroll) {\n        return\n      }\n      var isObject = typeof shouldScroll === 'object'\n      if (isObject && typeof shouldScroll.selector === 'string') {\n        var el = document.querySelector(shouldScroll.selector)\n        if (el) {\n          position = getElementPosition(el)\n        } else if (isValidPosition(shouldScroll)) {\n          position = normalizePosition(shouldScroll)\n        }\n      } else if (isObject && isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll)\n      }\n\n      if (position) {\n        window.scrollTo(position.x, position.y)\n      }\n    })\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length)\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\nfunction pushState (url, replace) {\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, '', url)\n    }\n    saveScrollPosition(_key)\n  } catch (e) {\n    window.location[replace ? 'assign' : 'replace'](url)\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true)\n}\n\n/*  */\n\n\nvar HashHistory = (function (History) {\n  function HashHistory (router, base, fallback) {\n    History.call(this, router, base)\n    // check history fallback deeplinking\n    if (fallback && this.checkFallback()) {\n      return\n    }\n    ensureSlash()\n  }\n\n  if ( History ) HashHistory.__proto__ = History;\n  HashHistory.prototype = Object.create( History && History.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  HashHistory.prototype.checkFallback = function checkFallback () {\n    var location = getLocation(this.base)\n    if (!/^\\/#/.test(location)) {\n      window.location.replace(\n        cleanPath(this.base + '/#' + location)\n      )\n      return true\n    }\n  };\n\n  HashHistory.prototype.onHashChange = function onHashChange () {\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), function (route) {\n      replaceHash(route.fullPath)\n    })\n  };\n\n  HashHistory.prototype.push = function push (location) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath)\n    })\n  };\n\n  HashHistory.prototype.replace = function replace (location) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath)\n    })\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n)\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current)\n    }\n  };\n\n  return HashHistory;\n}(History));\n\nfunction ensureSlash () {\n  var path = getHash()\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path)\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href\n  var index = href.indexOf('#')\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#')\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  )\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History) {\n  function AbstractHistory (router) {\n    History.call(this, router)\n    this.stack = []\n    this.index = -1\n  }\n\n  if ( History ) AbstractHistory.__proto__ = History;\n  AbstractHistory.prototype = Object.create( History && History.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route)\n      this$1.index++\n    })\n  };\n\n  AbstractHistory.prototype.replace = function replace (location) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route)\n    })\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex]\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex\n      this$1.updateRoute(route)\n    })\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null\n  this.options = options\n  this.beforeHooks = []\n  this.afterHooks = []\n  this.match = createMatcher(options.routes || [])\n\n  var mode = options.mode || 'hash'\n  this.fallback = mode === 'history' && !supportsHistory\n  if (this.fallback) {\n    mode = 'hash'\n  }\n  if (!inBrowser) {\n    mode = 'abstract'\n  }\n  this.mode = mode\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base)\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback)\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this)\n      break\n    default:\n      process.env.NODE_ENV !== 'production' && assert(false, (\"invalid mode: \" + mode))\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  )\n\n  this.app = app\n\n  var history = this.history\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(getLocation(history.base))\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      window.addEventListener('hashchange', function () {\n        history.onHashChange()\n      })\n    }\n    history.transitionTo(getHash(), setupHashListener, setupHashListener)\n  }\n\n  history.listen(function (route) {\n    this$1.app._route = route\n  })\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn)\n};\n\nVueRouter.prototype.push = function push (location) {\n  this.history.push(location)\n};\n\nVueRouter.prototype.replace = function replace (location) {\n  this.history.replace(location)\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n)\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1)\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1)\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).resolved\n    : this.currentRoute\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var normalizedTo = normalizeLocation(to, current || this.history.current, append)\n  var resolved = this.match(normalizedTo, current)\n  var fullPath = resolved.redirectedFrom || resolved.fullPath\n  var base = this.history.base\n  var href = createHref(base, fullPath, this.mode)\n  return {\n    normalizedTo: normalizedTo,\n    resolved: resolved,\n    href: href\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter)\n}\n\nmodule.exports = VueRouter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-router/dist/vue-router.common.js\n// module id = 199\n// module chunks = 1","var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \";\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && +chrome[1] < 57\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var name = ((!brokenModifierNames || !event.ctrlKey && !event.altKey && !event.metaKey) && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  return name\n}\n\nmodule.exports = keyName\nkeyName.base = base\nkeyName.shift = shift\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/w3c-keyname/index.js\n// module id = 200\n// module chunks = 1","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 201\n// module chunks = 1","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/addStyles.js\n// module id = 202\n// module chunks = 1"],"sourceRoot":""}